{"version":3,"sources":["../src/combineFragments.js"],"names":[],"mappings":";;;;;;;;;;QAGgB,gB,GAAA,gB;;AAHhB;;AACA;;AAEO,SAAS,gBAAT,CAA0B,gBAA1B,EAA4C,gBAA5C,EAA8D;AACjE,QAAI,oBAAoB,QAAO,gBAAP,yCAAO,gBAAP,OAA4B,QAApD,EAA8D;AAC1D,2BAAoB,UAAS,cAAT,EAAyB;AACzC,mBAAO,UAAS,KAAT,EAAgB,GAAhB,EAAqB,KAArB,EAA4B;AAC/B,uBAAO,eAAe,GAAf,CAAP;AACH,aAFD;AAGH,SAJmB,CAIlB,gBAJkB,CAApB;AAKH;AACD,WAAO,SAAS,uBAAT,CAAiC,YAAjC,EAA+C,YAA/C,EAA6D;AAChE,YAAM,YAAY,iBAAiB,YAAjB,EAA+B,YAA/B,CAAlB;AACA,eAAO,SAAS,gBAAT,CAA0B,OAA1B,EAAmC,KAAnC,EAA0C;AAC7C,gBAAM,eAAe,IAAI,KAAJ,CAAU,CAAV,CAArB;AACA;AACA;AACA,gBAAM,qBAAqB,eAAe,OAAf,EAAwB,gBAAxB,CAA3B;AACA,mBAAO,UAAU,OAAV,EAAmB,KAAnB,EAA0B,SAA1B,CACH,kBADG,EAEH,gBAAiB,QAAjB,EAA8B;AAAA;;AAAA,oBAA5B,KAA4B;AAAA,oBAArB,KAAqB;;AAC1B,6BAAa,CAAb,IAAkB,KAAlB;AACA,6BAAa,CAAb,IAAkB,QAAlB;AACA,uBAAO,YAAP;AACH,aANE,CAAP;AAQH,SAbD;AAcH,KAhBD;AAiBH;;AAED,SAAS,cAAT,CAAwB,OAAxB,EAAiC,gBAAjC,EAAmD;AAC/C,QAAM,QAAQ,EAAd;AACA,QAAM,YAAY,EAAlB;AACA,QAAM,iBAAiB,EAAvB;AACA,WAAO,SAAS,kBAAT,QAA4C;AAAA;;AAAA,YAAf,KAAe;AAAA,YAAR,KAAQ;;;AAE/C,YAAI,QAAQ,CAAZ;AAAA,YAAe,iBAAf;AAAA,YAAyB,sBAAzB;;AAEA,aAAK,IAAM,WAAX,IAA0B,KAA1B,EAAiC;;AAE7B,gBAAM,gBAAgB,MAAM,WAAN,CAAtB;;AAEA,gBAAI,CAAC,WAAW,UAAU,WAAV,CAAZ,MAAwC,SAA5C,EAAuD;AACnD,2BAAW,iBAAiB,KAAjB,EAAwB,WAAxB,EAAqC,aAArC,CAAX;AACA,oBAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAChC,+BAAW,UAAU,WAAV,IAAyB,KAApC;AACH;AACJ;;AAED,gBAAI,aAAa,KAAjB,EAAwB;AACpB;AACH;;AAED,gBAAI,EAAE,gBAAgB,eAAe,WAAf,CAAlB,CAAJ,EAAoD;AAChD,gCAAgB,2BAAhB;AACA,+BAAe,WAAf,IAA8B,aAA9B;AACA,2BAAW,UAAU,WAAV,IAAyB;AAChC,yBAAK,WAD2B;AAEhC,0BAAM,SACF,cAAO,IAAP,CAAY,aAAZ,CADE,EAEF,WAFE,EAGJ,OAHI,EAGK,aAHL;AAF0B,iBAApC;AAOH;;AAED,kBAAM,OAAN,IAAiB,QAAjB;AACA,0BAAc,IAAd,CAAmB,CAAC,KAAD,EAAQ,KAAR,CAAnB;AACH;;AAED,eAAO,MAAM,MAAN,GAAe,KAAtB,EAA6B;AAAA,6BACT,MAAM,GAAN,EADS;;AAAA,gBACjB,GADiB,cACjB,GADiB;;AAEzB,gBAAM,iBAAgB,eAAe,GAAf,CAAtB;AACA,mBAAO,UAAU,GAAV,CAAP;AACA,mBAAO,eAAe,GAAf,CAAP;AACA,2BAAc,QAAd;AACH;;AAED,YAAI,MAAM,MAAN,KAAiB,CAArB,EAAwB;AACpB,mBAAO,iBAAW,EAAX,CAAc,KAAd,CAAP;AACH;;AAED,eAAO,iBAAW,aAAX,CAAyB,MAAM,GAAN,CAAU,iBAAmB;AAAA,gBAAhB,IAAgB,SAAhB,IAAgB;AAAA,gBAAV,GAAU,SAAV,GAAU;;AACzD,mBAAO,KAAK,GAAL,CAAS,iBAAuB;AAAA;;AAAA,oBAArB,KAAqB;AAAA,oBAAd,QAAc;;AACnC,sBAAM,GAAN,IAAa,QAAb;AACA,uBAAO,KAAP;AACH,aAHM,CAAP;AAIH,SAL+B,CAAzB,EAKH,UAAC,KAAD;AAAA,mBAAW,KAAX;AAAA,SALG,CAAP;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,KA7DD;AA8DH","file":"combineFragments.js","sourcesContent":["import { Models } from './utils';\nimport { Observable, BehaviorSubject } from 'rxjs';\n\nexport function combineFragments(pendingContainer, resolveFragments) {\n    if (resolveFragments && typeof resolveFragments === 'object') {\n        resolveFragments = (function(fragmentsTable) {\n            return function(state, key, value) {\n                return fragmentsTable[key];\n            }\n        }(resolveFragments));\n    }\n    return function partialCombinedFragment(falcorModels, fallbackPath) {\n        const container = pendingContainer(falcorModels, fallbackPath);\n        return function combinedFragment(action$, store) {\n            const arrayWrapper = new Array(2);\n            // Todo: Write a `differenceMap` merge strategy instead of\n            // switchMap + combineLatest-ing to Subjects\n            const groupIntoFragments = groupFragments(action$, resolveFragments);\n            return container(action$, store).switchMap(\n                groupIntoFragments,\n                ([model, state], newState) => {\n                    arrayWrapper[0] = model;\n                    arrayWrapper[1] = newState;\n                    return arrayWrapper;\n                }\n            );\n        }\n    }\n}\n\nfunction groupFragments(action$, resolveFragments) {\n    const epics = [];\n    const fragments = {};\n    const fragmentModels = {};\n    return function groupIntoFragments([model, state]) {\n\n        let index = 0, fragment, fragmentModel;\n\n        for (const fragmentKey in state) {\n\n            const fragmentValue = state[fragmentKey];\n\n            if ((fragment = fragments[fragmentKey]) === undefined) {\n                fragment = resolveFragments(state, fragmentKey, fragmentValue);\n                if (typeof fragment !== 'function') {\n                    fragment = fragments[fragmentKey] = false;\n                }\n            }\n\n            if (fragment === false) {\n                continue;\n            }\n\n            if (!(fragmentModel = fragmentModels[fragmentKey])) {\n                fragmentModel = new BehaviorSubject();\n                fragmentModels[fragmentKey] = fragmentModel;\n                fragment = fragments[fragmentKey] = {\n                    key: fragmentKey,\n                    epic: fragment(\n                        Models.from(fragmentModel),\n                        fragmentKey\n                    )(action$, fragmentValue)\n                };\n            }\n\n            epics[index++] = fragment;\n            fragmentModel.next([model, state]);\n        }\n\n        while (epics.length > index) {\n            const { key } = epics.pop();\n            const fragmentModel = fragmentModels[key];\n            delete fragments[key];\n            delete fragmentModels[key];\n            fragmentModel.complete();\n        }\n\n        if (epics.length === 0) {\n            return Observable.of(state);\n        }\n\n        return Observable.combineLatest(epics.map(({ epic, key }) => {\n            return epic.map(([model, newState]) => {\n                state[key] = newState;\n                return state;\n            });\n        }), (state) => state);\n\n        // Todo: shouldn't this work instead?\n        // return Observable.from(epics).mergeScan((state, { epic, key }) => {\n        //     return epic.map(([model, newState]) => {\n        //         state[key] = newState;\n        //         return state;\n        //     })\n        // }, state);\n    }\n}\n"]}