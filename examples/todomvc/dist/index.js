/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "dd36394f01bb33c9a4c0"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(74);
	module.exports = __webpack_require__(76);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var url = __webpack_require__(2);
	var SockJS = __webpack_require__(8);
	var stripAnsi = __webpack_require__(72);
	var scriptElements = document.getElementsByTagName("script");
	var scriptHost = scriptElements[scriptElements.length-1].getAttribute("src").replace(/\/[^\/]+$/, "");
	
	// If this bundle is inlined, use the resource query to get the correct url.
	// Else, get the url from the <script> this file was called with.
	var urlParts = url.parse( true ?
		__resourceQuery.substr(1) :
		(scriptHost ? scriptHost : "/")
	);
	
	var sock = null;
	var hot = false;
	var initial = true;
	var currentHash = "";
	
	var onSocketMsg = {
		hot: function() {
			hot = true;
			console.log("[WDS] Hot Module Replacement enabled.");
		},
		invalid: function() {
			console.log("[WDS] App updated. Recompiling...");
		},
		hash: function(hash) {
			currentHash = hash;
		},
		"still-ok": function() {
			console.log("[WDS] Nothing changed.")
		},
		ok: function() {
			if(initial) return initial = false;
			reloadApp();
		},
		warnings: function(warnings) {
			console.log("[WDS] Warnings while compiling.");
			for(var i = 0; i < warnings.length; i++)
				console.warn(stripAnsi(warnings[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		errors: function(errors) {
			console.log("[WDS] Errors while compiling.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		},
		"proxy-error": function(errors) {
			console.log("[WDS] Proxy error.");
			for(var i = 0; i < errors.length; i++)
				console.error(stripAnsi(errors[i]));
			if(initial) return initial = false;
			reloadApp();
		}
	};
	
	var newConnection = function() {
		sock = new SockJS(url.format({
			protocol: urlParts.protocol,
			auth: urlParts.auth,
			hostname: (urlParts.hostname === '0.0.0.0') ? window.location.hostname : urlParts.hostname,
			port: urlParts.port,
			pathname: urlParts.path === '/' ? "/sockjs-node" : urlParts.path
		}));
	
		sock.onclose = function() {
			console.error("[WDS] Disconnected!");
	
			// Try to reconnect.
			sock = null;
			setTimeout(function () {
				newConnection();
			}, 2000);
		};
	
		sock.onmessage = function(e) {
			// This assumes that all data sent via the websocket is JSON.
			var msg = JSON.parse(e.data);
			onSocketMsg[msg.type](msg.data);
		};
	};
	
	newConnection();
	
	function reloadApp() {
		if(hot) {
			console.log("[WDS] App hot update...");
			window.postMessage("webpackHotUpdate" + currentHash, "*");
		} else {
			console.log("[WDS] App updated. Reloading...");
			window.location.reload();
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "?http://localhost:8080"))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var punycode = __webpack_require__(3);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(5);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};
	
	function isString(arg) {
	  return typeof arg === "string";
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(6);
	exports.encode = exports.stringify = __webpack_require__(7);


/***/ },
/* 6 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 7 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var transportList = __webpack_require__(9);
	
	module.exports = __webpack_require__(56)(transportList);
	
	// TODO can't get rid of this until all servers do
	if ('_sockjs_onload' in global) {
	  setTimeout(global._sockjs_onload, 1);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = [
	  // streaming transports
	  __webpack_require__(10)
	, __webpack_require__(27)
	, __webpack_require__(37)
	, __webpack_require__(39)
	, __webpack_require__(42)(__webpack_require__(39))
	
	  // polling transports
	, __webpack_require__(49)
	, __webpack_require__(42)(__webpack_require__(49))
	, __webpack_require__(51)
	, __webpack_require__(52)
	, __webpack_require__(42)(__webpack_require__(51))
	, __webpack_require__(53)
	];


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var utils = __webpack_require__(12)
	  , urlUtils = __webpack_require__(15)
	  , inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  , WebsocketDriver = __webpack_require__(26)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:websocket');
	}
	
	function WebSocketTransport(transUrl) {
	  if (!WebSocketTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  EventEmitter.call(this);
	  debug('constructor', transUrl);
	
	  var self = this;
	  var url = urlUtils.addPath(transUrl, '/websocket');
	  if (url.slice(0, 5) === 'https') {
	    url = 'wss' + url.slice(5);
	  } else {
	    url = 'ws' + url.slice(4);
	  }
	  this.url = url;
	
	  this.ws = new WebsocketDriver(this.url);
	  this.ws.onmessage = function(e) {
	    debug('message event', e.data);
	    self.emit('message', e.data);
	  };
	  // Firefox has an interesting bug. If a websocket connection is
	  // created after onunload, it stays alive even when user
	  // navigates away from the page. In such situation let's lie -
	  // let's not open the ws connection at all. See:
	  // https://github.com/sockjs/sockjs-client/issues/28
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload');
	    self.ws.close();
	  });
	  this.ws.onclose = function(e) {
	    debug('close event', e.code, e.reason);
	    self.emit('close', e.code, e.reason);
	    self._cleanup();
	  };
	  this.ws.onerror = function(e) {
	    debug('error event', e);
	    self.emit('close', 1006, 'WebSocket connection broken');
	    self._cleanup();
	  };
	}
	
	inherits(WebSocketTransport, EventEmitter);
	
	WebSocketTransport.prototype.send = function(data) {
	  var msg = '[' + data + ']';
	  debug('send', msg);
	  this.ws.send(msg);
	};
	
	WebSocketTransport.prototype.close = function() {
	  debug('close');
	  if (this.ws) {
	    this.ws.close();
	  }
	  this._cleanup();
	};
	
	WebSocketTransport.prototype._cleanup = function() {
	  debug('_cleanup');
	  var ws = this.ws;
	  if (ws) {
	    ws.onmessage = ws.onclose = ws.onerror = null;
	  }
	  utils.unloadDel(this.unloadRef);
	  this.unloadRef = this.ws = null;
	  this.removeAllListeners();
	};
	
	WebSocketTransport.enabled = function() {
	  debug('enabled');
	  return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = 'websocket';
	
	// In theory, ws should require 1 round trip. But in chrome, this is
	// not very stable over SSL. Most likely a ws connection requires a
	// separate SSL connection, in which case 2 round trips are an
	// absolute minumum.
	WebSocketTransport.roundTrips = 2;
	
	module.exports = WebSocketTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var random = __webpack_require__(13);
	
	var onUnload = {}
	  , afterUnload = false
	    // detect google chrome packaged apps because they don't allow the 'unload' event
	  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
	  ;
	
	module.exports = {
	  attachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.addEventListener(event, listener, false);
	    } else if (global.document && global.attachEvent) {
	      // IE quirks.
	      // According to: http://stevesouders.com/misc/test-postmessage.php
	      // the message gets delivered only to 'document', not 'window'.
	      global.document.attachEvent('on' + event, listener);
	      // I get 'window' for ie8.
	      global.attachEvent('on' + event, listener);
	    }
	  }
	
	, detachEvent: function(event, listener) {
	    if (typeof global.addEventListener !== 'undefined') {
	      global.removeEventListener(event, listener, false);
	    } else if (global.document && global.detachEvent) {
	      global.document.detachEvent('on' + event, listener);
	      global.detachEvent('on' + event, listener);
	    }
	  }
	
	, unloadAdd: function(listener) {
	    if (isChromePackagedApp) {
	      return null;
	    }
	
	    var ref = random.string(8);
	    onUnload[ref] = listener;
	    if (afterUnload) {
	      setTimeout(this.triggerUnloadCallbacks, 0);
	    }
	    return ref;
	  }
	
	, unloadDel: function(ref) {
	    if (ref in onUnload) {
	      delete onUnload[ref];
	    }
	  }
	
	, triggerUnloadCallbacks: function() {
	    for (var ref in onUnload) {
	      onUnload[ref]();
	      delete onUnload[ref];
	    }
	  }
	};
	
	var unloadTriggered = function() {
	  if (afterUnload) {
	    return;
	  }
	  afterUnload = true;
	  module.exports.triggerUnloadCallbacks();
	};
	
	// 'unload' alone is not reliable in opera within an iframe, but we
	// can't use `beforeunload` as IE fires it on javascript: links.
	if (!isChromePackagedApp) {
	  module.exports.attachEvent('unload', unloadTriggered);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/* global crypto:true */
	var crypto = __webpack_require__(14);
	
	// This string has length 32, a power of 2, so the modulus doesn't introduce a
	// bias.
	var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
	module.exports = {
	  string: function(length) {
	    var max = _randomStringChars.length;
	    var bytes = crypto.randomBytes(length);
	    var ret = [];
	    for (var i = 0; i < length; i++) {
	      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
	    }
	    return ret.join('');
	  }
	
	, number: function(max) {
	    return Math.floor(Math.random() * max);
	  }
	
	, numberString: function(max) {
	    var t = ('' + (max - 1)).length;
	    var p = new Array(t + 1).join('0');
	    return (p + this.number(max)).slice(-t);
	  }
	};


/***/ },
/* 14 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	if (global.crypto && global.crypto.getRandomValues) {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Uint8Array(length);
	    global.crypto.getRandomValues(bytes);
	    return bytes;
	  };
	} else {
	  module.exports.randomBytes = function(length) {
	    var bytes = new Array(length);
	    for (var i = 0; i < length; i++) {
	      bytes[i] = Math.floor(Math.random() * 256);
	    }
	    return bytes;
	  };
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var URL = __webpack_require__(16);
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:utils:url');
	}
	
	module.exports = {
	  getOrigin: function(url) {
	    if (!url) {
	      return null;
	    }
	
	    var p = new URL(url);
	    if (p.protocol === 'file:') {
	      return null;
	    }
	
	    var port = p.port;
	    if (!port) {
	      port = (p.protocol === 'https:') ? '443' : '80';
	    }
	
	    return p.protocol + '//' + p.hostname + ':' + port;
	  }
	
	, isOriginEqual: function(a, b) {
	    var res = this.getOrigin(a) === this.getOrigin(b);
	    debug('same', a, b, res);
	    return res;
	  }
	
	, isSchemeEqual: function(a, b) {
	    return (a.split(':')[0] === b.split(':')[0]);
	  }
	
	, addPath: function (url, path) {
	    var qs = url.split('?');
	    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
	  }
	
	, addQuery: function (url, q) {
	    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var required = __webpack_require__(17)
	  , lolcation = __webpack_require__(18)
	  , qs = __webpack_require__(19)
	  , relativere = /^\/(?!\/)/
	  , protocolre = /^([a-z0-9.+-]+:)?(\/\/)?(.*)$/i; // actual protocol is first match
	
	/**
	 * These are the parse instructions for the URL parsers, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it's a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it's backwards or forward parsing, when set as number it's
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var instructions = [
	  ['#', 'hash'],                        // Extract from the back.
	  ['?', 'query'],                       // Extract from the back.
	  ['/', 'pathname'],                    // Extract from the back.
	  ['@', 'auth', 1],                     // Extract from the front.
	  [NaN, 'host', undefined, 1, 1],       // Set left over value.
	  [/\:(\d+)$/, 'port'],                 // RegExp the back.
	  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
	];
	
	 /**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase
	 * @property {Boolean} slashes Indicates whether the protocol is followed by double slash ("//")
	 * @property {String} rest     Rest of the URL that is not part of the protocol
	 */
	
	 /**
	  * Extract protocol information from a URL with/without double slash ("//")
	  *
	  * @param  {String} address   URL we want to extract from.
	  * @return {ProtocolExtract}  Extracted information
	  * @private
	  */
	function extractProtocol(address) {
	  var match = protocolre.exec(address);
	  return {
	    protocol: match[1] ? match[1].toLowerCase() : '',
	    slashes: !!match[2],
	    rest: match[3] ? match[3] : ''
	  };
	}
	
	/**
	 * The actual URL instance. Instead of returning an object we've opted-in to
	 * create an actual constructor as it's much more memory efficient and
	 * faster and it pleases my CDO.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} location Location defaults for relative paths.
	 * @param {Boolean|Function} parser Parser for the query string.
	 * @api public
	 */
	function URL(address, location, parser) {
	  if (!(this instanceof URL)) {
	    return new URL(address, location, parser);
	  }
	
	  var relative = relativere.test(address)
	    , parse, instruction, index, key
	    , type = typeof location
	    , url = this
	    , i = 0;
	
	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if ('object' !== type && 'string' !== type) {
	    parser = location;
	    location = null;
	  }
	
	  if (parser && 'function' !== typeof parser) {
	    parser = qs.parse;
	  }
	
	  location = lolcation(location);
	
	  // extract protocol information before running the instructions
	  var extracted = extractProtocol(address);
	  url.protocol = extracted.protocol || location.protocol || '';
	  url.slashes = extracted.slashes || location.slashes;
	  address = extracted.rest;
	
	  for (; i < instructions.length; i++) {
	    instruction = instructions[i];
	    parse = instruction[0];
	    key = instruction[1];
	
	    if (parse !== parse) {
	      url[key] = address;
	    } else if ('string' === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if ('number' === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if (index = parse.exec(address)) {
	      url[key] = index[1];
	      address = address.slice(0, address.length - index[0].length);
	    }
	
	    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');
	
	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) {
	      url[key] = url[key].toLowerCase();
	    }
	  }
	
	  //
	  // Also parse the supplied query string in to an object. If we're supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);
	
	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we're going
	  // override it with the hostname which contains no port number.
	  //
	  if (!required(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = '';
	  }
	
	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = '';
	  if (url.auth) {
	    instruction = url.auth.split(':');
	    url.username = instruction[0] || '';
	    url.password = instruction[1] || '';
	  }
	
	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}
	
	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} prop          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse
	 *                               the query.
	 *                               When setting the protocol, double slash will be removed from
	 *                               the final url if it is true.
	 * @returns {URL}
	 * @api public
	 */
	URL.prototype.set = function set(part, value, fn) {
	  var url = this;
	
	  if ('query' === part) {
	    if ('string' === typeof value && value.length) {
	      value = (fn || qs.parse)(value);
	    }
	
	    url[part] = value;
	  } else if ('port' === part) {
	    url[part] = value;
	
	    if (!required(value, url.protocol)) {
	      url.host = url.hostname;
	      url[part] = '';
	    } else if (value) {
	      url.host = url.hostname +':'+ value;
	    }
	  } else if ('hostname' === part) {
	    url[part] = value;
	
	    if (url.port) value += ':'+ url.port;
	    url.host = value;
	  } else if ('host' === part) {
	    url[part] = value;
	
	    if (/\:\d+/.test(value)) {
	      value = value.split(':');
	      url.hostname = value[0];
	      url.port = value[1];
	    }
	  } else if ('protocol' === part) {
	    url.protocol = value;
	    url.slashes = !fn;
	  } else {
	    url[part] = value;
	  }
	
	  url.href = url.toString();
	  return url;
	};
	
	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String}
	 * @api public
	 */
	URL.prototype.toString = function toString(stringify) {
	  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
	
	  var query
	    , url = this
	    , protocol = url.protocol;
	
	  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
	
	  var result = protocol + (url.slashes ? '//' : '');
	
	  if (url.username) {
	    result += url.username;
	    if (url.password) result += ':'+ url.password;
	    result += '@';
	  }
	
	  result += url.hostname;
	  if (url.port) result += ':'+ url.port;
	
	  result += url.pathname;
	
	  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
	  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
	
	  if (url.hash) result += url.hash;
	
	  return result;
	};
	
	//
	// Expose the URL parser and some additional properties that might be useful for
	// others.
	//
	URL.qs = qs;
	URL.location = lolcation;
	module.exports = URL;


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Check if we're required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	module.exports = function required(port, protocol) {
	  protocol = protocol.split(':')[0];
	  port = +port;
	
	  if (!port) return false;
	
	  switch (protocol) {
	    case 'http':
	    case 'ws':
	    return port !== 80;
	
	    case 'https':
	    case 'wss':
	    return port !== 443;
	
	    case 'ftp':
	    return port !== 21;
	
	    case 'gopher':
	    return port !== 70;
	
	    case 'file':
	    return false;
	  }
	
	  return port !== 0;
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
	
	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL's as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 }
	  , URL;
	
	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good "default"
	 * location from it so we can generate proper relative URL's again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @api public
	 */
	module.exports = function lolcation(loc) {
	  loc = loc || global.location || {};
	  URL = URL || __webpack_require__(16);
	
	  var finaldestination = {}
	    , type = typeof loc
	    , key;
	
	  if ('blob:' === loc.protocol) {
	    finaldestination = new URL(unescape(loc.pathname), {});
	  } else if ('string' === type) {
	    finaldestination = new URL(loc, {});
	    for (key in ignore) delete finaldestination[key];
	  } else if ('object' === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }
	
	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }
	
	  return finaldestination;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 19 */
/***/ function(module, exports) {

	'use strict';
	
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?&]+)=([^&]*)/g
	    , result = {}
	    , part;
	
	  //
	  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
	  // the lastIndex property so we can continue executing this loop until we've
	  // parsed all results.
	  //
	  for (;
	    part = parser.exec(query);
	    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
	  );
	
	  return result;
	}
	
	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || '';
	
	  var pairs = [];
	
	  //
	  // Optionally prefix with a '?' if needed
	  //
	  if ('string' !== typeof prefix) prefix = '?';
	
	  for (var key in obj) {
	    if (has.call(obj, key)) {
	      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
	    }
	  }
	
	  return pairs.length ? prefix + pairs.join('&') : '';
	}
	
	//
	// Expose the module.
	//
	exports.stringify = querystringify;
	exports.parse = querystring;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(21);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(22);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventTarget = __webpack_require__(25)
	  ;
	
	function EventEmitter() {
	  EventTarget.call(this);
	}
	
	inherits(EventEmitter, EventTarget);
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  if (type) {
	    delete this._listeners[type];
	  } else {
	    this._listeners = {};
	  }
	};
	
	EventEmitter.prototype.once = function(type, listener) {
	  var self = this
	    , fired = false;
	
	  function g() {
	    self.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  this.on(type, g);
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var listeners = this._listeners[type];
	  if (!listeners) {
	    return;
	  }
	  var args = Array.prototype.slice.call(arguments, 1);
	  for (var i = 0; i < listeners.length; i++) {
	    listeners[i].apply(this, args);
	  }
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
	EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;
	
	module.exports.EventEmitter = EventEmitter;


/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';
	
	/* Simplified implementation of DOM2 EventTarget.
	 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
	 */
	
	function EventTarget() {
	  this._listeners = {};
	}
	
	EventTarget.prototype.addEventListener = function(eventType, listener) {
	  if (!(eventType in this._listeners)) {
	    this._listeners[eventType] = [];
	  }
	  var arr = this._listeners[eventType];
	  // #4
	  if (arr.indexOf(listener) === -1) {
	    // Make a copy so as not to interfere with a current dispatchEvent.
	    arr = arr.concat([listener]);
	  }
	  this._listeners[eventType] = arr;
	};
	
	EventTarget.prototype.removeEventListener = function(eventType, listener) {
	  var arr = this._listeners[eventType];
	  if (!arr) {
	    return;
	  }
	  var idx = arr.indexOf(listener);
	  if (idx !== -1) {
	    if (arr.length > 1) {
	      // Make a copy so as not to interfere with a current dispatchEvent.
	      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
	    } else {
	      delete this._listeners[eventType];
	    }
	    return;
	  }
	};
	
	EventTarget.prototype.dispatchEvent = function(event) {
	  var t = event.type;
	  var args = Array.prototype.slice.call(arguments, 0);
	  // TODO: This doesn't match the real behavior; per spec, onfoo get
	  // their place in line from the /first/ time they're set from
	  // non-null. Although WebKit bumps it to the end every time it's
	  // set.
	  if (this['on' + t]) {
	    this['on' + t].apply(this, args);
	  }
	  if (t in this._listeners) {
	    // Grab a reference to the listeners list. removeEventListener may alter the list.
	    var listeners = this._listeners[t];
	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].apply(this, args);
	    }
	  }
	};
	
	module.exports = EventTarget;


/***/ },
/* 26 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.WebSocket || global.MozWebSocket;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , AjaxBasedTransport = __webpack_require__(28)
	  , XhrReceiver = __webpack_require__(32)
	  , XHRCorsObject = __webpack_require__(33)
	  , XHRLocalObject = __webpack_require__(35)
	  , browser = __webpack_require__(36)
	  ;
	
	function XhrStreamingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrStreamingTransport, AjaxBasedTransport);
	
	XhrStreamingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	  // Opera doesn't support xhr-streaming #60
	  // But it might be able to #92
	  if (browser.isOpera()) {
	    return false;
	  }
	
	  return XHRCorsObject.enabled;
	};
	
	XhrStreamingTransport.transportName = 'xhr-streaming';
	XhrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	// Safari gets confused when a streaming ajax request is started
	// before onload. This causes the load indicator to spin indefinetely.
	// Only require body when used in a browser
	XhrStreamingTransport.needBody = !!global.document;
	
	module.exports = XhrStreamingTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , urlUtils = __webpack_require__(15)
	  , SenderReceiver = __webpack_require__(29)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:ajax-based');
	}
	
	function createAjaxSender(AjaxObject) {
	  return function(url, payload, callback) {
	    debug('create ajax sender', url, payload);
	    var opt = {};
	    if (typeof payload === 'string') {
	      opt.headers = {'Content-type':'text/plain'};
	    }
	    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
	    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
	    xo.once('finish', function(status) {
	      debug('finish', status);
	      xo = null;
	
	      if (status !== 200 && status !== 204) {
	        return callback(new Error('http status ' + status));
	      }
	      callback();
	    });
	    return function() {
	      debug('abort');
	      xo.close();
	      xo = null;
	
	      var err = new Error('Aborted');
	      err.code = 1000;
	      callback(err);
	    };
	  };
	}
	
	function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
	  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}
	
	inherits(AjaxBasedTransport, SenderReceiver);
	
	module.exports = AjaxBasedTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , urlUtils = __webpack_require__(15)
	  , BufferedSender = __webpack_require__(30)
	  , Polling = __webpack_require__(31)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:sender-receiver');
	}
	
	function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
	  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
	  debug(pollUrl);
	  var self = this;
	  BufferedSender.call(this, transUrl, senderFunc);
	
	  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
	  this.poll.on('message', function(msg) {
	    debug('poll message', msg);
	    self.emit('message', msg);
	  });
	  this.poll.once('close', function(code, reason) {
	    debug('poll close', code, reason);
	    self.poll = null;
	    self.emit('close', code, reason);
	    self.close();
	  });
	}
	
	inherits(SenderReceiver, BufferedSender);
	
	SenderReceiver.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  if (this.poll) {
	    this.poll.abort();
	    this.poll = null;
	  }
	  this.stop();
	};
	
	module.exports = SenderReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:buffered-sender');
	}
	
	function BufferedSender(url, sender) {
	  debug(url);
	  EventEmitter.call(this);
	  this.sendBuffer = [];
	  this.sender = sender;
	  this.url = url;
	}
	
	inherits(BufferedSender, EventEmitter);
	
	BufferedSender.prototype.send = function(message) {
	  debug('send', message);
	  this.sendBuffer.push(message);
	  if (!this.sendStop) {
	    this.sendSchedule();
	  }
	};
	
	// For polling transports in a situation when in the message callback,
	// new message is being send. If the sending connection was started
	// before receiving one, it is possible to saturate the network and
	// timeout due to the lack of receiving socket. To avoid that we delay
	// sending messages by some small time, in order to let receiving
	// connection be started beforehand. This is only a halfmeasure and
	// does not fix the big problem, but it does make the tests go more
	// stable on slow networks.
	BufferedSender.prototype.sendScheduleWait = function() {
	  debug('sendScheduleWait');
	  var self = this;
	  var tref;
	  this.sendStop = function() {
	    debug('sendStop');
	    self.sendStop = null;
	    clearTimeout(tref);
	  };
	  tref = setTimeout(function() {
	    debug('timeout');
	    self.sendStop = null;
	    self.sendSchedule();
	  }, 25);
	};
	
	BufferedSender.prototype.sendSchedule = function() {
	  debug('sendSchedule', this.sendBuffer.length);
	  var self = this;
	  if (this.sendBuffer.length > 0) {
	    var payload = '[' + this.sendBuffer.join(',') + ']';
	    this.sendStop = this.sender(this.url, payload, function(err) {
	      self.sendStop = null;
	      if (err) {
	        debug('error', err);
	        self.emit('close', err.code || 1006, 'Sending error: ' + err);
	        self._cleanup();
	      } else {
	        self.sendScheduleWait();
	      }
	    });
	    this.sendBuffer = [];
	  }
	};
	
	BufferedSender.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	BufferedSender.prototype.stop = function() {
	  debug('stop');
	  this._cleanup();
	  if (this.sendStop) {
	    this.sendStop();
	    this.sendStop = null;
	  }
	};
	
	module.exports = BufferedSender;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:polling');
	}
	
	function Polling(Receiver, receiveUrl, AjaxObject) {
	  debug(receiveUrl);
	  EventEmitter.call(this);
	  this.Receiver = Receiver;
	  this.receiveUrl = receiveUrl;
	  this.AjaxObject = AjaxObject;
	  this._scheduleReceiver();
	}
	
	inherits(Polling, EventEmitter);
	
	Polling.prototype._scheduleReceiver = function() {
	  debug('_scheduleReceiver');
	  var self = this;
	  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);
	
	  poll.on('message', function(msg) {
	    debug('message', msg);
	    self.emit('message', msg);
	  });
	
	  poll.once('close', function(code, reason) {
	    debug('close', code, reason, self.pollIsClosing);
	    self.poll = poll = null;
	
	    if (!self.pollIsClosing) {
	      if (reason === 'network') {
	        self._scheduleReceiver();
	      } else {
	        self.emit('close', code || 1006, reason);
	        self.removeAllListeners();
	      }
	    }
	  });
	};
	
	Polling.prototype.abort = function() {
	  debug('abort');
	  this.removeAllListeners();
	  this.pollIsClosing = true;
	  if (this.poll) {
	    this.poll.abort();
	  }
	};
	
	module.exports = Polling;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:receiver:xhr');
	}
	
	function XhrReceiver(url, AjaxObject) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	
	  this.bufferPosition = 0;
	
	  this.xo = new AjaxObject('POST', url, null);
	  this.xo.on('chunk', this._chunkHandler.bind(this));
	  this.xo.once('finish', function(status, text) {
	    debug('finish', status, text);
	    self._chunkHandler(status, text);
	    self.xo = null;
	    var reason = status === 200 ? 'network' : 'permanent';
	    debug('close', reason);
	    self.emit('close', null, reason);
	    self._cleanup();
	  });
	}
	
	inherits(XhrReceiver, EventEmitter);
	
	XhrReceiver.prototype._chunkHandler = function(status, text) {
	  debug('_chunkHandler', status);
	  if (status !== 200 || !text) {
	    return;
	  }
	
	  for (var idx = -1; ; this.bufferPosition += idx + 1) {
	    var buf = text.slice(this.bufferPosition);
	    idx = buf.indexOf('\n');
	    if (idx === -1) {
	      break;
	    }
	    var msg = buf.slice(0, idx);
	    if (msg) {
	      debug('message', msg);
	      this.emit('message', msg);
	    }
	  }
	};
	
	XhrReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  this.removeAllListeners();
	};
	
	XhrReceiver.prototype.abort = function() {
	  debug('abort');
	  if (this.xo) {
	    this.xo.close();
	    debug('close');
	    this.emit('close', null, 'user');
	    this.xo = null;
	  }
	  this._cleanup();
	};
	
	module.exports = XhrReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , XhrDriver = __webpack_require__(34)
	  ;
	
	function XHRCorsObject(method, url, payload, opts) {
	  XhrDriver.call(this, method, url, payload, opts);
	}
	
	inherits(XHRCorsObject, XhrDriver);
	
	XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;
	
	module.exports = XHRCorsObject;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  , utils = __webpack_require__(12)
	  , urlUtils = __webpack_require__(15)
	  , XHR = global.XMLHttpRequest
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:browser:xhr');
	}
	
	function AbstractXHRObject(method, url, payload, opts) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function () {
	    self._start(method, url, payload, opts);
	  }, 0);
	}
	
	inherits(AbstractXHRObject, EventEmitter);
	
	AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
	  var self = this;
	
	  try {
	    this.xhr = new XHR();
	  } catch (x) {}
	
	  if (!this.xhr) {
	    debug('no xhr');
	    this.emit('finish', 0, 'no xhr support');
	    this._cleanup();
	    return;
	  }
	
	  // several browsers cache POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  // Explorer tends to keep connection open, even after the
	  // tab gets closed: http://bugs.jquery.com/ticket/5280
	  this.unloadRef = utils.unloadAdd(function() {
	    debug('unload cleanup');
	    self._cleanup(true);
	  });
	  try {
	    this.xhr.open(method, url, true);
	    if (this.timeout && 'timeout' in this.xhr) {
	      this.xhr.timeout = this.timeout;
	      this.xhr.ontimeout = function() {
	        debug('xhr timeout');
	        self.emit('finish', 0, '');
	        self._cleanup(false);
	      };
	    }
	  } catch (e) {
	    debug('exception', e);
	    // IE raises an exception on wrong port.
	    this.emit('finish', 0, '');
	    this._cleanup(false);
	    return;
	  }
	
	  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
	    debug('withCredentials');
	    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
	    // "This never affects same-site requests."
	
	    this.xhr.withCredentials = 'true';
	  }
	  if (opts && opts.headers) {
	    for (var key in opts.headers) {
	      this.xhr.setRequestHeader(key, opts.headers[key]);
	    }
	  }
	
	  this.xhr.onreadystatechange = function() {
	    if (self.xhr) {
	      var x = self.xhr;
	      var text, status;
	      debug('readyState', x.readyState);
	      switch (x.readyState) {
	      case 3:
	        // IE doesn't like peeking into responseText or status
	        // on Microsoft.XMLHTTP and readystate=3
	        try {
	          status = x.status;
	          text = x.responseText;
	        } catch (e) {}
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	
	        // IE does return readystate == 3 for 404 answers.
	        if (status === 200 && text && text.length > 0) {
	          debug('chunk');
	          self.emit('chunk', status, text);
	        }
	        break;
	      case 4:
	        status = x.status;
	        debug('status', status);
	        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
	        if (status === 1223) {
	          status = 204;
	        }
	        // IE returns this for a bad port
	        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
	        if (status === 12005 || status === 12029) {
	          status = 0;
	        }
	
	        debug('finish', status, x.responseText);
	        self.emit('finish', status, x.responseText);
	        self._cleanup(false);
	        break;
	      }
	    }
	  };
	
	  try {
	    self.xhr.send(payload);
	  } catch (e) {
	    self.emit('finish', 0, '');
	    self._cleanup(false);
	  }
	};
	
	AbstractXHRObject.prototype._cleanup = function(abort) {
	  debug('cleanup');
	  if (!this.xhr) {
	    return;
	  }
	  this.removeAllListeners();
	  utils.unloadDel(this.unloadRef);
	
	  // IE needs this field to be a function
	  this.xhr.onreadystatechange = function() {};
	  if (this.xhr.ontimeout) {
	    this.xhr.ontimeout = null;
	  }
	
	  if (abort) {
	    try {
	      this.xhr.abort();
	    } catch (x) {}
	  }
	  this.unloadRef = this.xhr = null;
	};
	
	AbstractXHRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	AbstractXHRObject.enabled = !!XHR;
	// override XMLHttpRequest for IE6/7
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (!AbstractXHRObject.enabled && (axo in global)) {
	  debug('overriding xmlhttprequest');
	  XHR = function() {
	    try {
	      return new global[axo]('Microsoft.XMLHTTP');
	    } catch (e) {
	      return null;
	    }
	  };
	  AbstractXHRObject.enabled = !!new XHR();
	}
	
	var cors = false;
	try {
	  cors = 'withCredentials' in new XHR();
	} catch (ignored) {}
	
	AbstractXHRObject.supportsCORS = cors;
	
	module.exports = AbstractXHRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , XhrDriver = __webpack_require__(34)
	  ;
	
	function XHRLocalObject(method, url, payload /*, opts */) {
	  XhrDriver.call(this, method, url, payload, {
	    noCredentials: true
	  });
	}
	
	inherits(XHRLocalObject, XhrDriver);
	
	XHRLocalObject.enabled = XhrDriver.enabled;
	
	module.exports = XHRLocalObject;


/***/ },
/* 36 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = {
	  isOpera: function() {
	    return global.navigator &&
	      /opera/i.test(global.navigator.userAgent);
	  }
	
	, isKonqueror: function() {
	    return global.navigator &&
	      /konqueror/i.test(global.navigator.userAgent);
	  }
	
	  // #187 wrap document.domain in try/catch because of WP8 from file:///
	, hasDomain: function () {
	    // non-browser client always has a domain
	    if (!global.document) {
	      return true;
	    }
	
	    try {
	      return !!global.document.domain;
	    } catch (e) {
	      return false;
	    }
	  }
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , AjaxBasedTransport = __webpack_require__(28)
	  , XhrReceiver = __webpack_require__(32)
	  , XDRObject = __webpack_require__(38)
	  ;
	
	// According to:
	//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
	//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/
	
	function XdrStreamingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
	}
	
	inherits(XdrStreamingTransport, AjaxBasedTransport);
	
	XdrStreamingTransport.enabled = function(info) {
	  if (info.cookie_needed || info.nullOrigin) {
	    return false;
	  }
	  return XDRObject.enabled && info.sameScheme;
	};
	
	XdrStreamingTransport.transportName = 'xdr-streaming';
	XdrStreamingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrStreamingTransport;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  , eventUtils = __webpack_require__(12)
	  , browser = __webpack_require__(36)
	  , urlUtils = __webpack_require__(15)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:sender:xdr');
	}
	
	// References:
	//   http://ajaxian.com/archives/100-line-ajax-wrapper
	//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
	
	function XDRObject(method, url, payload) {
	  debug(method, url);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self._start(method, url, payload);
	  }, 0);
	}
	
	inherits(XDRObject, EventEmitter);
	
	XDRObject.prototype._start = function(method, url, payload) {
	  debug('_start');
	  var self = this;
	  var xdr = new global.XDomainRequest();
	  // IE caches even POSTs
	  url = urlUtils.addQuery(url, 't=' + (+new Date()));
	
	  xdr.onerror = function() {
	    debug('onerror');
	    self._error();
	  };
	  xdr.ontimeout = function() {
	    debug('ontimeout');
	    self._error();
	  };
	  xdr.onprogress = function() {
	    debug('progress', xdr.responseText);
	    self.emit('chunk', 200, xdr.responseText);
	  };
	  xdr.onload = function() {
	    debug('load');
	    self.emit('finish', 200, xdr.responseText);
	    self._cleanup(false);
	  };
	  this.xdr = xdr;
	  this.unloadRef = eventUtils.unloadAdd(function() {
	    self._cleanup(true);
	  });
	  try {
	    // Fails with AccessDenied if port number is bogus
	    this.xdr.open(method, url);
	    if (this.timeout) {
	      this.xdr.timeout = this.timeout;
	    }
	    this.xdr.send(payload);
	  } catch (x) {
	    this._error();
	  }
	};
	
	XDRObject.prototype._error = function() {
	  this.emit('finish', 0, '');
	  this._cleanup(false);
	};
	
	XDRObject.prototype._cleanup = function(abort) {
	  debug('cleanup', abort);
	  if (!this.xdr) {
	    return;
	  }
	  this.removeAllListeners();
	  eventUtils.unloadDel(this.unloadRef);
	
	  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
	  if (abort) {
	    try {
	      this.xdr.abort();
	    } catch (x) {}
	  }
	  this.unloadRef = this.xdr = null;
	};
	
	XDRObject.prototype.close = function() {
	  debug('close');
	  this._cleanup(true);
	};
	
	// IE 8/9 if the request target uses the same scheme - #79
	XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());
	
	module.exports = XDRObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , AjaxBasedTransport = __webpack_require__(28)
	  , EventSourceReceiver = __webpack_require__(40)
	  , XHRCorsObject = __webpack_require__(33)
	  , EventSourceDriver = __webpack_require__(41)
	  ;
	
	function EventSourceTransport(transUrl) {
	  if (!EventSourceTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	
	  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
	}
	
	inherits(EventSourceTransport, AjaxBasedTransport);
	
	EventSourceTransport.enabled = function() {
	  return !!EventSourceDriver;
	};
	
	EventSourceTransport.transportName = 'eventsource';
	EventSourceTransport.roundTrips = 2;
	
	module.exports = EventSourceTransport;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  , EventSourceDriver = __webpack_require__(41)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:receiver:eventsource');
	}
	
	function EventSourceReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	
	  var self = this;
	  var es = this.es = new EventSourceDriver(url);
	  es.onmessage = function(e) {
	    debug('message', e.data);
	    self.emit('message', decodeURI(e.data));
	  };
	  es.onerror = function(e) {
	    debug('error', es.readyState, e);
	    // ES on reconnection has readyState = 0 or 1.
	    // on network error it's CLOSED = 2
	    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
	    self._cleanup();
	    self._close(reason);
	  };
	}
	
	inherits(EventSourceReceiver, EventEmitter);
	
	EventSourceReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	EventSourceReceiver.prototype._cleanup = function() {
	  debug('cleanup');
	  var es = this.es;
	  if (es) {
	    es.onmessage = es.onerror = null;
	    es.close();
	    this.es = null;
	  }
	};
	
	EventSourceReceiver.prototype._close = function(reason) {
	  debug('close', reason);
	  var self = this;
	  // Safari and chrome < 15 crash if we close window before
	  // waiting for ES cleanup. See:
	  // https://code.google.com/p/chromium/issues/detail?id=89155
	  setTimeout(function() {
	    self.emit('close', null, reason);
	    self.removeAllListeners();
	  }, 200);
	};
	
	module.exports = EventSourceReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 41 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.EventSource;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , IframeTransport = __webpack_require__(43)
	  , objectUtils = __webpack_require__(48)
	  ;
	
	module.exports = function(transport) {
	
	  function IframeWrapTransport(transUrl, baseUrl) {
	    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
	  }
	
	  inherits(IframeWrapTransport, IframeTransport);
	
	  IframeWrapTransport.enabled = function(url, info) {
	    if (!global.document) {
	      return false;
	    }
	
	    var iframeInfo = objectUtils.extend({}, info);
	    iframeInfo.sameOrigin = true;
	    return transport.enabled(iframeInfo) && IframeTransport.enabled();
	  };
	
	  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
	  IframeWrapTransport.needBody = true;
	  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)
	
	  IframeWrapTransport.facadeTransport = transport;
	
	  return IframeWrapTransport;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	// Few cool transports do work only for same-origin. In order to make
	// them work cross-domain we shall use iframe, served from the
	// remote domain. New browsers have capabilities to communicate with
	// cross domain iframe using postMessage(). In IE it was implemented
	// from IE 8+, but of course, IE got some details wrong:
	//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
	//    http://stevesouders.com/misc/test-postmessage.php
	
	var inherits = __webpack_require__(23)
	  , JSON3 = __webpack_require__(44)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  , version = __webpack_require__(46)
	  , urlUtils = __webpack_require__(15)
	  , iframeUtils = __webpack_require__(47)
	  , eventUtils = __webpack_require__(12)
	  , random = __webpack_require__(13)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:transport:iframe');
	}
	
	function IframeTransport(transport, transUrl, baseUrl) {
	  if (!IframeTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  EventEmitter.call(this);
	
	  var self = this;
	  this.origin = urlUtils.getOrigin(baseUrl);
	  this.baseUrl = baseUrl;
	  this.transUrl = transUrl;
	  this.transport = transport;
	  this.windowId = random.string(8);
	
	  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
	  debug(transport, transUrl, iframeUrl);
	
	  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
	    debug('err callback');
	    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
	    self.close();
	  });
	
	  this.onmessageCallback = this._message.bind(this);
	  eventUtils.attachEvent('message', this.onmessageCallback);
	}
	
	inherits(IframeTransport, EventEmitter);
	
	IframeTransport.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  if (this.iframeObj) {
	    eventUtils.detachEvent('message', this.onmessageCallback);
	    try {
	      // When the iframe is not loaded, IE raises an exception
	      // on 'contentWindow'.
	      this.postMessage('c');
	    } catch (x) {}
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	    this.onmessageCallback = this.iframeObj = null;
	  }
	};
	
	IframeTransport.prototype._message = function(e) {
	  debug('message', e.data);
	  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
	    debug('not same origin', e.origin, this.origin);
	    return;
	  }
	
	  var iframeMessage;
	  try {
	    iframeMessage = JSON3.parse(e.data);
	  } catch (ignored) {
	    debug('bad json', e.data);
	    return;
	  }
	
	  if (iframeMessage.windowId !== this.windowId) {
	    debug('mismatched window id', iframeMessage.windowId, this.windowId);
	    return;
	  }
	
	  switch (iframeMessage.type) {
	  case 's':
	    this.iframeObj.loaded();
	    // window global dependency
	    this.postMessage('s', JSON3.stringify([
	      version
	    , this.transport
	    , this.transUrl
	    , this.baseUrl
	    ]));
	    break;
	  case 't':
	    this.emit('message', iframeMessage.data);
	    break;
	  case 'c':
	    var cdata;
	    try {
	      cdata = JSON3.parse(iframeMessage.data);
	    } catch (ignored) {
	      debug('bad json', iframeMessage.data);
	      return;
	    }
	    this.emit('close', cdata[0], cdata[1]);
	    this.close();
	    break;
	  }
	};
	
	IframeTransport.prototype.postMessage = function(type, data) {
	  debug('postMessage', type, data);
	  this.iframeObj.post(JSON3.stringify({
	    windowId: this.windowId
	  , type: type
	  , data: data || ''
	  }), this.origin);
	};
	
	IframeTransport.prototype.send = function(message) {
	  debug('send', message);
	  this.postMessage('m', message);
	};
	
	IframeTransport.enabled = function() {
	  return iframeUtils.iframeEnabled;
	};
	
	IframeTransport.transportName = 'iframe';
	IframeTransport.roundTrips = 2;
	
	module.exports = IframeTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
	;(function () {
	  // Detect the `define` function exposed by asynchronous module loaders. The
	  // strict `define` check is necessary for compatibility with `r.js`.
	  var isLoader = "function" === "function" && __webpack_require__(45);
	
	  // A set of types used to distinguish objects from primitives.
	  var objectTypes = {
	    "function": true,
	    "object": true
	  };
	
	  // Detect the `exports` object exposed by CommonJS implementations.
	  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	
	  // Use the `global` object exposed by Node (including Browserify via
	  // `insert-module-globals`), Narwhal, and Ringo as the default context,
	  // and the `window` object in browsers. Rhino exports a `global` function
	  // instead.
	  var root = objectTypes[typeof window] && window || this,
	      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
	
	  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
	    root = freeGlobal;
	  }
	
	  // Public: Initializes JSON 3 using the given `context` object, attaching the
	  // `stringify` and `parse` functions to the specified `exports` object.
	  function runInContext(context, exports) {
	    context || (context = root["Object"]());
	    exports || (exports = root["Object"]());
	
	    // Native constructor aliases.
	    var Number = context["Number"] || root["Number"],
	        String = context["String"] || root["String"],
	        Object = context["Object"] || root["Object"],
	        Date = context["Date"] || root["Date"],
	        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
	        TypeError = context["TypeError"] || root["TypeError"],
	        Math = context["Math"] || root["Math"],
	        nativeJSON = context["JSON"] || root["JSON"];
	
	    // Delegate to the native `stringify` and `parse` implementations.
	    if (typeof nativeJSON == "object" && nativeJSON) {
	      exports.stringify = nativeJSON.stringify;
	      exports.parse = nativeJSON.parse;
	    }
	
	    // Convenience aliases.
	    var objectProto = Object.prototype,
	        getClass = objectProto.toString,
	        isProperty, forEach, undef;
	
	    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
	    var isExtended = new Date(-3509827334573292);
	    try {
	      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
	      // results for certain dates in Opera >= 10.53.
	      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
	        // Safari < 2.0.2 stores the internal millisecond time value correctly,
	        // but clips the values returned by the date methods to the range of
	        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
	        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
	    } catch (exception) {}
	
	    // Internal: Determines whether the native `JSON.stringify` and `parse`
	    // implementations are spec-compliant. Based on work by Ken Snyder.
	    function has(name) {
	      if (has[name] !== undef) {
	        // Return cached feature test result.
	        return has[name];
	      }
	      var isSupported;
	      if (name == "bug-string-char-index") {
	        // IE <= 7 doesn't support accessing string characters using square
	        // bracket notation. IE 8 only supports this for primitives.
	        isSupported = "a"[0] != "a";
	      } else if (name == "json") {
	        // Indicates whether both `JSON.stringify` and `JSON.parse` are
	        // supported.
	        isSupported = has("json-stringify") && has("json-parse");
	      } else {
	        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
	        // Test `JSON.stringify`.
	        if (name == "json-stringify") {
	          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
	          if (stringifySupported) {
	            // A test function object with a custom `toJSON` method.
	            (value = function () {
	              return 1;
	            }).toJSON = value;
	            try {
	              stringifySupported =
	                // Firefox 3.1b1 and b2 serialize string, number, and boolean
	                // primitives as object literals.
	                stringify(0) === "0" &&
	                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
	                // literals.
	                stringify(new Number()) === "0" &&
	                stringify(new String()) == '""' &&
	                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
	                // does not define a canonical JSON representation (this applies to
	                // objects with `toJSON` properties as well, *unless* they are nested
	                // within an object or array).
	                stringify(getClass) === undef &&
	                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
	                // FF 3.1b3 pass this test.
	                stringify(undef) === undef &&
	                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
	                // respectively, if the value is omitted entirely.
	                stringify() === undef &&
	                // FF 3.1b1, 2 throw an error if the given value is not a number,
	                // string, array, object, Boolean, or `null` literal. This applies to
	                // objects with custom `toJSON` methods as well, unless they are nested
	                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
	                // methods entirely.
	                stringify(value) === "1" &&
	                stringify([value]) == "[1]" &&
	                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
	                // `"[null]"`.
	                stringify([undef]) == "[null]" &&
	                // YUI 3.0.0b1 fails to serialize `null` literals.
	                stringify(null) == "null" &&
	                // FF 3.1b1, 2 halts serialization if an array contains a function:
	                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
	                // elides non-JSON values from objects and arrays, unless they
	                // define custom `toJSON` methods.
	                stringify([undef, getClass, null]) == "[null,null,null]" &&
	                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
	                // where character escape codes are expected (e.g., `\b` => `\u0008`).
	                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
	                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
	                stringify(null, value) === "1" &&
	                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
	                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
	                // serialize extended years.
	                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
	                // The milliseconds are optional in ES 5, but required in 5.1.
	                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
	                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
	                // four-digit years instead of six-digit years. Credits: @Yaffle.
	                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
	                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
	                // values less than 1000. Credits: @Yaffle.
	                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
	            } catch (exception) {
	              stringifySupported = false;
	            }
	          }
	          isSupported = stringifySupported;
	        }
	        // Test `JSON.parse`.
	        if (name == "json-parse") {
	          var parse = exports.parse;
	          if (typeof parse == "function") {
	            try {
	              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
	              // Conforming implementations should also coerce the initial argument to
	              // a string prior to parsing.
	              if (parse("0") === 0 && !parse(false)) {
	                // Simple parsing test.
	                value = parse(serialized);
	                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
	                if (parseSupported) {
	                  try {
	                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
	                    parseSupported = !parse('"\t"');
	                  } catch (exception) {}
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
	                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
	                      // certain octal literals.
	                      parseSupported = parse("01") !== 1;
	                    } catch (exception) {}
	                  }
	                  if (parseSupported) {
	                    try {
	                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
	                      // points. These environments, along with FF 3.1b1 and 2,
	                      // also allow trailing commas in JSON objects and arrays.
	                      parseSupported = parse("1.") !== 1;
	                    } catch (exception) {}
	                  }
	                }
	              }
	            } catch (exception) {
	              parseSupported = false;
	            }
	          }
	          isSupported = parseSupported;
	        }
	      }
	      return has[name] = !!isSupported;
	    }
	
	    if (!has("json")) {
	      // Common `[[Class]]` name aliases.
	      var functionClass = "[object Function]",
	          dateClass = "[object Date]",
	          numberClass = "[object Number]",
	          stringClass = "[object String]",
	          arrayClass = "[object Array]",
	          booleanClass = "[object Boolean]";
	
	      // Detect incomplete support for accessing string characters by index.
	      var charIndexBuggy = has("bug-string-char-index");
	
	      // Define additional utility methods if the `Date` methods are buggy.
	      if (!isExtended) {
	        var floor = Math.floor;
	        // A mapping between the months of the year and the number of days between
	        // January 1st and the first of the respective month.
	        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	        // Internal: Calculates the number of days between the Unix epoch and the
	        // first day of the given month.
	        var getDay = function (year, month) {
	          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
	        };
	      }
	
	      // Internal: Determines if a property is a direct property of the given
	      // object. Delegates to the native `Object#hasOwnProperty` method.
	      if (!(isProperty = objectProto.hasOwnProperty)) {
	        isProperty = function (property) {
	          var members = {}, constructor;
	          if ((members.__proto__ = null, members.__proto__ = {
	            // The *proto* property cannot be set multiple times in recent
	            // versions of Firefox and SeaMonkey.
	            "toString": 1
	          }, members).toString != getClass) {
	            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
	            // supports the mutable *proto* property.
	            isProperty = function (property) {
	              // Capture and break the object's prototype chain (see section 8.6.2
	              // of the ES 5.1 spec). The parenthesized expression prevents an
	              // unsafe transformation by the Closure Compiler.
	              var original = this.__proto__, result = property in (this.__proto__ = null, this);
	              // Restore the original prototype chain.
	              this.__proto__ = original;
	              return result;
	            };
	          } else {
	            // Capture a reference to the top-level `Object` constructor.
	            constructor = members.constructor;
	            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
	            // other environments.
	            isProperty = function (property) {
	              var parent = (this.constructor || constructor).prototype;
	              return property in this && !(property in parent && this[property] === parent[property]);
	            };
	          }
	          members = null;
	          return isProperty.call(this, property);
	        };
	      }
	
	      // Internal: Normalizes the `for...in` iteration algorithm across
	      // environments. Each enumerated key is yielded to a `callback` function.
	      forEach = function (object, callback) {
	        var size = 0, Properties, members, property;
	
	        // Tests for bugs in the current environment's `for...in` algorithm. The
	        // `valueOf` property inherits the non-enumerable flag from
	        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
	        (Properties = function () {
	          this.valueOf = 0;
	        }).prototype.valueOf = 0;
	
	        // Iterate over a new instance of the `Properties` class.
	        members = new Properties();
	        for (property in members) {
	          // Ignore all properties inherited from `Object.prototype`.
	          if (isProperty.call(members, property)) {
	            size++;
	          }
	        }
	        Properties = members = null;
	
	        // Normalize the iteration algorithm.
	        if (!size) {
	          // A list of non-enumerable properties inherited from `Object.prototype`.
	          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
	          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
	          // properties.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, length;
	            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
	            for (property in object) {
	              // Gecko <= 1.0 enumerates the `prototype` property of functions under
	              // certain conditions; IE does not.
	              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for each non-enumerable property.
	            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
	          };
	        } else if (size == 2) {
	          // Safari <= 2.0.4 enumerates shadowed properties twice.
	          forEach = function (object, callback) {
	            // Create a set of iterated properties.
	            var members = {}, isFunction = getClass.call(object) == functionClass, property;
	            for (property in object) {
	              // Store each property name to prevent double enumeration. The
	              // `prototype` property of functions is not enumerated due to cross-
	              // environment inconsistencies.
	              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
	                callback(property);
	              }
	            }
	          };
	        } else {
	          // No bugs detected; use the standard `for...in` algorithm.
	          forEach = function (object, callback) {
	            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
	            for (property in object) {
	              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
	                callback(property);
	              }
	            }
	            // Manually invoke the callback for the `constructor` property due to
	            // cross-environment inconsistencies.
	            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
	              callback(property);
	            }
	          };
	        }
	        return forEach(object, callback);
	      };
	
	      // Public: Serializes a JavaScript `value` as a JSON string. The optional
	      // `filter` argument may specify either a function that alters how object and
	      // array members are serialized, or an array of strings and numbers that
	      // indicates which properties should be serialized. The optional `width`
	      // argument may be either a string or number that specifies the indentation
	      // level of the output.
	      if (!has("json-stringify")) {
	        // Internal: A map of control characters and their escaped equivalents.
	        var Escapes = {
	          92: "\\\\",
	          34: '\\"',
	          8: "\\b",
	          12: "\\f",
	          10: "\\n",
	          13: "\\r",
	          9: "\\t"
	        };
	
	        // Internal: Converts `value` into a zero-padded string such that its
	        // length is at least equal to `width`. The `width` must be <= 6.
	        var leadingZeroes = "000000";
	        var toPaddedString = function (width, value) {
	          // The `|| 0` expression is necessary to work around a bug in
	          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
	          return (leadingZeroes + (value || 0)).slice(-width);
	        };
	
	        // Internal: Double-quotes a string `value`, replacing all ASCII control
	        // characters (characters with code unit values between 0 and 31) with
	        // their escaped equivalents. This is an implementation of the
	        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
	        var unicodePrefix = "\\u00";
	        var quote = function (value) {
	          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
	          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
	          for (; index < length; index++) {
	            var charCode = value.charCodeAt(index);
	            // If the character is a control character, append its Unicode or
	            // shorthand escape sequence; otherwise, append the character as-is.
	            switch (charCode) {
	              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
	                result += Escapes[charCode];
	                break;
	              default:
	                if (charCode < 32) {
	                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
	                  break;
	                }
	                result += useCharIndex ? symbols[index] : value.charAt(index);
	            }
	          }
	          return result + '"';
	        };
	
	        // Internal: Recursively serializes an object. Implements the
	        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
	        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
	          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
	          try {
	            // Necessary for host object support.
	            value = object[property];
	          } catch (exception) {}
	          if (typeof value == "object" && value) {
	            className = getClass.call(value);
	            if (className == dateClass && !isProperty.call(value, "toJSON")) {
	              if (value > -1 / 0 && value < 1 / 0) {
	                // Dates are serialized according to the `Date#toJSON` method
	                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
	                // for the ISO 8601 date time string format.
	                if (getDay) {
	                  // Manually compute the year, month, date, hours, minutes,
	                  // seconds, and milliseconds if the `getUTC*` methods are
	                  // buggy. Adapted from @Yaffle's `date-shim` project.
	                  date = floor(value / 864e5);
	                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
	                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
	                  date = 1 + date - getDay(year, month);
	                  // The `time` value specifies the time within the day (see ES
	                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
	                  // to compute `A modulo B`, as the `%` operator does not
	                  // correspond to the `modulo` operation for negative numbers.
	                  time = (value % 864e5 + 864e5) % 864e5;
	                  // The hours, minutes, seconds, and milliseconds are obtained by
	                  // decomposing the time within the day. See section 15.9.1.10.
	                  hours = floor(time / 36e5) % 24;
	                  minutes = floor(time / 6e4) % 60;
	                  seconds = floor(time / 1e3) % 60;
	                  milliseconds = time % 1e3;
	                } else {
	                  year = value.getUTCFullYear();
	                  month = value.getUTCMonth();
	                  date = value.getUTCDate();
	                  hours = value.getUTCHours();
	                  minutes = value.getUTCMinutes();
	                  seconds = value.getUTCSeconds();
	                  milliseconds = value.getUTCMilliseconds();
	                }
	                // Serialize extended years correctly.
	                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
	                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
	                  // Months, dates, hours, minutes, and seconds should have two
	                  // digits; milliseconds should have three.
	                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
	                  // Milliseconds are optional in ES 5.0, but required in 5.1.
	                  "." + toPaddedString(3, milliseconds) + "Z";
	              } else {
	                value = null;
	              }
	            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
	              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
	              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
	              // ignores all `toJSON` methods on these objects unless they are
	              // defined directly on an instance.
	              value = value.toJSON(property);
	            }
	          }
	          if (callback) {
	            // If a replacement function was provided, call it to obtain the value
	            // for serialization.
	            value = callback.call(object, property, value);
	          }
	          if (value === null) {
	            return "null";
	          }
	          className = getClass.call(value);
	          if (className == booleanClass) {
	            // Booleans are represented literally.
	            return "" + value;
	          } else if (className == numberClass) {
	            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
	            // `"null"`.
	            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
	          } else if (className == stringClass) {
	            // Strings are double-quoted and escaped.
	            return quote("" + value);
	          }
	          // Recursively serialize objects and arrays.
	          if (typeof value == "object") {
	            // Check for cyclic structures. This is a linear search; performance
	            // is inversely proportional to the number of unique nested objects.
	            for (length = stack.length; length--;) {
	              if (stack[length] === value) {
	                // Cyclic structures cannot be serialized by `JSON.stringify`.
	                throw TypeError();
	              }
	            }
	            // Add the object to the stack of traversed objects.
	            stack.push(value);
	            results = [];
	            // Save the current indentation level and indent one additional level.
	            prefix = indentation;
	            indentation += whitespace;
	            if (className == arrayClass) {
	              // Recursively serialize array elements.
	              for (index = 0, length = value.length; index < length; index++) {
	                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
	                results.push(element === undef ? "null" : element);
	              }
	              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
	            } else {
	              // Recursively serialize object members. Members are selected from
	              // either a user-specified list of property names, or the object
	              // itself.
	              forEach(properties || value, function (property) {
	                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
	                if (element !== undef) {
	                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
	                  // is not the empty string, let `member` {quote(property) + ":"}
	                  // be the concatenation of `member` and the `space` character."
	                  // The "`space` character" refers to the literal space
	                  // character, not the `space` {width} argument provided to
	                  // `JSON.stringify`.
	                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
	                }
	              });
	              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
	            }
	            // Remove the object from the traversed object stack.
	            stack.pop();
	            return result;
	          }
	        };
	
	        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
	        exports.stringify = function (source, filter, width) {
	          var whitespace, callback, properties, className;
	          if (objectTypes[typeof filter] && filter) {
	            if ((className = getClass.call(filter)) == functionClass) {
	              callback = filter;
	            } else if (className == arrayClass) {
	              // Convert the property names array into a makeshift set.
	              properties = {};
	              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
	            }
	          }
	          if (width) {
	            if ((className = getClass.call(width)) == numberClass) {
	              // Convert the `width` to an integer and create a string containing
	              // `width` number of space characters.
	              if ((width -= width % 1) > 0) {
	                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
	              }
	            } else if (className == stringClass) {
	              whitespace = width.length <= 10 ? width : width.slice(0, 10);
	            }
	          }
	          // Opera <= 7.54u2 discards the values associated with empty string keys
	          // (`""`) only if they are used directly within an object member list
	          // (e.g., `!("" in { "": 1})`).
	          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
	        };
	      }
	
	      // Public: Parses a JSON source string.
	      if (!has("json-parse")) {
	        var fromCharCode = String.fromCharCode;
	
	        // Internal: A map of escaped control characters and their unescaped
	        // equivalents.
	        var Unescapes = {
	          92: "\\",
	          34: '"',
	          47: "/",
	          98: "\b",
	          116: "\t",
	          110: "\n",
	          102: "\f",
	          114: "\r"
	        };
	
	        // Internal: Stores the parser state.
	        var Index, Source;
	
	        // Internal: Resets the parser state and throws a `SyntaxError`.
	        var abort = function () {
	          Index = Source = null;
	          throw SyntaxError();
	        };
	
	        // Internal: Returns the next token, or `"$"` if the parser has reached
	        // the end of the source string. A token may be a string, number, `null`
	        // literal, or Boolean literal.
	        var lex = function () {
	          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
	          while (Index < length) {
	            charCode = source.charCodeAt(Index);
	            switch (charCode) {
	              case 9: case 10: case 13: case 32:
	                // Skip whitespace tokens, including tabs, carriage returns, line
	                // feeds, and space characters.
	                Index++;
	                break;
	              case 123: case 125: case 91: case 93: case 58: case 44:
	                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
	                // the current position.
	                value = charIndexBuggy ? source.charAt(Index) : source[Index];
	                Index++;
	                return value;
	              case 34:
	                // `"` delimits a JSON string; advance to the next character and
	                // begin parsing the string. String tokens are prefixed with the
	                // sentinel `@` character to distinguish them from punctuators and
	                // end-of-string tokens.
	                for (value = "@", Index++; Index < length;) {
	                  charCode = source.charCodeAt(Index);
	                  if (charCode < 32) {
	                    // Unescaped ASCII control characters (those with a code unit
	                    // less than the space character) are not permitted.
	                    abort();
	                  } else if (charCode == 92) {
	                    // A reverse solidus (`\`) marks the beginning of an escaped
	                    // control character (including `"`, `\`, and `/`) or Unicode
	                    // escape sequence.
	                    charCode = source.charCodeAt(++Index);
	                    switch (charCode) {
	                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
	                        // Revive escaped control characters.
	                        value += Unescapes[charCode];
	                        Index++;
	                        break;
	                      case 117:
	                        // `\u` marks the beginning of a Unicode escape sequence.
	                        // Advance to the first character and validate the
	                        // four-digit code point.
	                        begin = ++Index;
	                        for (position = Index + 4; Index < position; Index++) {
	                          charCode = source.charCodeAt(Index);
	                          // A valid sequence comprises four hexdigits (case-
	                          // insensitive) that form a single hexadecimal value.
	                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
	                            // Invalid Unicode escape sequence.
	                            abort();
	                          }
	                        }
	                        // Revive the escaped character.
	                        value += fromCharCode("0x" + source.slice(begin, Index));
	                        break;
	                      default:
	                        // Invalid escape sequence.
	                        abort();
	                    }
	                  } else {
	                    if (charCode == 34) {
	                      // An unescaped double-quote character marks the end of the
	                      // string.
	                      break;
	                    }
	                    charCode = source.charCodeAt(Index);
	                    begin = Index;
	                    // Optimize for the common case where a string is valid.
	                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
	                      charCode = source.charCodeAt(++Index);
	                    }
	                    // Append the string as-is.
	                    value += source.slice(begin, Index);
	                  }
	                }
	                if (source.charCodeAt(Index) == 34) {
	                  // Advance to the next character and return the revived string.
	                  Index++;
	                  return value;
	                }
	                // Unterminated string.
	                abort();
	              default:
	                // Parse numbers and literals.
	                begin = Index;
	                // Advance past the negative sign, if one is specified.
	                if (charCode == 45) {
	                  isSigned = true;
	                  charCode = source.charCodeAt(++Index);
	                }
	                // Parse an integer or floating-point value.
	                if (charCode >= 48 && charCode <= 57) {
	                  // Leading zeroes are interpreted as octal literals.
	                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
	                    // Illegal octal literal.
	                    abort();
	                  }
	                  isSigned = false;
	                  // Parse the integer component.
	                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
	                  // Floats cannot contain a leading decimal point; however, this
	                  // case is already accounted for by the parser.
	                  if (source.charCodeAt(Index) == 46) {
	                    position = ++Index;
	                    // Parse the decimal component.
	                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal trailing decimal.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Parse exponents. The `e` denoting the exponent is
	                  // case-insensitive.
	                  charCode = source.charCodeAt(Index);
	                  if (charCode == 101 || charCode == 69) {
	                    charCode = source.charCodeAt(++Index);
	                    // Skip past the sign following the exponent, if one is
	                    // specified.
	                    if (charCode == 43 || charCode == 45) {
	                      Index++;
	                    }
	                    // Parse the exponential component.
	                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
	                    if (position == Index) {
	                      // Illegal empty exponent.
	                      abort();
	                    }
	                    Index = position;
	                  }
	                  // Coerce the parsed value to a JavaScript number.
	                  return +source.slice(begin, Index);
	                }
	                // A negative sign may only precede numbers.
	                if (isSigned) {
	                  abort();
	                }
	                // `true`, `false`, and `null` literals.
	                if (source.slice(Index, Index + 4) == "true") {
	                  Index += 4;
	                  return true;
	                } else if (source.slice(Index, Index + 5) == "false") {
	                  Index += 5;
	                  return false;
	                } else if (source.slice(Index, Index + 4) == "null") {
	                  Index += 4;
	                  return null;
	                }
	                // Unrecognized token.
	                abort();
	            }
	          }
	          // Return the sentinel `$` character if the parser has reached the end
	          // of the source string.
	          return "$";
	        };
	
	        // Internal: Parses a JSON `value` token.
	        var get = function (value) {
	          var results, hasMembers;
	          if (value == "$") {
	            // Unexpected end of input.
	            abort();
	          }
	          if (typeof value == "string") {
	            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
	              // Remove the sentinel `@` character.
	              return value.slice(1);
	            }
	            // Parse object and array literals.
	            if (value == "[") {
	              // Parses a JSON array, returning a new JavaScript array.
	              results = [];
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing square bracket marks the end of the array literal.
	                if (value == "]") {
	                  break;
	                }
	                // If the array literal contains elements, the current token
	                // should be a comma separating the previous element from the
	                // next.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "]") {
	                      // Unexpected trailing `,` in array literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each array element.
	                    abort();
	                  }
	                }
	                // Elisions and leading commas are not permitted.
	                if (value == ",") {
	                  abort();
	                }
	                results.push(get(value));
	              }
	              return results;
	            } else if (value == "{") {
	              // Parses a JSON object, returning a new JavaScript object.
	              results = {};
	              for (;; hasMembers || (hasMembers = true)) {
	                value = lex();
	                // A closing curly brace marks the end of the object literal.
	                if (value == "}") {
	                  break;
	                }
	                // If the object literal contains members, the current token
	                // should be a comma separator.
	                if (hasMembers) {
	                  if (value == ",") {
	                    value = lex();
	                    if (value == "}") {
	                      // Unexpected trailing `,` in object literal.
	                      abort();
	                    }
	                  } else {
	                    // A `,` must separate each object member.
	                    abort();
	                  }
	                }
	                // Leading commas are not permitted, object property names must be
	                // double-quoted strings, and a `:` must separate each property
	                // name and value.
	                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
	                  abort();
	                }
	                results[value.slice(1)] = get(lex());
	              }
	              return results;
	            }
	            // Unexpected token encountered.
	            abort();
	          }
	          return value;
	        };
	
	        // Internal: Updates a traversed object member.
	        var update = function (source, property, callback) {
	          var element = walk(source, property, callback);
	          if (element === undef) {
	            delete source[property];
	          } else {
	            source[property] = element;
	          }
	        };
	
	        // Internal: Recursively traverses a parsed JSON object, invoking the
	        // `callback` function for each value. This is an implementation of the
	        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
	        var walk = function (source, property, callback) {
	          var value = source[property], length;
	          if (typeof value == "object" && value) {
	            // `forEach` can't be used to traverse an array in Opera <= 8.54
	            // because its `Object#hasOwnProperty` implementation returns `false`
	            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
	            if (getClass.call(value) == arrayClass) {
	              for (length = value.length; length--;) {
	                update(value, length, callback);
	              }
	            } else {
	              forEach(value, function (property) {
	                update(value, property, callback);
	              });
	            }
	          }
	          return callback.call(source, property, value);
	        };
	
	        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
	        exports.parse = function (source, callback) {
	          var result, value;
	          Index = 0;
	          Source = "" + source;
	          result = get(lex());
	          // If a JSON string contains multiple tokens, it is invalid.
	          if (lex() != "$") {
	            abort();
	          }
	          // Reset the parser state.
	          Index = Source = null;
	          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
	        };
	      }
	    }
	
	    exports["runInContext"] = runInContext;
	    return exports;
	  }
	
	  if (freeExports && !isLoader) {
	    // Export for CommonJS environments.
	    runInContext(root, freeExports);
	  } else {
	    // Export for web browsers and JavaScript engines.
	    var nativeJSON = root.JSON,
	        previousJSON = root["JSON3"],
	        isRestored = false;
	
	    var JSON3 = runInContext(root, (root["JSON3"] = {
	      // Public: Restores the original value of the global `JSON` object and
	      // returns a reference to the `JSON3` object.
	      "noConflict": function () {
	        if (!isRestored) {
	          isRestored = true;
	          root.JSON = nativeJSON;
	          root["JSON3"] = previousJSON;
	          nativeJSON = previousJSON = null;
	        }
	        return JSON3;
	      }
	    }));
	
	    root.JSON = {
	      "parse": JSON3.parse,
	      "stringify": JSON3.stringify
	    };
	  }
	
	  // Export for asynchronous module loaders.
	  if (isLoader) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return JSON3;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 45 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = '1.0.3';

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var eventUtils = __webpack_require__(12)
	  , JSON3 = __webpack_require__(44)
	  , browser = __webpack_require__(36)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:utils:iframe');
	}
	
	module.exports = {
	  WPrefix: '_jp'
	, currentWindowId: null
	
	, polluteGlobalNamespace: function() {
	    if (!(module.exports.WPrefix in global)) {
	      global[module.exports.WPrefix] = {};
	    }
	  }
	
	, postMessage: function(type, data) {
	    if (global.parent !== global) {
	      global.parent.postMessage(JSON3.stringify({
	        windowId: module.exports.currentWindowId
	      , type: type
	      , data: data || ''
	      }), '*');
	    } else {
	      debug('Cannot postMessage, no parent window.', type, data);
	    }
	  }
	
	, createIframe: function(iframeUrl, errorCallback) {
	    var iframe = global.document.createElement('iframe');
	    var tref, unloadRef;
	    var unattach = function() {
	      debug('unattach');
	      clearTimeout(tref);
	      // Explorer had problems with that.
	      try {
	        iframe.onload = null;
	      } catch (x) {}
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      debug('cleanup');
	      if (iframe) {
	        unattach();
	        // This timeout makes chrome fire onbeforeunload event
	        // within iframe. Without the timeout it goes straight to
	        // onunload.
	        setTimeout(function() {
	          if (iframe) {
	            iframe.parentNode.removeChild(iframe);
	          }
	          iframe = null;
	        }, 0);
	        eventUtils.unloadDel(unloadRef);
	      }
	    };
	    var onerror = function(err) {
	      debug('onerror', err);
	      if (iframe) {
	        cleanup();
	        errorCallback(err);
	      }
	    };
	    var post = function(msg, origin) {
	      debug('post', msg, origin);
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	            iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {}
	    };
	
	    iframe.src = iframeUrl;
	    iframe.style.display = 'none';
	    iframe.style.position = 'absolute';
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    iframe.onload = function() {
	      debug('onload');
	      // `onload` is triggered before scripts on the iframe are
	      // executed. Give it few seconds to actually load stuff.
	      clearTimeout(tref);
	      tref = setTimeout(function() {
	        onerror('onload timeout');
	      }, 2000);
	    };
	    global.document.body.appendChild(iframe);
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	
	/* jshint undef: false, newcap: false */
	/* eslint no-undef: 0, new-cap: 0 */
	, createHtmlfile: function(iframeUrl, errorCallback) {
	    var axo = ['Active'].concat('Object').join('X');
	    var doc = new global[axo]('htmlfile');
	    var tref, unloadRef;
	    var iframe;
	    var unattach = function() {
	      clearTimeout(tref);
	      iframe.onerror = null;
	    };
	    var cleanup = function() {
	      if (doc) {
	        unattach();
	        eventUtils.unloadDel(unloadRef);
	        iframe.parentNode.removeChild(iframe);
	        iframe = doc = null;
	        CollectGarbage();
	      }
	    };
	    var onerror = function(r)  {
	      debug('onerror', r);
	      if (doc) {
	        cleanup();
	        errorCallback(r);
	      }
	    };
	    var post = function(msg, origin) {
	      try {
	        // When the iframe is not loaded, IE raises an exception
	        // on 'contentWindow'.
	        setTimeout(function() {
	          if (iframe && iframe.contentWindow) {
	              iframe.contentWindow.postMessage(msg, origin);
	          }
	        }, 0);
	      } catch (x) {}
	    };
	
	    doc.open();
	    doc.write('<html><s' + 'cript>' +
	              'document.domain="' + global.document.domain + '";' +
	              '</s' + 'cript></html>');
	    doc.close();
	    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
	    var c = doc.createElement('div');
	    doc.body.appendChild(c);
	    iframe = doc.createElement('iframe');
	    c.appendChild(iframe);
	    iframe.src = iframeUrl;
	    iframe.onerror = function() {
	      onerror('onerror');
	    };
	    tref = setTimeout(function() {
	      onerror('timeout');
	    }, 15000);
	    unloadRef = eventUtils.unloadAdd(cleanup);
	    return {
	      post: post
	    , cleanup: cleanup
	    , loaded: unattach
	    };
	  }
	};
	
	module.exports.iframeEnabled = false;
	if (global.document) {
	  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
	  // huge delay, or not at all.
	  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
	    typeof global.postMessage === 'object') && (!browser.isKonqueror());
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isObject: function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  }
	
	, extend: function(obj) {
	    if (!this.isObject(obj)) {
	      return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	      source = arguments[i];
	      for (prop in source) {
	        if (Object.prototype.hasOwnProperty.call(source, prop)) {
	          obj[prop] = source[prop];
	        }
	      }
	    }
	    return obj;
	  }
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , HtmlfileReceiver = __webpack_require__(50)
	  , XHRLocalObject = __webpack_require__(35)
	  , AjaxBasedTransport = __webpack_require__(28)
	  ;
	
	function HtmlFileTransport(transUrl) {
	  if (!HtmlfileReceiver.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
	}
	
	inherits(HtmlFileTransport, AjaxBasedTransport);
	
	HtmlFileTransport.enabled = function(info) {
	  return HtmlfileReceiver.enabled && info.sameOrigin;
	};
	
	HtmlFileTransport.transportName = 'htmlfile';
	HtmlFileTransport.roundTrips = 2;
	
	module.exports = HtmlFileTransport;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var inherits = __webpack_require__(23)
	  , iframeUtils = __webpack_require__(47)
	  , urlUtils = __webpack_require__(15)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  , random = __webpack_require__(13)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:receiver:htmlfile');
	}
	
	function HtmlfileReceiver(url) {
	  debug(url);
	  EventEmitter.call(this);
	  var self = this;
	  iframeUtils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));
	
	  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
	  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
	      iframeUtils.createHtmlfile : iframeUtils.createIframe;
	
	  global[iframeUtils.WPrefix][this.id] = {
	    start: function() {
	      debug('start');
	      self.iframeObj.loaded();
	    }
	  , message: function(data) {
	      debug('message', data);
	      self.emit('message', data);
	    }
	  , stop: function() {
	      debug('stop');
	      self._cleanup();
	      self._close('network');
	    }
	  };
	  this.iframeObj = constructFunc(url, function() {
	    debug('callback');
	    self._cleanup();
	    self._close('permanent');
	  });
	}
	
	inherits(HtmlfileReceiver, EventEmitter);
	
	HtmlfileReceiver.prototype.abort = function() {
	  debug('abort');
	  this._cleanup();
	  this._close('user');
	};
	
	HtmlfileReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  if (this.iframeObj) {
	    this.iframeObj.cleanup();
	    this.iframeObj = null;
	  }
	  delete global[iframeUtils.WPrefix][this.id];
	};
	
	HtmlfileReceiver.prototype._close = function(reason) {
	  debug('_close', reason);
	  this.emit('close', null, reason);
	  this.removeAllListeners();
	};
	
	HtmlfileReceiver.htmlfileEnabled = false;
	
	// obfuscate to avoid firewalls
	var axo = ['Active'].concat('Object').join('X');
	if (axo in global) {
	  try {
	    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
	  } catch (x) {}
	}
	
	HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;
	
	module.exports = HtmlfileReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , AjaxBasedTransport = __webpack_require__(28)
	  , XhrReceiver = __webpack_require__(32)
	  , XHRCorsObject = __webpack_require__(33)
	  , XHRLocalObject = __webpack_require__(35)
	  ;
	
	function XhrPollingTransport(transUrl) {
	  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
	}
	
	inherits(XhrPollingTransport, AjaxBasedTransport);
	
	XhrPollingTransport.enabled = function(info) {
	  if (info.nullOrigin) {
	    return false;
	  }
	
	  if (XHRLocalObject.enabled && info.sameOrigin) {
	    return true;
	  }
	  return XHRCorsObject.enabled;
	};
	
	XhrPollingTransport.transportName = 'xhr-polling';
	XhrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XhrPollingTransport;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , AjaxBasedTransport = __webpack_require__(28)
	  , XdrStreamingTransport = __webpack_require__(37)
	  , XhrReceiver = __webpack_require__(32)
	  , XDRObject = __webpack_require__(38)
	  ;
	
	function XdrPollingTransport(transUrl) {
	  if (!XDRObject.enabled) {
	    throw new Error('Transport created when disabled');
	  }
	  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
	}
	
	inherits(XdrPollingTransport, AjaxBasedTransport);
	
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = 'xdr-polling';
	XdrPollingTransport.roundTrips = 2; // preflight, ajax
	
	module.exports = XdrPollingTransport;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// The simplest and most robust transport, using the well-know cross
	// domain hack - JSONP. This transport is quite inefficient - one
	// message could use up to one http request. But at least it works almost
	// everywhere.
	// Known limitations:
	//   o you will get a spinning cursor
	//   o for Konqueror a dumb timer is needed to detect errors
	
	var inherits = __webpack_require__(23)
	  , SenderReceiver = __webpack_require__(29)
	  , JsonpReceiver = __webpack_require__(54)
	  , jsonpSender = __webpack_require__(55)
	  ;
	
	function JsonPTransport(transUrl) {
	  if (!JsonPTransport.enabled()) {
	    throw new Error('Transport created when disabled');
	  }
	  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
	}
	
	inherits(JsonPTransport, SenderReceiver);
	
	JsonPTransport.enabled = function() {
	  return !!global.document;
	};
	
	JsonPTransport.transportName = 'jsonp-polling';
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;
	
	module.exports = JsonPTransport;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var utils = __webpack_require__(47)
	  , random = __webpack_require__(13)
	  , browser = __webpack_require__(36)
	  , urlUtils = __webpack_require__(15)
	  , inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:receiver:jsonp');
	}
	
	function JsonpReceiver(url) {
	  debug(url);
	  var self = this;
	  EventEmitter.call(this);
	
	  utils.polluteGlobalNamespace();
	
	  this.id = 'a' + random.string(6);
	  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));
	
	  global[utils.WPrefix][this.id] = this._callback.bind(this);
	  this._createScript(urlWithId);
	
	  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
	  this.timeoutId = setTimeout(function() {
	    debug('timeout');
	    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
	  }, JsonpReceiver.timeout);
	}
	
	inherits(JsonpReceiver, EventEmitter);
	
	JsonpReceiver.prototype.abort = function() {
	  debug('abort');
	  if (global[utils.WPrefix][this.id]) {
	    var err = new Error('JSONP user aborted read');
	    err.code = 1000;
	    this._abort(err);
	  }
	};
	
	JsonpReceiver.timeout = 35000;
	JsonpReceiver.scriptErrorTimeout = 1000;
	
	JsonpReceiver.prototype._callback = function(data) {
	  debug('_callback', data);
	  this._cleanup();
	
	  if (this.aborting) {
	    return;
	  }
	
	  if (data) {
	    debug('message', data);
	    this.emit('message', data);
	  }
	  this.emit('close', null, 'network');
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._abort = function(err) {
	  debug('_abort', err);
	  this._cleanup();
	  this.aborting = true;
	  this.emit('close', err.code, err.message);
	  this.removeAllListeners();
	};
	
	JsonpReceiver.prototype._cleanup = function() {
	  debug('_cleanup');
	  clearTimeout(this.timeoutId);
	  if (this.script2) {
	    this.script2.parentNode.removeChild(this.script2);
	    this.script2 = null;
	  }
	  if (this.script) {
	    var script = this.script;
	    // Unfortunately, you can't really abort script loading of
	    // the script.
	    script.parentNode.removeChild(script);
	    script.onreadystatechange = script.onerror =
	        script.onload = script.onclick = null;
	    this.script = null;
	  }
	  delete global[utils.WPrefix][this.id];
	};
	
	JsonpReceiver.prototype._scriptError = function() {
	  debug('_scriptError');
	  var self = this;
	  if (this.errorTimer) {
	    return;
	  }
	
	  this.errorTimer = setTimeout(function() {
	    if (!self.loadedOkay) {
	      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
	    }
	  }, JsonpReceiver.scriptErrorTimeout);
	};
	
	JsonpReceiver.prototype._createScript = function(url) {
	  debug('_createScript', url);
	  var self = this;
	  var script = this.script = global.document.createElement('script');
	  var script2;  // Opera synchronous load trick.
	
	  script.id = 'a' + random.string(8);
	  script.src = url;
	  script.type = 'text/javascript';
	  script.charset = 'UTF-8';
	  script.onerror = this._scriptError.bind(this);
	  script.onload = function() {
	    debug('onload');
	    self._abort(new Error('JSONP script loaded abnormally (onload)'));
	  };
	
	  // IE9 fires 'error' event after onreadystatechange or before, in random order.
	  // Use loadedOkay to determine if actually errored
	  script.onreadystatechange = function() {
	    debug('onreadystatechange', script.readyState);
	    if (/loaded|closed/.test(script.readyState)) {
	      if (script && script.htmlFor && script.onclick) {
	        self.loadedOkay = true;
	        try {
	          // In IE, actually execute the script.
	          script.onclick();
	        } catch (x) {}
	      }
	      if (script) {
	        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
	      }
	    }
	  };
	  // IE: event/htmlFor/onclick trick.
	  // One can't rely on proper order for onreadystatechange. In order to
	  // make sure, set a 'htmlFor' and 'event' properties, so that
	  // script code will be installed as 'onclick' handler for the
	  // script object. Later, onreadystatechange, manually execute this
	  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
	  // set. For reference see:
	  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	  // Also, read on that about script ordering:
	  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
	  if (typeof script.async === 'undefined' && global.document.attachEvent) {
	    // According to mozilla docs, in recent browsers script.async defaults
	    // to 'true', so we may use it to detect a good browser:
	    // https://developer.mozilla.org/en/HTML/Element/script
	    if (!browser.isOpera()) {
	      // Naively assume we're in IE
	      try {
	        script.htmlFor = script.id;
	        script.event = 'onclick';
	      } catch (x) {}
	      script.async = true;
	    } else {
	      // Opera, second sync script hack
	      script2 = this.script2 = global.document.createElement('script');
	      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
	      script.async = script2.async = false;
	    }
	  }
	  if (typeof script.async !== 'undefined') {
	    script.async = true;
	  }
	
	  var head = global.document.getElementsByTagName('head')[0];
	  head.insertBefore(script, head.firstChild);
	  if (script2) {
	    head.insertBefore(script2, head.firstChild);
	  }
	};
	
	module.exports = JsonpReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var random = __webpack_require__(13)
	  , urlUtils = __webpack_require__(15)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:sender:jsonp');
	}
	
	var form, area;
	
	function createIframe(id) {
	  debug('createIframe', id);
	  try {
	    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	    return global.document.createElement('<iframe name="' + id + '">');
	  } catch (x) {
	    var iframe = global.document.createElement('iframe');
	    iframe.name = id;
	    return iframe;
	  }
	}
	
	function createForm() {
	  debug('createForm');
	  form = global.document.createElement('form');
	  form.style.display = 'none';
	  form.style.position = 'absolute';
	  form.method = 'POST';
	  form.enctype = 'application/x-www-form-urlencoded';
	  form.acceptCharset = 'UTF-8';
	
	  area = global.document.createElement('textarea');
	  area.name = 'd';
	  form.appendChild(area);
	
	  global.document.body.appendChild(form);
	}
	
	module.exports = function(url, payload, callback) {
	  debug(url, payload);
	  if (!form) {
	    createForm();
	  }
	  var id = 'a' + random.string(8);
	  form.target = id;
	  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);
	
	  var iframe = createIframe(id);
	  iframe.id = id;
	  iframe.style.display = 'none';
	  form.appendChild(iframe);
	
	  try {
	    area.value = payload;
	  } catch (e) {
	    // seriously broken browsers get here
	  }
	  form.submit();
	
	  var completed = function(err) {
	    debug('completed', id, err);
	    if (!iframe.onerror) {
	      return;
	    }
	    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
	    // Opera mini doesn't like if we GC iframe
	    // immediately, thus this timeout.
	    setTimeout(function() {
	      debug('cleaning up', id);
	      iframe.parentNode.removeChild(iframe);
	      iframe = null;
	    }, 500);
	    area.value = '';
	    // It is not possible to detect if the iframe succeeded or
	    // failed to submit our form.
	    callback(err);
	  };
	  iframe.onerror = function() {
	    debug('onerror', id);
	    completed();
	  };
	  iframe.onload = function() {
	    debug('onload', id);
	    completed();
	  };
	  iframe.onreadystatechange = function(e) {
	    debug('onreadystatechange', id, iframe.readyState, e);
	    if (iframe.readyState === 'complete') {
	      completed();
	    }
	  };
	  return function() {
	    debug('aborted', id);
	    completed(new Error('Aborted'));
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	__webpack_require__(57);
	
	var URL = __webpack_require__(16)
	  , inherits = __webpack_require__(23)
	  , JSON3 = __webpack_require__(44)
	  , random = __webpack_require__(13)
	  , escape = __webpack_require__(58)
	  , urlUtils = __webpack_require__(15)
	  , eventUtils = __webpack_require__(12)
	  , transport = __webpack_require__(59)
	  , objectUtils = __webpack_require__(48)
	  , browser = __webpack_require__(36)
	  , log = __webpack_require__(60)
	  , Event = __webpack_require__(61)
	  , EventTarget = __webpack_require__(25)
	  , loc = __webpack_require__(62)
	  , CloseEvent = __webpack_require__(63)
	  , TransportMessageEvent = __webpack_require__(64)
	  , InfoReceiver = __webpack_require__(65)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  // Make debug module available globally so you can enable via the console easily
	  global.dbg = __webpack_require__(20);
	  debug = global.dbg('sockjs-client:main');
	}
	
	var transports;
	
	// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
	function SockJS(url, protocols, options) {
	  if (!(this instanceof SockJS)) {
	    return new SockJS(url, protocols, options);
	  }
	  if (arguments.length < 1) {
	    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
	  }
	  EventTarget.call(this);
	
	  this.readyState = SockJS.CONNECTING;
	  this.extensions = '';
	  this.protocol = '';
	
	  // non-standard extension
	  options = options || {};
	  if (options.protocols_whitelist) {
	    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
	  }
	  this._transportsWhitelist = options.transports;
	
	  var sessionId = options.sessionId || 8;
	  if (typeof sessionId === 'function') {
	    this._generateSessionId = sessionId;
	  } else if (typeof sessionId === 'number') {
	    this._generateSessionId = function() {
	      return random.string(sessionId);
	    };
	  } else {
	    throw new TypeError("If sessionId is used in the options, it needs to be a number or a function.");
	  }
	
	  this._server = options.server || random.numberString(1000);
	
	  // Step 1 of WS spec - parse and validate the url. Issue #8
	  var parsedUrl = new URL(url);
	  if (!parsedUrl.host || !parsedUrl.protocol) {
	    throw new SyntaxError("The URL '" + url + "' is invalid");
	  } else if (parsedUrl.hash) {
	    throw new SyntaxError('The URL must not contain a fragment');
	  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
	    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
	  }
	
	  var secure = parsedUrl.protocol === 'https:';
	  // Step 2 - don't allow secure origin with an insecure protocol
	  if (loc.protocol === 'https' && !secure) {
	    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
	  }
	
	  // Step 3 - check port access - no need here
	  // Step 4 - parse protocols argument
	  if (!protocols) {
	    protocols = [];
	  } else if (!Array.isArray(protocols)) {
	    protocols = [protocols];
	  }
	
	  // Step 5 - check protocols argument
	  var sortedProtocols = protocols.sort();
	  sortedProtocols.forEach(function(proto, i) {
	    if (!proto) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
	    }
	    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
	      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
	    }
	  });
	
	  // Step 6 - convert origin
	  var o = urlUtils.getOrigin(loc.href);
	  this._origin = o ? o.toLowerCase() : null;
	
	  // remove the trailing slash
	  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));
	
	  // store the sanitized url
	  this.url = parsedUrl.href;
	  debug('using url', this.url);
	
	  // Step 7 - start connection in background
	  // obtain server info
	  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
	  this._urlInfo = {
	    nullOrigin: !browser.hasDomain()
	  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
	  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
	  };
	
	  this._ir = new InfoReceiver(this.url, this._urlInfo);
	  this._ir.once('finish', this._receiveInfo.bind(this));
	}
	
	inherits(SockJS, EventTarget);
	
	function userSetCode(code) {
	  return code === 1000 || (code >= 3000 && code <= 4999);
	}
	
	SockJS.prototype.close = function(code, reason) {
	  // Step 1
	  if (code && !userSetCode(code)) {
	    throw new Error('InvalidAccessError: Invalid code');
	  }
	  // Step 2.4 states the max is 123 bytes, but we are just checking length
	  if (reason && reason.length > 123) {
	    throw new SyntaxError('reason argument has an invalid length');
	  }
	
	  // Step 3.1
	  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
	    return;
	  }
	
	  // TODO look at docs to determine how to set this
	  var wasClean = true;
	  this._close(code || 1000, reason || 'Normal closure', wasClean);
	};
	
	SockJS.prototype.send = function(data) {
	  // #13 - convert anything non-string to string
	  // TODO this currently turns objects into [object Object]
	  if (typeof data !== 'string') {
	    data = '' + data;
	  }
	  if (this.readyState === SockJS.CONNECTING) {
	    throw new Error('InvalidStateError: The connection has not been established yet');
	  }
	  if (this.readyState !== SockJS.OPEN) {
	    return;
	  }
	  this._transport.send(escape.quote(data));
	};
	
	SockJS.version = __webpack_require__(46);
	
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	
	SockJS.prototype._receiveInfo = function(info, rtt) {
	  debug('_receiveInfo', rtt);
	  this._ir = null;
	  if (!info) {
	    this._close(1002, 'Cannot connect to server');
	    return;
	  }
	
	  // establish a round-trip timeout (RTO) based on the
	  // round-trip time (RTT)
	  this._rto = this.countRTO(rtt);
	  // allow server to override url used for the actual transport
	  this._transUrl = info.base_url ? info.base_url : this.url;
	  info = objectUtils.extend(info, this._urlInfo);
	  debug('info', info);
	  // determine list of desired and supported transports
	  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
	  this._transports = enabledTransports.main;
	  debug(this._transports.length + ' enabled transports');
	
	  this._connect();
	};
	
	SockJS.prototype._connect = function() {
	  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
	    debug('attempt', Transport.transportName);
	    if (Transport.needBody) {
	      if (!global.document.body ||
	          (typeof global.document.readyState !== 'undefined' &&
	            global.document.readyState !== 'complete' &&
	            global.document.readyState !== 'interactive')) {
	        debug('waiting for body');
	        this._transports.unshift(Transport);
	        eventUtils.attachEvent('load', this._connect.bind(this));
	        return;
	      }
	    }
	
	    // calculate timeout based on RTO and round trips. Default to 5s
	    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
	    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
	    debug('using timeout', timeoutMs);
	
	    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
	    debug('transport url', transportUrl);
	    var transportObj = new Transport(transportUrl, this._transUrl);
	    transportObj.on('message', this._transportMessage.bind(this));
	    transportObj.once('close', this._transportClose.bind(this));
	    transportObj.transportName = Transport.transportName;
	    this._transport = transportObj;
	
	    return;
	  }
	  this._close(2000, 'All transports failed', false);
	};
	
	SockJS.prototype._transportTimeout = function() {
	  debug('_transportTimeout');
	  if (this.readyState === SockJS.CONNECTING) {
	    this._transportClose(2007, 'Transport timed out');
	  }
	};
	
	SockJS.prototype._transportMessage = function(msg) {
	  debug('_transportMessage', msg);
	  var self = this
	    , type = msg.slice(0, 1)
	    , content = msg.slice(1)
	    , payload
	    ;
	
	  // first check for messages that don't need a payload
	  switch (type) {
	    case 'o':
	      this._open();
	      return;
	    case 'h':
	      this.dispatchEvent(new Event('heartbeat'));
	      debug('heartbeat', this.transport);
	      return;
	  }
	
	  if (content) {
	    try {
	      payload = JSON3.parse(content);
	    } catch (e) {
	      debug('bad json', content);
	    }
	  }
	
	  if (typeof payload === 'undefined') {
	    debug('empty payload', content);
	    return;
	  }
	
	  switch (type) {
	    case 'a':
	      if (Array.isArray(payload)) {
	        payload.forEach(function(p) {
	          debug('message', self.transport, p);
	          self.dispatchEvent(new TransportMessageEvent(p));
	        });
	      }
	      break;
	    case 'm':
	      debug('message', this.transport, payload);
	      this.dispatchEvent(new TransportMessageEvent(payload));
	      break;
	    case 'c':
	      if (Array.isArray(payload) && payload.length === 2) {
	        this._close(payload[0], payload[1], true);
	      }
	      break;
	  }
	};
	
	SockJS.prototype._transportClose = function(code, reason) {
	  debug('_transportClose', this.transport, code, reason);
	  if (this._transport) {
	    this._transport.removeAllListeners();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
	    this._connect();
	    return;
	  }
	
	  this._close(code, reason);
	};
	
	SockJS.prototype._open = function() {
	  debug('_open', this._transport.transportName, this.readyState);
	  if (this.readyState === SockJS.CONNECTING) {
	    if (this._transportTimeoutId) {
	      clearTimeout(this._transportTimeoutId);
	      this._transportTimeoutId = null;
	    }
	    this.readyState = SockJS.OPEN;
	    this.transport = this._transport.transportName;
	    this.dispatchEvent(new Event('open'));
	    debug('connected', this.transport);
	  } else {
	    // The server might have been restarted, and lost track of our
	    // connection.
	    this._close(1006, 'Server lost session');
	  }
	};
	
	SockJS.prototype._close = function(code, reason, wasClean) {
	  debug('_close', this.transport, code, reason, wasClean, this.readyState);
	  var forceFail = false;
	
	  if (this._ir) {
	    forceFail = true;
	    this._ir.close();
	    this._ir = null;
	  }
	  if (this._transport) {
	    this._transport.close();
	    this._transport = null;
	    this.transport = null;
	  }
	
	  if (this.readyState === SockJS.CLOSED) {
	    throw new Error('InvalidStateError: SockJS has already been closed');
	  }
	
	  this.readyState = SockJS.CLOSING;
	  setTimeout(function() {
	    this.readyState = SockJS.CLOSED;
	
	    if (forceFail) {
	      this.dispatchEvent(new Event('error'));
	    }
	
	    var e = new CloseEvent('close');
	    e.wasClean = wasClean || false;
	    e.code = code || 1000;
	    e.reason = reason;
	
	    this.dispatchEvent(e);
	    this.onmessage = this.onclose = this.onerror = null;
	    debug('disconnected');
	  }.bind(this), 0);
	};
	
	// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
	// and RFC 2988.
	SockJS.prototype.countRTO = function(rtt) {
	  // In a local environment, when using IE8/9 and the `jsonp-polling`
	  // transport the time needed to establish a connection (the time that pass
	  // from the opening of the transport to the call of `_dispatchOpen`) is
	  // around 200msec (the lower bound used in the article above) and this
	  // causes spurious timeouts. For this reason we calculate a value slightly
	  // larger than that used in the article.
	  if (rtt > 100) {
	    return 4 * rtt; // rto > 400msec
	  }
	  return 300 + rtt; // 300msec < rto <= 400msec
	};
	
	module.exports = function(availableTransports) {
	  transports = transport(availableTransports);
	  __webpack_require__(70)(SockJS, availableTransports);
	  return SockJS;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 57 */
/***/ function(module, exports) {

	/* eslint-disable */
	/* jscs: disable */
	'use strict';
	
	// pulled specific shims from https://github.com/es-shims/es5-shim
	
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;
	
	var _toString = ObjectPrototype.toString;
	var isFunction = function (val) {
	    return ObjectPrototype.toString.call(val) === '[object Function]';
	};
	var isArray = function isArray(obj) {
	    return _toString.call(obj) === '[object Array]';
	};
	var isString = function isString(obj) {
	    return _toString.call(obj) === '[object String]';
	};
	
	var supportsDescriptors = Object.defineProperty && (function () {
	    try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	    } catch (e) { /* this is ES3 */
	        return false;
	    }
	}());
	
	// Define configurable, writable and non-enumerable props
	// if they don't exist.
	var defineProperty;
	if (supportsDescriptors) {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        Object.defineProperty(object, name, {
	            configurable: true,
	            enumerable: false,
	            writable: true,
	            value: method
	        });
	    };
	} else {
	    defineProperty = function (object, name, method, forceAssign) {
	        if (!forceAssign && (name in object)) { return; }
	        object[name] = method;
	    };
	}
	var defineProperties = function (object, map, forceAssign) {
	    for (var name in map) {
	        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
	          defineProperty(object, name, map[name], forceAssign);
	        }
	    }
	};
	
	var toObject = function (o) {
	    if (o == null) { // this matches both null and undefined
	        throw new TypeError("can't convert " + o + ' to object');
	    }
	    return Object(o);
	};
	
	//
	// Util
	// ======
	//
	
	// ES5 9.4
	// http://es5.github.com/#x9.4
	// http://jsperf.com/to-integer
	
	function toInteger(num) {
	    var n = +num;
	    if (n !== n) { // isNaN
	        n = 0;
	    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
	        n = (n > 0 || -1) * Math.floor(Math.abs(n));
	    }
	    return n;
	}
	
	function ToUint32(x) {
	    return x >>> 0;
	}
	
	//
	// Function
	// ========
	//
	
	// ES-5 15.3.4.5
	// http://es5.github.com/#x15.3.4.5
	
	function Empty() {}
	
	defineProperties(FunctionPrototype, {
	    bind: function bind(that) { // .length is 1
	        // 1. Let Target be the this value.
	        var target = this;
	        // 2. If IsCallable(Target) is false, throw a TypeError exception.
	        if (!isFunction(target)) {
	            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
	        }
	        // 3. Let A be a new (possibly empty) internal list of all of the
	        //   argument values provided after thisArg (arg1, arg2 etc), in order.
	        // XXX slicedArgs will stand in for "A" if used
	        var args = array_slice.call(arguments, 1); // for normal call
	        // 4. Let F be a new native ECMAScript object.
	        // 11. Set the [[Prototype]] internal property of F to the standard
	        //   built-in Function prototype object as specified in 15.3.3.1.
	        // 12. Set the [[Call]] internal property of F as described in
	        //   15.3.4.5.1.
	        // 13. Set the [[Construct]] internal property of F as described in
	        //   15.3.4.5.2.
	        // 14. Set the [[HasInstance]] internal property of F as described in
	        //   15.3.4.5.3.
	        var binder = function () {
	
	            if (this instanceof bound) {
	                // 15.3.4.5.2 [[Construct]]
	                // When the [[Construct]] internal method of a function object,
	                // F that was created using the bind function is called with a
	                // list of arguments ExtraArgs, the following steps are taken:
	                // 1. Let target be the value of F's [[TargetFunction]]
	                //   internal property.
	                // 2. If target has no [[Construct]] internal method, a
	                //   TypeError exception is thrown.
	                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Construct]] internal
	                //   method of target providing args as the arguments.
	
	                var result = target.apply(
	                    this,
	                    args.concat(array_slice.call(arguments))
	                );
	                if (Object(result) === result) {
	                    return result;
	                }
	                return this;
	
	            } else {
	                // 15.3.4.5.1 [[Call]]
	                // When the [[Call]] internal method of a function object, F,
	                // which was created using the bind function is called with a
	                // this value and a list of arguments ExtraArgs, the following
	                // steps are taken:
	                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
	                //   property.
	                // 2. Let boundThis be the value of F's [[BoundThis]] internal
	                //   property.
	                // 3. Let target be the value of F's [[TargetFunction]] internal
	                //   property.
	                // 4. Let args be a new list containing the same values as the
	                //   list boundArgs in the same order followed by the same
	                //   values as the list ExtraArgs in the same order.
	                // 5. Return the result of calling the [[Call]] internal method
	                //   of target providing boundThis as the this value and
	                //   providing args as the arguments.
	
	                // equiv: target.call(this, ...boundArgs, ...args)
	                return target.apply(
	                    that,
	                    args.concat(array_slice.call(arguments))
	                );
	
	            }
	
	        };
	
	        // 15. If the [[Class]] internal property of Target is "Function", then
	        //     a. Let L be the length property of Target minus the length of A.
	        //     b. Set the length own property of F to either 0 or L, whichever is
	        //       larger.
	        // 16. Else set the length own property of F to 0.
	
	        var boundLength = Math.max(0, target.length - args.length);
	
	        // 17. Set the attributes of the length own property of F to the values
	        //   specified in 15.3.5.1.
	        var boundArgs = [];
	        for (var i = 0; i < boundLength; i++) {
	            boundArgs.push('$' + i);
	        }
	
	        // XXX Build a dynamic function with desired amount of arguments is the only
	        // way to set the length property of a function.
	        // In environments where Content Security Policies enabled (Chrome extensions,
	        // for ex.) all use of eval or Function costructor throws an exception.
	        // However in all of these environments Function.prototype.bind exists
	        // and so this code will never be executed.
	        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);
	
	        if (target.prototype) {
	            Empty.prototype = target.prototype;
	            bound.prototype = new Empty();
	            // Clean up dangling references.
	            Empty.prototype = null;
	        }
	
	        // TODO
	        // 18. Set the [[Extensible]] internal property of F to true.
	
	        // TODO
	        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
	        // 20. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
	        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
	        //   false.
	        // 21. Call the [[DefineOwnProperty]] internal method of F with
	        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
	        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
	        //   and false.
	
	        // TODO
	        // NOTE Function objects created using Function.prototype.bind do not
	        // have a prototype property or the [[Code]], [[FormalParameters]], and
	        // [[Scope]] internal properties.
	        // XXX can't delete prototype in pure-js.
	
	        // 22. Return F.
	        return bound;
	    }
	});
	
	//
	// Array
	// =====
	//
	
	// ES5 15.4.3.2
	// http://es5.github.com/#x15.4.3.2
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
	defineProperties(Array, { isArray: isArray });
	
	
	var boxedString = Object('a');
	var splitString = boxedString[0] !== 'a' || !(0 in boxedString);
	
	var properlyBoxesContext = function properlyBoxed(method) {
	    // Check node 0.6.21 bug where third parameter is not boxed
	    var properlyBoxesNonStrict = true;
	    var properlyBoxesStrict = true;
	    if (method) {
	        method.call('foo', function (_, __, context) {
	            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
	        });
	
	        method.call([1], function () {
	            'use strict';
	            properlyBoxesStrict = typeof this === 'string';
	        }, 'x');
	    }
	    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	};
	
	defineProperties(ArrayPrototype, {
	    forEach: function forEach(fun /*, thisp*/) {
	        var object = toObject(this),
	            self = splitString && isString(this) ? this.split('') : object,
	            thisp = arguments[1],
	            i = -1,
	            length = self.length >>> 0;
	
	        // If no callback function or if callback is not a callable function
	        if (!isFunction(fun)) {
	            throw new TypeError(); // TODO message
	        }
	
	        while (++i < length) {
	            if (i in self) {
	                // Invoke the callback function with call, passing arguments:
	                // context, property value, property key, thisArg object
	                // context
	                fun.call(thisp, self[i], i, object);
	            }
	        }
	    }
	}, !properlyBoxesContext(ArrayPrototype.forEach));
	
	// ES5 15.4.4.14
	// http://es5.github.com/#x15.4.4.14
	// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
	var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
	defineProperties(ArrayPrototype, {
	    indexOf: function indexOf(sought /*, fromIndex */ ) {
	        var self = splitString && isString(this) ? this.split('') : toObject(this),
	            length = self.length >>> 0;
	
	        if (!length) {
	            return -1;
	        }
	
	        var i = 0;
	        if (arguments.length > 1) {
	            i = toInteger(arguments[1]);
	        }
	
	        // handle negative indices
	        i = i >= 0 ? i : Math.max(0, length + i);
	        for (; i < length; i++) {
	            if (i in self && self[i] === sought) {
	                return i;
	            }
	        }
	        return -1;
	    }
	}, hasFirefox2IndexOfBug);
	
	//
	// String
	// ======
	//
	
	// ES5 15.5.4.14
	// http://es5.github.com/#x15.5.4.14
	
	// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
	// Many browsers do not split properly with regular expressions or they
	// do not perform the split correctly under obscure conditions.
	// See http://blog.stevenlevithan.com/archives/cross-browser-split
	// I've tested in many browsers and this seems to cover the deviant ones:
	//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
	//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
	//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
	//       [undefined, "t", undefined, "e", ...]
	//    ''.split(/.?/) should be [], not [""]
	//    '.'.split(/()()/) should be ["."], not ["", "", "."]
	
	var string_split = StringPrototype.split;
	if (
	    'ab'.split(/(?:ab)*/).length !== 2 ||
	    '.'.split(/(.?)(.?)/).length !== 4 ||
	    'tesst'.split(/(s)*/)[1] === 't' ||
	    'test'.split(/(?:)/, -1).length !== 4 ||
	    ''.split(/.?/).length ||
	    '.'.split(/()()/).length > 1
	) {
	    (function () {
	        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group
	
	        StringPrototype.split = function (separator, limit) {
	            var string = this;
	            if (separator === void 0 && limit === 0) {
	                return [];
	            }
	
	            // If `separator` is not a regex, use native split
	            if (_toString.call(separator) !== '[object RegExp]') {
	                return string_split.call(this, separator, limit);
	            }
	
	            var output = [],
	                flags = (separator.ignoreCase ? 'i' : '') +
	                        (separator.multiline  ? 'm' : '') +
	                        (separator.extended   ? 'x' : '') + // Proposed for ES6
	                        (separator.sticky     ? 'y' : ''), // Firefox 3+
	                lastLastIndex = 0,
	                // Make `global` and avoid `lastIndex` issues by working with a copy
	                separator2, match, lastIndex, lastLength;
	            separator = new RegExp(separator.source, flags + 'g');
	            string += ''; // Type-convert
	            if (!compliantExecNpcg) {
	                // Doesn't need flags gy, but they don't hurt
	                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
	            }
	            /* Values for `limit`, per the spec:
	             * If undefined: 4294967295 // Math.pow(2, 32) - 1
	             * If 0, Infinity, or NaN: 0
	             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
	             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
	             * If other: Type-convert, then use the above rules
	             */
	            limit = limit === void 0 ?
	                -1 >>> 0 : // Math.pow(2, 32) - 1
	                ToUint32(limit);
	            while (match = separator.exec(string)) {
	                // `separator.lastIndex` is not reliable cross-browser
	                lastIndex = match.index + match[0].length;
	                if (lastIndex > lastLastIndex) {
	                    output.push(string.slice(lastLastIndex, match.index));
	                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
	                    // nonparticipating capturing groups
	                    if (!compliantExecNpcg && match.length > 1) {
	                        match[0].replace(separator2, function () {
	                            for (var i = 1; i < arguments.length - 2; i++) {
	                                if (arguments[i] === void 0) {
	                                    match[i] = void 0;
	                                }
	                            }
	                        });
	                    }
	                    if (match.length > 1 && match.index < string.length) {
	                        ArrayPrototype.push.apply(output, match.slice(1));
	                    }
	                    lastLength = match[0].length;
	                    lastLastIndex = lastIndex;
	                    if (output.length >= limit) {
	                        break;
	                    }
	                }
	                if (separator.lastIndex === match.index) {
	                    separator.lastIndex++; // Avoid an infinite loop
	                }
	            }
	            if (lastLastIndex === string.length) {
	                if (lastLength || !separator.test('')) {
	                    output.push('');
	                }
	            } else {
	                output.push(string.slice(lastLastIndex));
	            }
	            return output.length > limit ? output.slice(0, limit) : output;
	        };
	    }());
	
	// [bugfix, chrome]
	// If separator is undefined, then the result array contains just one String,
	// which is the this value (converted to a String). If limit is not undefined,
	// then the output array is truncated so that it contains no more than limit
	// elements.
	// "0".split(undefined, 0) -> []
	} else if ('0'.split(void 0, 0).length) {
	    StringPrototype.split = function split(separator, limit) {
	        if (separator === void 0 && limit === 0) { return []; }
	        return string_split.call(this, separator, limit);
	    };
	}
	
	// ES5 15.5.4.20
	// whitespace from: http://es5.github.io/#x15.5.4.20
	var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
	    '\u2029\uFEFF';
	var zeroWidth = '\u200b';
	var wsRegexChars = '[' + ws + ']';
	var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
	var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
	var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
	defineProperties(StringPrototype, {
	    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
	    // http://perfectionkills.com/whitespace-deviations/
	    trim: function trim() {
	        if (this === void 0 || this === null) {
	            throw new TypeError("can't convert " + this + ' to object');
	        }
	        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
	    }
	}, hasTrimWhitespaceBug);
	
	// ECMA-262, 3rd B.2.3
	// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
	// non-normative section suggesting uniform semantics and it should be
	// normalized across all browsers
	// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
	var string_substr = StringPrototype.substr;
	var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
	defineProperties(StringPrototype, {
	    substr: function substr(start, length) {
	        return string_substr.call(
	            this,
	            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
	            length
	        );
	    }
	}, hasNegativeSubstrBug);


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(44);
	
	// Some extra characters that Chrome gets wrong, and substitutes with
	// something else on the wire.
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
	  , extraLookup;
	
	// This may be quite slow, so let's delay until user actually uses bad
	// characters.
	var unrollLookup = function(escapable) {
	  var i;
	  var unrolled = {};
	  var c = [];
	  for (i = 0; i < 65536; i++) {
	    c.push( String.fromCharCode(i) );
	  }
	  escapable.lastIndex = 0;
	  c.join('').replace(escapable, function(a) {
	    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    return '';
	  });
	  escapable.lastIndex = 0;
	  return unrolled;
	};
	
	// Quote string, also taking care of unicode characters that browsers
	// often break. Especially, take care of unicode surrogates:
	// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
	module.exports = {
	  quote: function(string) {
	    var quoted = JSON3.stringify(string);
	
	    // In most cases this should be very fast and good enough.
	    extraEscapable.lastIndex = 0;
	    if (!extraEscapable.test(quoted)) {
	      return quoted;
	    }
	
	    if (!extraLookup) {
	      extraLookup = unrollLookup(extraEscapable);
	    }
	
	    return quoted.replace(extraEscapable, function(a) {
	      return extraLookup[a];
	    });
	  }
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:utils:transport');
	}
	
	module.exports = function(availableTransports) {
	  return {
	    filterToEnabled: function(transportsWhitelist, info) {
	      var transports = {
	        main: []
	      , facade: []
	      };
	      if (!transportsWhitelist) {
	        transportsWhitelist = [];
	      } else if (typeof transportsWhitelist === 'string') {
	        transportsWhitelist = [transportsWhitelist];
	      }
	
	      availableTransports.forEach(function(trans) {
	        if (!trans) {
	          return;
	        }
	
	        if (trans.transportName === 'websocket' && info.websocket === false) {
	          debug('disabled from server', 'websocket');
	          return;
	        }
	
	        if (transportsWhitelist.length &&
	            transportsWhitelist.indexOf(trans.transportName) === -1) {
	          debug('not in whitelist', trans.transportName);
	          return;
	        }
	
	        if (trans.enabled(info)) {
	          debug('enabled', trans.transportName);
	          transports.main.push(trans);
	          if (trans.facadeTransport) {
	            transports.facade.push(trans.facadeTransport);
	          }
	        } else {
	          debug('disabled', trans.transportName);
	        }
	      });
	      return transports;
	    }
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 60 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var logObject = {};
	['log', 'debug', 'warn'].forEach(function (level) {
	  var levelExists = global.console && global.console[level] && global.console[level].apply;
	  logObject[level] = levelExists ? function () {
	    return global.console[level].apply(global.console, arguments);
	  } : (level === 'log' ? function () {} : logObject.log);
	});
	
	module.exports = logObject;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 61 */
/***/ function(module, exports) {

	'use strict';
	
	function Event(eventType) {
	  this.type = eventType;
	}
	
	Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
	  this.type = eventType;
	  this.bubbles = canBubble;
	  this.cancelable = cancelable;
	  this.timeStamp = +new Date();
	  return this;
	};
	
	Event.prototype.stopPropagation = function() {};
	Event.prototype.preventDefault  = function() {};
	
	Event.CAPTURING_PHASE = 1;
	Event.AT_TARGET       = 2;
	Event.BUBBLING_PHASE  = 3;
	
	module.exports = Event;


/***/ },
/* 62 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	module.exports = global.location || {
	  origin: 'http://localhost:80'
	, protocol: 'http'
	, host: 'localhost'
	, port: 80
	, href: 'http://localhost/'
	, hash: ''
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , Event = __webpack_require__(61)
	  ;
	
	function CloseEvent() {
	  Event.call(this);
	  this.initEvent('close', false, false);
	  this.wasClean = false;
	  this.code = 0;
	  this.reason = '';
	}
	
	inherits(CloseEvent, Event);
	
	module.exports = CloseEvent;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , Event = __webpack_require__(61)
	  ;
	
	function TransportMessageEvent(data) {
	  Event.call(this);
	  this.initEvent('message', false, false);
	  this.data = data;
	}
	
	inherits(TransportMessageEvent, Event);
	
	module.exports = TransportMessageEvent;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  , urlUtils = __webpack_require__(15)
	  , XDR = __webpack_require__(38)
	  , XHRCors = __webpack_require__(33)
	  , XHRLocal = __webpack_require__(35)
	  , XHRFake = __webpack_require__(66)
	  , InfoIframe = __webpack_require__(67)
	  , InfoAjax = __webpack_require__(69)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:info-receiver');
	}
	
	function InfoReceiver(baseUrl, urlInfo) {
	  debug(baseUrl);
	  var self = this;
	  EventEmitter.call(this);
	
	  setTimeout(function() {
	    self.doXhr(baseUrl, urlInfo);
	  }, 0);
	}
	
	inherits(InfoReceiver, EventEmitter);
	
	// TODO this is currently ignoring the list of available transports and the whitelist
	
	InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
	  // determine method of CORS support (if needed)
	  if (urlInfo.sameOrigin) {
	    return new InfoAjax(url, XHRLocal);
	  }
	  if (XHRCors.enabled) {
	    return new InfoAjax(url, XHRCors);
	  }
	  if (XDR.enabled && urlInfo.sameScheme) {
	    return new InfoAjax(url, XDR);
	  }
	  if (InfoIframe.enabled()) {
	    return new InfoIframe(baseUrl, url);
	  }
	  return new InfoAjax(url, XHRFake);
	};
	
	InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
	  var self = this
	    , url = urlUtils.addPath(baseUrl, '/info')
	    ;
	  debug('doXhr', url);
	
	  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);
	
	  this.timeoutRef = setTimeout(function() {
	    debug('timeout');
	    self._cleanup(false);
	    self.emit('finish');
	  }, InfoReceiver.timeout);
	
	  this.xo.once('finish', function(info, rtt) {
	    debug('finish', info, rtt);
	    self._cleanup(true);
	    self.emit('finish', info, rtt);
	  });
	};
	
	InfoReceiver.prototype._cleanup = function(wasClean) {
	  debug('_cleanup');
	  clearTimeout(this.timeoutRef);
	  this.timeoutRef = null;
	  if (!wasClean && this.xo) {
	    this.xo.close();
	  }
	  this.xo = null;
	};
	
	InfoReceiver.prototype.close = function() {
	  debug('close');
	  this.removeAllListeners();
	  this._cleanup(false);
	};
	
	InfoReceiver.timeout = 8000;
	
	module.exports = InfoReceiver;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  ;
	
	function XHRFake(/* method, url, payload, opts */) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.to = setTimeout(function() {
	    self.emit('finish', 200, '{}');
	  }, XHRFake.timeout);
	}
	
	inherits(XHRFake, EventEmitter);
	
	XHRFake.prototype.close = function() {
	  clearTimeout(this.to);
	};
	
	XHRFake.timeout = 2000;
	
	module.exports = XHRFake;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  , JSON3 = __webpack_require__(44)
	  , utils = __webpack_require__(12)
	  , IframeTransport = __webpack_require__(43)
	  , InfoReceiverIframe = __webpack_require__(68)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:info-iframe');
	}
	
	function InfoIframe(baseUrl, url) {
	  var self = this;
	  EventEmitter.call(this);
	
	  var go = function() {
	    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);
	
	    ifr.once('message', function(msg) {
	      if (msg) {
	        var d;
	        try {
	          d = JSON3.parse(msg);
	        } catch (e) {
	          debug('bad json', msg);
	          self.emit('finish');
	          self.close();
	          return;
	        }
	
	        var info = d[0], rtt = d[1];
	        self.emit('finish', info, rtt);
	      }
	      self.close();
	    });
	
	    ifr.once('close', function() {
	      self.emit('finish');
	      self.close();
	    });
	  };
	
	  // TODO this seems the same as the 'needBody' from transports
	  if (!global.document.body) {
	    utils.attachEvent('load', go);
	  } else {
	    go();
	  }
	}
	
	inherits(InfoIframe, EventEmitter);
	
	InfoIframe.enabled = function() {
	  return IframeTransport.enabled();
	};
	
	InfoIframe.prototype.close = function() {
	  if (this.ifr) {
	    this.ifr.close();
	  }
	  this.removeAllListeners();
	  this.ifr = null;
	};
	
	module.exports = InfoIframe;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11), (function() { return this; }())))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(23)
	  , EventEmitter = __webpack_require__(24).EventEmitter
	  , JSON3 = __webpack_require__(44)
	  , XHRLocalObject = __webpack_require__(35)
	  , InfoAjax = __webpack_require__(69)
	  ;
	
	function InfoReceiverIframe(transUrl) {
	  var self = this;
	  EventEmitter.call(this);
	
	  this.ir = new InfoAjax(transUrl, XHRLocalObject);
	  this.ir.once('finish', function(info, rtt) {
	    self.ir = null;
	    self.emit('message', JSON3.stringify([info, rtt]));
	  });
	}
	
	inherits(InfoReceiverIframe, EventEmitter);
	
	InfoReceiverIframe.transportName = 'iframe-info-receiver';
	
	InfoReceiverIframe.prototype.close = function() {
	  if (this.ir) {
	    this.ir.close();
	    this.ir = null;
	  }
	  this.removeAllListeners();
	};
	
	module.exports = InfoReceiverIframe;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var EventEmitter = __webpack_require__(24).EventEmitter
	  , inherits = __webpack_require__(23)
	  , JSON3 = __webpack_require__(44)
	  , objectUtils = __webpack_require__(48)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:info-ajax');
	}
	
	function InfoAjax(url, AjaxObject) {
	  EventEmitter.call(this);
	
	  var self = this;
	  var t0 = +new Date();
	  this.xo = new AjaxObject('GET', url);
	
	  this.xo.once('finish', function(status, text) {
	    var info, rtt;
	    if (status === 200) {
	      rtt = (+new Date()) - t0;
	      if (text) {
	        try {
	          info = JSON3.parse(text);
	        } catch (e) {
	          debug('bad json', text);
	        }
	      }
	
	      if (!objectUtils.isObject(info)) {
	        info = {};
	      }
	    }
	    self.emit('finish', info, rtt);
	    self.removeAllListeners();
	  });
	}
	
	inherits(InfoAjax, EventEmitter);
	
	InfoAjax.prototype.close = function() {
	  this.removeAllListeners();
	  this.xo.close();
	};
	
	module.exports = InfoAjax;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var urlUtils = __webpack_require__(15)
	  , eventUtils = __webpack_require__(12)
	  , JSON3 = __webpack_require__(44)
	  , FacadeJS = __webpack_require__(71)
	  , InfoIframeReceiver = __webpack_require__(68)
	  , iframeUtils = __webpack_require__(47)
	  , loc = __webpack_require__(62)
	  ;
	
	var debug = function() {};
	if (process.env.NODE_ENV !== 'production') {
	  debug = __webpack_require__(20)('sockjs-client:iframe-bootstrap');
	}
	
	module.exports = function(SockJS, availableTransports) {
	  var transportMap = {};
	  availableTransports.forEach(function(at) {
	    if (at.facadeTransport) {
	      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
	    }
	  });
	
	  // hard-coded for the info iframe
	  // TODO see if we can make this more dynamic
	  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
	  var parentOrigin;
	
	  /* eslint-disable camelcase */
	  SockJS.bootstrap_iframe = function() {
	    /* eslint-enable camelcase */
	    var facade;
	    iframeUtils.currentWindowId = loc.hash.slice(1);
	    var onMessage = function(e) {
	      if (e.source !== parent) {
	        return;
	      }
	      if (typeof parentOrigin === 'undefined') {
	        parentOrigin = e.origin;
	      }
	      if (e.origin !== parentOrigin) {
	        return;
	      }
	
	      var iframeMessage;
	      try {
	        iframeMessage = JSON3.parse(e.data);
	      } catch (ignored) {
	        debug('bad json', e.data);
	        return;
	      }
	
	      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
	        return;
	      }
	      switch (iframeMessage.type) {
	      case 's':
	        var p;
	        try {
	          p = JSON3.parse(iframeMessage.data);
	        } catch (ignored) {
	          debug('bad json', iframeMessage.data);
	          break;
	        }
	        var version = p[0];
	        var transport = p[1];
	        var transUrl = p[2];
	        var baseUrl = p[3];
	        debug(version, transport, transUrl, baseUrl);
	        // change this to semver logic
	        if (version !== SockJS.version) {
	          throw new Error('Incompatibile SockJS! Main site uses:' +
	                    ' "' + version + '", the iframe:' +
	                    ' "' + SockJS.version + '".');
	        }
	
	        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
	            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
	          throw new Error('Can\'t connect to different domain from within an ' +
	                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
	        }
	        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
	        break;
	      case 'm':
	        facade._send(iframeMessage.data);
	        break;
	      case 'c':
	        if (facade) {
	          facade._close();
	        }
	        facade = null;
	        break;
	      }
	    };
	
	    eventUtils.attachEvent('message', onMessage);
	
	    // Start
	    iframeUtils.postMessage('s');
	  };
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var JSON3 = __webpack_require__(44)
	  , iframeUtils = __webpack_require__(47)
	  ;
	
	function FacadeJS(transport) {
	  this._transport = transport;
	  transport.on('message', this._transportMessage.bind(this));
	  transport.on('close', this._transportClose.bind(this));
	}
	
	FacadeJS.prototype._transportClose = function(code, reason) {
	  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
	};
	FacadeJS.prototype._transportMessage = function(frame) {
	  iframeUtils.postMessage('t', frame);
	};
	FacadeJS.prototype._send = function(data) {
	  this._transport.send(data);
	};
	FacadeJS.prototype._close = function() {
	  this._transport.close();
	  this._transport.removeAllListeners();
	};
	
	module.exports = FacadeJS;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(73)();
	
	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
	};


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals window __webpack_hash__ */
	if(true) {
		var lastData;
		var upToDate = function upToDate() {
			return lastData.indexOf(__webpack_require__.h()) >= 0;
		};
		var check = function check() {
			module.hot.check(true, function(err, updatedModules) {
				if(err) {
					if(module.hot.status() in {
							abort: 1,
							fail: 1
						}) {
						console.warn("[HMR] Cannot apply update. Need to do a full reload!");
						console.warn("[HMR] " + err.stack || err.message);
						window.location.reload();
					} else {
						console.warn("[HMR] Update failed: " + err.stack || err.message);
					}
					return;
				}
	
				if(!updatedModules) {
					console.warn("[HMR] Cannot find update. Need to do a full reload!");
					console.warn("[HMR] (Probably because of restarting the webpack-dev-server)");
					window.location.reload();
					return;
				}
	
				if(!upToDate()) {
					check();
				}
	
				__webpack_require__(75)(updatedModules, updatedModules);
	
				if(upToDate()) {
					console.log("[HMR] App is up to date.");
				}
	
			});
		};
		var addEventListener = window.addEventListener ? function(eventName, listener) {
			window.addEventListener(eventName, listener, false);
		} : function(eventName, listener) {
			window.attachEvent("on" + eventName, listener);
		};
		addEventListener("message", function(event) {
			if(typeof event.data === "string" && event.data.indexOf("webpackHotUpdate") === 0) {
				lastData = event.data;
				if(!upToDate() && module.hot.status() === "idle") {
					console.log("[HMR] Checking for updates on the server...");
					check();
				}
			}
		});
		console.log("[HMR] Waiting for update signal from WDS...");
	} else {
		throw new Error("[HMR] Hot Module Replacement is disabled.");
	}


/***/ },
/* 75 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(updatedModules, renewedModules) {
		var unacceptedModules = updatedModules.filter(function(moduleId) {
			return renewedModules && renewedModules.indexOf(moduleId) < 0;
		});
	
		if(unacceptedModules.length > 0) {
			console.warn("[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
			unacceptedModules.forEach(function(moduleId) {
				console.warn("[HMR]  - " + moduleId);
			});
		}
	
		if(!renewedModules || renewedModules.length === 0) {
			console.log("[HMR] Nothing hot updated.");
		} else {
			console.log("[HMR] Updated modules:");
			renewedModules.forEach(function(moduleId) {
				console.log("[HMR]  - " + moduleId);
			});
		}
	};


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(77);
	
	var _ASAPScheduler = __webpack_require__(378);
	
	var _ASAPScheduler2 = _interopRequireDefault(_ASAPScheduler);
	
	var _BehaviorSubject = __webpack_require__(96);
	
	__webpack_require__(420);
	
	__webpack_require__(423);
	
	__webpack_require__(121);
	
	__webpack_require__(123);
	
	__webpack_require__(125);
	
	__webpack_require__(127);
	
	__webpack_require__(426);
	
	__webpack_require__(429);
	
	__webpack_require__(434);
	
	__webpack_require__(204);
	
	__webpack_require__(435);
	
	__webpack_require__(437);
	
	__webpack_require__(131);
	
	__webpack_require__(439);
	
	__webpack_require__(441);
	
	__webpack_require__(443);
	
	__webpack_require__(445);
	
	var _snabbdom = __webpack_require__(447);
	
	var _snabbdom2 = _interopRequireDefault(_snabbdom);
	
	var _class = __webpack_require__(451);
	
	var _class2 = _interopRequireDefault(_class);
	
	var _props = __webpack_require__(452);
	
	var _props2 = _interopRequireDefault(_props);
	
	var _style = __webpack_require__(453);
	
	var _style2 = _interopRequireDefault(_style);
	
	var _attributes = __webpack_require__(454);
	
	var _attributes2 = _interopRequireDefault(_attributes);
	
	var _eventlisteners = __webpack_require__(455);
	
	var _eventlisteners2 = _interopRequireDefault(_eventlisteners);
	
	var _App = __webpack_require__(456);
	
	var _Routes = __webpack_require__(485);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** @jsx hJSX */
	
	
	var patch = _snabbdom2.default.init([_class2.default, _props2.default, _style2.default, _attributes2.default, _eventlisteners2.default]);
	
	var rootElement = document.body.appendChild(document.createElement('div'));
	
	var modules = new _BehaviorSubject.BehaviorSubject({ App: _App.App, Routes: _Routes.Routes });
	
	modules.switchMap(function (_ref) {
	    var App = _ref.App;
	    var Routes = _ref.Routes;
	
	
	    // Read the cache from local storage if possible.
	    var TodoCache = JSON.parse(localStorage.getItem('todos-reaxtor') || 'null');
	    if (!TodoCache || !TodoCache.apiVersion || !TodoCache.apiVersion.value === 0) {
	        TodoCache = null;
	    }
	
	    // Initialize the routes with the cache from local storage.
	    var TodoRouter = _.Router.createClass(Routes(TodoCache || undefined));
	
	    // Create root App Component (Observable)
	    return (0, _.reaxtor)(App, new _.Model({
	        materialized: true,
	        treatErrorsAsValues: true,
	        allowFromWhenceYouCame: true,
	        scheduler: new _ASAPScheduler2.default(),
	        source: new TodoRouter(),
	        onChangesCompleted: function onChangesCompleted() {
	            localStorage.setItem('todos-reaxtor', JSON.stringify(this.getCache()));
	        }
	    }));
	}).scan(patch, rootElement).subscribe();
	
	// If hot module replacement is enabled, listen for changes to App and Routes.
	if (true) {
	    // We accept updates to the top component
	    module.hot.accept([456, 483, 485, 471, 484, 457], function () {
	        // Dispatch the new modules to the modules Subject.
	        modules.next({
	            App: __webpack_require__(456),
	            Controls: __webpack_require__(483),
	            Routes: __webpack_require__(485),
	            Task: __webpack_require__(471),
	            TaskInput: __webpack_require__(484),
	            Tasks: __webpack_require__(457)
	        });
	    });
	}

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.reaxtor = exports.Container = exports.Component = exports.Router = exports.Event = exports.Model = exports.hJSX = undefined;
	
	var _Subject = __webpack_require__(78);
	
	var _Observable = __webpack_require__(79);
	
	var _Subscriber = __webpack_require__(83);
	
	var _BehaviorSubject = __webpack_require__(96);
	
	__webpack_require__(97);
	
	__webpack_require__(103);
	
	__webpack_require__(113);
	
	__webpack_require__(119);
	
	__webpack_require__(121);
	
	__webpack_require__(123);
	
	__webpack_require__(125);
	
	__webpack_require__(127);
	
	__webpack_require__(129);
	
	__webpack_require__(131);
	
	__webpack_require__(133);
	
	var _falcorRouter = __webpack_require__(135);
	
	var _falcorRouter2 = _interopRequireDefault(_falcorRouter);
	
	var _Model = __webpack_require__(246);
	
	var _Event = __webpack_require__(404);
	
	var _Component = __webpack_require__(405);
	
	var _Container = __webpack_require__(418);
	
	var _snabbdomJsx = __webpack_require__(419);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_Subscriber.Subscriber.prototype.onNext = _Subscriber.Subscriber.prototype.next; /** @jsx hJSX */
	
	_Subscriber.Subscriber.prototype.onError = _Subscriber.Subscriber.prototype.error;
	_Subscriber.Subscriber.prototype.onCompleted = _Subscriber.Subscriber.prototype.complete;
	
	_Subject.Subject.prototype.onNext = _Subject.Subject.prototype.next;
	_Subject.Subject.prototype.onError = _Subject.Subject.prototype.error;
	_Subject.Subject.prototype.onCompleted = _Subject.Subject.prototype.complete;
	
	exports.hJSX = _snabbdomJsx.html;
	exports.Model = _Model.Model;
	exports.Event = _Event.Event;
	exports.Router = _falcorRouter2.default;
	exports.Component = _Component.Component;
	exports.Container = _Container.Container;
	exports.reaxtor = reaxtor;
	
	
	function reaxtor(RootClass, model) {
	
	    var working = false;
	    var reenter = false;
	
	    var models = new _BehaviorSubject.BehaviorSubject([model]);
	    var previousOnChangesCompleted = model._root.onChangesCompleted;
	
	    model._root.onChangesCompleted = function () {
	        if (working) {
	            return reenter = true;
	        }
	        working = true;
	        do {
	            reenter = false;
	            // console.log('\nstart top-down render ----> [');
	            if (previousOnChangesCompleted) {
	                previousOnChangesCompleted.call(this);
	            }
	            models.next([this]);
	            // console.log('] <---- end top-down render\n');
	        } while (reenter === true);
	    };
	
	    return new RootClass({ models: models }).do(function () {
	        working = false;
	    });
	}
	//# sourceMappingURL=index.js.map

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	var Subscriber_1 = __webpack_require__(83);
	var Subscription_1 = __webpack_require__(85);
	var SubjectSubscription_1 = __webpack_require__(93);
	var rxSubscriber_1 = __webpack_require__(91);
	var throwError_1 = __webpack_require__(94);
	var ObjectUnsubscribedError_1 = __webpack_require__(95);
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.isStopped = false;
	        this.hasErrored = false;
	        this.dispatching = false;
	        this.hasCompleted = false;
	        this.source = source;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new Subject(this.destination || this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.add = function (subscription) {
	        return Subscription_1.Subscription.prototype.add.call(this, subscription);
	    };
	    Subject.prototype.remove = function (subscription) {
	        Subscription_1.Subscription.prototype.remove.call(this, subscription);
	    };
	    Subject.prototype.unsubscribe = function () {
	        Subscription_1.Subscription.prototype.unsubscribe.call(this);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            if (subscriber.isUnsubscribed) {
	                return;
	            }
	            else if (this.hasErrored) {
	                return subscriber.error(this.errorValue);
	            }
	            else if (this.hasCompleted) {
	                return subscriber.complete();
	            }
	            this.throwIfUnsubscribed();
	            var subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	            this.observers.push(subscriber);
	            return subscription;
	        }
	    };
	    Subject.prototype._unsubscribe = function () {
	        this.source = null;
	        this.isStopped = true;
	        this.observers = null;
	        this.destination = null;
	    };
	    Subject.prototype.next = function (value) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.hasErrored) {
	            this._error(this.errorValue);
	        }
	        else if (this.hasCompleted) {
	            this._complete();
	        }
	    };
	    Subject.prototype.error = function (err) {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasErrored = true;
	        this.errorValue = err;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(err);
	    };
	    Subject.prototype.complete = function () {
	        this.throwIfUnsubscribed();
	        if (this.isStopped) {
	            return;
	        }
	        this.isStopped = true;
	        this.hasCompleted = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new SubjectObservable(this);
	        return observable;
	    };
	    Subject.prototype._next = function (value) {
	        if (this.destination) {
	            this.destination.next(value);
	        }
	        else {
	            this._finalNext(value);
	        }
	    };
	    Subject.prototype._finalNext = function (value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };
	    Subject.prototype._error = function (err) {
	        if (this.destination) {
	            this.destination.error(err);
	        }
	        else {
	            this._finalError(err);
	        }
	    };
	    Subject.prototype._finalError = function (err) {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].error(err);
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype._complete = function () {
	        if (this.destination) {
	            this.destination.complete();
	        }
	        else {
	            this._finalComplete();
	        }
	    };
	    Subject.prototype._finalComplete = function () {
	        var index = -1;
	        var observers = this.observers;
	        // optimization to block our SubjectSubscriptions from
	        // splicing themselves out of the observers list one by one.
	        this.observers = null;
	        this.isUnsubscribed = true;
	        if (observers) {
	            var len = observers.length;
	            while (++index < len) {
	                observers[index].complete();
	            }
	        }
	        this.isUnsubscribed = false;
	        this.unsubscribe();
	    };
	    Subject.prototype.throwIfUnsubscribed = function () {
	        if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	    };
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new Subscriber_1.Subscriber(this);
	    };
	    Subject.create = function (destination, source) {
	        return new Subject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectObservable = (function (_super) {
	    __extends(SubjectObservable, _super);
	    function SubjectObservable(source) {
	        _super.call(this);
	        this.source = source;
	    }
	    return SubjectObservable;
	}(Observable_1.Observable));
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(80);
	var observable_1 = __webpack_require__(81);
	var toSubscriber_1 = __webpack_require__(82);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     * @method subscribe
	     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` imple will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {"use strict";
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	/* tslint:disable:no-unused-variable */
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = freeGlobal;
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module), (function() { return this; }())))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(80);
	var Symbol = root_1.root.Symbol;
	if (typeof Symbol === 'function') {
	    if (Symbol.observable) {
	        exports.$$observable = Symbol.observable;
	    }
	    else {
	        if (typeof Symbol.for === 'function') {
	            exports.$$observable = Symbol.for('observable');
	        }
	        else {
	            exports.$$observable = Symbol('observable');
	        }
	        Symbol.observable = exports.$$observable;
	    }
	}
	else {
	    exports.$$observable = '@@observable';
	}
	//# sourceMappingURL=observable.js.map

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(83);
	var rxSubscriber_1 = __webpack_require__(91);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver && typeof nextOrObserver === 'object') {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(84);
	var Subscription_1 = __webpack_require__(85);
	var rxSubscriber_1 = __webpack_require__(91);
	var Observer_1 = __webpack_require__(92);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 84 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(86);
	var isObject_1 = __webpack_require__(87);
	var isFunction_1 = __webpack_require__(84);
	var tryCatch_1 = __webpack_require__(88);
	var errorObject_1 = __webpack_require__(89);
	var UnsubscriptionError_1 = __webpack_require__(90);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.isUnsubscribed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `isUnsubscribed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
	            return;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.isUnsubscribed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 86 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 87 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(89);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 90 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        this.name = 'UnsubscriptionError';
	        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n') : '';
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(80);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 92 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    isUnsubscribed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(85);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, observer) {
	        _super.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 94 */
/***/ function(module, exports) {

	"use strict";
	function throwError(e) { throw e; }
	exports.throwError = throwError;
	//# sourceMappingURL=throwError.js.map

/***/ },
/* 95 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        _super.call(this, 'object unsubscribed');
	        this.name = 'ObjectUnsubscribedError';
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(78);
	var throwError_1 = __webpack_require__(94);
	var ObjectUnsubscribedError_1 = __webpack_require__(95);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasErrored) {
	            throwError_1.throwError(this.errorValue);
	        }
	        else if (this.isUnsubscribed) {
	            throwError_1.throwError(new ObjectUnsubscribedError_1.ObjectUnsubscribedError());
	        }
	        else {
	            return this._value;
	        }
	    };
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.isUnsubscribed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype._next = function (value) {
	        _super.prototype._next.call(this, this._value = value);
	    };
	    BehaviorSubject.prototype._error = function (err) {
	        this.hasErrored = true;
	        _super.prototype._error.call(this, this.errorValue = err);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;
	//# sourceMappingURL=BehaviorSubject.js.map

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var of_1 = __webpack_require__(98);
	Observable_1.Observable.of = of_1.of;
	//# sourceMappingURL=of.js.map

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(99);
	exports.of = ArrayObservable_1.ArrayObservable.of;
	//# sourceMappingURL=of.js.map

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	var ScalarObservable_1 = __webpack_require__(100);
	var EmptyObservable_1 = __webpack_require__(101);
	var isScheduler_1 = __webpack_require__(102);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` Scheduler, which means the `next`
	     * notifications are sent synchronously, although with a different Scheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.isUnsubscribed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;
	//# sourceMappingURL=ArrayObservable.js.map

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.isUnsubscribed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;
	//# sourceMappingURL=ScalarObservable.js.map

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;
	//# sourceMappingURL=EmptyObservable.js.map

/***/ },
/* 102 */
/***/ function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;
	//# sourceMappingURL=isScheduler.js.map

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var from_1 = __webpack_require__(104);
	Observable_1.Observable.from = from_1.from;
	//# sourceMappingURL=from.js.map

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromObservable_1 = __webpack_require__(105);
	exports.from = FromObservable_1.FromObservable.create;
	//# sourceMappingURL=from.js.map

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(86);
	var isFunction_1 = __webpack_require__(84);
	var isPromise_1 = __webpack_require__(106);
	var isScheduler_1 = __webpack_require__(102);
	var PromiseObservable_1 = __webpack_require__(107);
	var IteratorObservable_1 = __webpack_require__(108);
	var ArrayObservable_1 = __webpack_require__(99);
	var ArrayLikeObservable_1 = __webpack_require__(110);
	var observable_1 = __webpack_require__(81);
	var iterator_1 = __webpack_require__(109);
	var Observable_1 = __webpack_require__(79);
	var observeOn_1 = __webpack_require__(111);
	var isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    FromObservable.create = function (ish, mapFnOrScheduler, thisArg, lastScheduler) {
	        var scheduler = null;
	        var mapFn = null;
	        if (isFunction_1.isFunction(mapFnOrScheduler)) {
	            scheduler = lastScheduler || null;
	            mapFn = mapFnOrScheduler;
	        }
	        else if (isScheduler_1.isScheduler(scheduler)) {
	            scheduler = mapFnOrScheduler;
	        }
	        if (ish != null) {
	            if (typeof ish[observable_1.$$observable] === 'function') {
	                if (ish instanceof Observable_1.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1.isArray(ish)) {
	                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, null, null, scheduler);
	            }
	            else if (isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, mapFn, thisArg, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[observable_1.$$observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[observable_1.$$observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1.Observable));
	exports.FromObservable = FromObservable;
	//# sourceMappingURL=FromObservable.js.map

/***/ },
/* 106 */
/***/ function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(80);
	var Observable_1 = __webpack_require__(79);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * @param promise
	     * @param scheduler
	     * @return {PromiseObservable}
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        if (scheduler === void 0) { scheduler = null; }
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.isUnsubscribed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.isUnsubscribed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.isUnsubscribed) {
	        subscriber.error(err);
	    }
	}
	//# sourceMappingURL=PromiseObservable.js.map

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(80);
	var isObject_1 = __webpack_require__(87);
	var tryCatch_1 = __webpack_require__(88);
	var Observable_1 = __webpack_require__(79);
	var isFunction_1 = __webpack_require__(84);
	var iterator_1 = __webpack_require__(109);
	var errorObject_1 = __webpack_require__(89);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends(IteratorObservable, _super);
	    function IteratorObservable(iterator, project, thisArg, scheduler) {
	        _super.call(this);
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        if (isObject_1.isObject(project)) {
	            this.thisArg = project;
	            this.scheduler = thisArg;
	        }
	        else if (isFunction_1.isFunction(project)) {
	            this.project = project;
	            this.thisArg = thisArg;
	            this.scheduler = scheduler;
	        }
	        else if (project != null) {
	            throw new Error('When provided, `project` must be a function.');
	        }
	        this.iterator = getIterator(iterator);
	    }
	    IteratorObservable.create = function (iterator, project, thisArg, scheduler) {
	        return new IteratorObservable(iterator, project, thisArg, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, thisArg = state.thisArg, project = state.project, iterator = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        if (project) {
	            result = tryCatch_1.tryCatch(project).call(thisArg, result.value, index);
	            if (result === errorObject_1.errorObject) {
	                state.error = errorObject_1.errorObject.e;
	                state.hasError = true;
	            }
	            else {
	                subscriber.next(result);
	                state.index = index + 1;
	            }
	        }
	        else {
	            subscriber.next(result.value);
	            state.index = index + 1;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator = _a.iterator, project = _a.project, thisArg = _a.thisArg, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else if (project) {
	                    result = tryCatch_1.tryCatch(project).call(thisArg, result.value, index++);
	                    if (result === errorObject_1.errorObject) {
	                        subscriber.error(errorObject_1.errorObject.e);
	                        break;
	                    }
	                    subscriber.next(result);
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1.Observable));
	exports.IteratorObservable = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1.$$iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1.$$iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1.$$iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('Object is not iterable');
	    }
	    return obj[iterator_1.$$iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	//# sourceMappingURL=IteratorObservable.js.map

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(80);
	var Symbol = root_1.root.Symbol;
	if (typeof Symbol === 'function') {
	    if (Symbol.iterator) {
	        exports.$$iterator = Symbol.iterator;
	    }
	    else if (typeof Symbol.for === 'function') {
	        exports.$$iterator = Symbol.for('iterator');
	    }
	}
	else {
	    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {
	        // Bug for mozilla version
	        exports.$$iterator = '@@iterator';
	    }
	    else if (root_1.root.Map) {
	        // es6-shim specific logic
	        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {
	                exports.$$iterator = key;
	                break;
	            }
	        }
	    }
	    else {
	        exports.$$iterator = '@@iterator';
	    }
	}
	//# sourceMappingURL=iterator.js.map

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	var ScalarObservable_1 = __webpack_require__(100);
	var EmptyObservable_1 = __webpack_require__(101);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, mapFn, thisArg, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!mapFn && !scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	        if (mapFn) {
	            this.mapFn = mapFn.bind(thisArg);
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, mapFn, thisArg, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        else if (length === 1 && !mapFn) {
	            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, mapFn, thisArg, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, mapFn = state.mapFn, subscriber = state.subscriber;
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        var result = mapFn ? mapFn(arrayLike[index], index) : arrayLike[index];
	        subscriber.next(result);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, mapFn = _a.mapFn, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, mapFn: mapFn, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.isUnsubscribed; i++) {
	                var result = mapFn ? mapFn(arrayLike[i], i) : arrayLike[i];
	                subscriber.next(result);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1.Observable));
	exports.ArrayLikeObservable = ArrayLikeObservable;
	//# sourceMappingURL=ArrayLikeObservable.js.map

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var Notification_1 = __webpack_require__(112);
	/**
	 * @see {@link Notification}
	 *
	 * @param scheduler
	 * @param delay
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method observeOn
	 * @owner Observable
	 */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new ObserveOnOperator(scheduler, delay));
	}
	exports.observeOn = observeOn;
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	exports.ObserveOnOperator = ObserveOnOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ObserveOnSubscriber = (function (_super) {
	    __extends(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination;
	        notification.observe(destination);
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification_1.Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification_1.Notification.createError(err));
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification_1.Notification.createComplete());
	    };
	    return ObserveOnSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ObserveOnSubscriber = ObserveOnSubscriber;
	var ObserveOnMessage = (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());
	exports.ObserveOnMessage = ObserveOnMessage;
	//# sourceMappingURL=observeOn.js.map

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	/**
	 * Represents a push-based event or value that an {@link Observable} can emit.
	 * This class is particularly useful for operators that manage notifications,
	 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
	 * others. Besides wrapping the actual delivered value, it also annotates it
	 * with metadata of, for instance, what type of push message it is (`next`,
	 * `error`, or `complete`).
	 *
	 * @see {@link materialize}
	 * @see {@link dematerialize}
	 * @see {@link observeOn}
	 *
	 * @class Notification<T>
	 */
	var Notification = (function () {
	    function Notification(kind, value, exception) {
	        this.kind = kind;
	        this.value = value;
	        this.exception = exception;
	        this.hasValue = kind === 'N';
	    }
	    /**
	     * Delivers to the given `observer` the value wrapped by this Notification.
	     * @param {Observer} observer
	     * @return
	     */
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next && observer.next(this.value);
	            case 'E':
	                return observer.error && observer.error(this.exception);
	            case 'C':
	                return observer.complete && observer.complete();
	        }
	    };
	    /**
	     * Given some {@link Observer} callbacks, deliver the value represented by the
	     * current Notification to the correctly corresponding callback.
	     * @param {function(value: T): void} next An Observer `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next && next(this.value);
	            case 'E':
	                return error && error(this.exception);
	            case 'C':
	                return complete && complete();
	        }
	    };
	    /**
	     * Takes an Observer or its individual callback functions, and calls `observe`
	     * or `do` methods accordingly.
	     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
	     * the `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    /**
	     * Returns a simple Observable that just delivers the notification represented
	     * by this Notification instance.
	     * @return {any}
	     */
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return Observable_1.Observable.of(this.value);
	            case 'E':
	                return Observable_1.Observable.throw(this.exception);
	            case 'C':
	                return Observable_1.Observable.empty();
	        }
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `next` from a
	     * given value.
	     * @param {T} value The `next` value.
	     * @return {Notification<T>} The "next" Notification representing the
	     * argument.
	     */
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return this.undefinedValueNotification;
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `error` from a
	     * given error.
	     * @param {any} [err] The `error` exception.
	     * @return {Notification<T>} The "error" Notification representing the
	     * argument.
	     */
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `complete`.
	     * @return {Notification<any>} The valueless "complete" Notification.
	     */
	    Notification.createComplete = function () {
	        return this.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    Notification.undefinedValueNotification = new Notification('N', undefined);
	    return Notification;
	}());
	exports.Notification = Notification;
	//# sourceMappingURL=Notification.js.map

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var defer_1 = __webpack_require__(114);
	Observable_1.Observable.defer = defer_1.defer;
	//# sourceMappingURL=defer.js.map

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var DeferObservable_1 = __webpack_require__(115);
	exports.defer = DeferObservable_1.DeferObservable.create;
	//# sourceMappingURL=defer.js.map

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	var subscribeToResult_1 = __webpack_require__(116);
	var OuterSubscriber_1 = __webpack_require__(118);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var DeferObservable = (function (_super) {
	    __extends(DeferObservable, _super);
	    function DeferObservable(observableFactory) {
	        _super.call(this);
	        this.observableFactory = observableFactory;
	    }
	    /**
	     * Creates an Observable that, on subscribe, calls an Observable factory to
	     * make an Observable for each new Observer.
	     *
	     * <span class="informal">Creates the Observable lazily, that is, only when it
	     * is subscribed.
	     * </span>
	     *
	     * <img src="./img/defer.png" width="100%">
	     *
	     * `defer` allows you to create the Observable only when the Observer
	     * subscribes, and create a fresh Observable for each Observer. It waits until
	     * an Observer subscribes to it, and then it generates an Observable,
	     * typically with an Observable factory function. It does this afresh for each
	     * subscriber, so although each subscriber may think it is subscribing to the
	     * same Observable, in fact each subscriber gets its own individual
	     * Observable.
	     *
	     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
	     * var clicksOrInterval = Rx.Observable.defer(function () {
	     *   if (Math.random() > 0.5) {
	     *     return Rx.Observable.fromEvent(document, 'click');
	     *   } else {
	     *     return Rx.Observable.interval(1000);
	     *   }
	     * });
	     * clicksOrInterval.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     *
	     * @param {function(): Observable|Promise} observableFactory The Observable
	     * factory function to invoke for each Observer that subscribes to the output
	     * Observable. May also return a Promise, which will be converted on the fly
	     * to an Observable.
	     * @return {Observable} An Observable whose Observers' subscriptions trigger
	     * an invocation of the given Observable factory function.
	     * @static true
	     * @name defer
	     * @owner Observable
	     */
	    DeferObservable.create = function (observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	    DeferObservable.prototype._subscribe = function (subscriber) {
	        return new DeferSubscriber(subscriber, this.observableFactory);
	    };
	    return DeferObservable;
	}(Observable_1.Observable));
	exports.DeferObservable = DeferObservable;
	var DeferSubscriber = (function (_super) {
	    __extends(DeferSubscriber, _super);
	    function DeferSubscriber(destination, factory) {
	        _super.call(this, destination);
	        this.factory = factory;
	        this.tryDefer();
	    }
	    DeferSubscriber.prototype.tryDefer = function () {
	        try {
	            this._callFactory();
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    DeferSubscriber.prototype._callFactory = function () {
	        var result = this.factory();
	        if (result) {
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return DeferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=DeferObservable.js.map

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(80);
	var isArray_1 = __webpack_require__(86);
	var isPromise_1 = __webpack_require__(106);
	var Observable_1 = __webpack_require__(79);
	var iterator_1 = __webpack_require__(109);
	var observable_1 = __webpack_require__(81);
	var InnerSubscriber_1 = __webpack_require__(117);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.isUnsubscribed) {
	        return;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    if (isArray_1.isArray(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.isUnsubscribed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.isUnsubscribed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (typeof result[iterator_1.$$iterator] === 'function') {
	        for (var _i = 0, _a = result; _i < _a.length; _i++) {
	            var item = _a[_i];
	            destination.next(item);
	            if (destination.isUnsubscribed) {
	                break;
	            }
	        }
	        if (!destination.isUnsubscribed) {
	            destination.complete();
	        }
	    }
	    else if (typeof result[observable_1.$$observable] === 'function') {
	        var obs = result[observable_1.$$observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error('invalid observable');
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        destination.error(new TypeError('unknown type returned'));
	    }
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var empty_1 = __webpack_require__(120);
	Observable_1.Observable.empty = empty_1.empty;
	//# sourceMappingURL=empty.js.map

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EmptyObservable_1 = __webpack_require__(101);
	exports.empty = EmptyObservable_1.EmptyObservable.create;
	//# sourceMappingURL=empty.js.map

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var combineLatest_1 = __webpack_require__(122);
	Observable_1.Observable.combineLatest = combineLatest_1.combineLatestStatic;
	//# sourceMappingURL=combineLatest.js.map

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(99);
	var isArray_1 = __webpack_require__(86);
	var isScheduler_1 = __webpack_require__(102);
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from this Observable with values from
	 * Observables passed as arguments. This is done by subscribing to each
	 * Observable, in order, and collecting an array of each of the most recent
	 * values any time any of the input Observables emits, then either taking that
	 * array and passing it as arguments to an optional `project` function and
	 * emitting the return value of that, or just emitting the array of recent
	 * values directly if there is no `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    observables.unshift(this);
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	/* tslint:enable:max-line-length */
	/**
	 * Combines the values from observables passed as arguments. This is done by subscribing
	 * to each observable, in order, and collecting an array of each of the most recent values any time any of the observables
	 * emits, then either taking that array and passing it as arguments to an option `project` function and emitting the return
	 * value of that, or just emitting the array of recent values directly if there is no `project` function.
	 * @param {...Observable} observables the observables to combine
	 * @param {function} [project] an optional function to project the values from the combined recent values into a new value for emission.
	 * @return {Observable} an observable of other projected values from the most recent values from each observable, or an array of each of
	 * the most recent values from each observable.
	 * @static true
	 * @name combineLatest
	 * @owner Observable
	 */
	function combineLatestStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    var scheduler = null;
	    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new CombineLatestOperator(project));
	}
	exports.combineLatestStatic = combineLatestStatic;
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        this.project = project;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new CombineLatestSubscriber(subscriber, this.project));
	    };
	    return CombineLatestOperator;
	}());
	exports.CombineLatestOperator = CombineLatestOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CombineLatestSubscriber = (function (_super) {
	    __extends(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, project) {
	        _super.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	        this.toRespond = [];
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        var toRespond = this.toRespond;
	        toRespond.push(toRespond.length);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	        if (toRespond.length === 0) {
	            if (this.project) {
	                this._tryProject(values);
	            }
	            else {
	                this.destination.next(values);
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryProject = function (values) {
	        var result;
	        try {
	            result = this.project.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.CombineLatestSubscriber = CombineLatestSubscriber;
	//# sourceMappingURL=combineLatest.js.map

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var do_1 = __webpack_require__(124);
	Observable_1.Observable.prototype.do = do_1._do;
	//# sourceMappingURL=do.js.map

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	exports._do = _do;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=do.js.map

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var map_1 = __webpack_require__(126);
	Observable_1.Observable.prototype.map = map_1.map;
	//# sourceMappingURL=map.js.map

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=map.js.map

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var scan_1 = __webpack_require__(128);
	Observable_1.Observable.prototype.scan = scan_1.scan;
	//# sourceMappingURL=scan.js.map

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Applies an accumulation function over the source Observable, and returns each
	 * intermediate result, with an optional seed value.
	 *
	 * <span class="informal">It's like {@link reduce}, but emits the current
	 * accumulation whenever the source emits a value.</span>
	 *
	 * <img src="./img/scan.png" width="100%">
	 *
	 * Combines together all values emitted on the source, using an accumulator
	 * function that knows how to join a new source value into the accumulation from
	 * the past. Is similar to {@link reduce}, but emits the intermediate
	 * accumulations.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var ones = clicks.mapTo(1);
	 * var seed = 0;
	 * var count = ones.scan((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link reduce}
	 *
	 * @param {function(acc: R, value: T): R} accumulator The accumulator function
	 * called on each source value.
	 * @param {T|R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method scan
	 * @owner Observable
	 */
	function scan(accumulator, seed) {
	    return this.lift(new ScanOperator(accumulator, seed));
	}
	exports.scan = scan;
	var ScanOperator = (function () {
	    function ScanOperator(accumulator, seed) {
	        this.accumulator = accumulator;
	        this.seed = seed;
	    }
	    ScanOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed));
	    };
	    return ScanOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ScanSubscriber = (function (_super) {
	    __extends(ScanSubscriber, _super);
	    function ScanSubscriber(destination, accumulator, seed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.accumulatorSet = false;
	        this.seed = seed;
	        this.accumulator = accumulator;
	        this.accumulatorSet = typeof seed !== 'undefined';
	    }
	    Object.defineProperty(ScanSubscriber.prototype, "seed", {
	        get: function () {
	            return this._seed;
	        },
	        set: function (value) {
	            this.accumulatorSet = true;
	            this._seed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ScanSubscriber.prototype._next = function (value) {
	        if (!this.accumulatorSet) {
	            this.seed = value;
	            this.destination.next(value);
	        }
	        else {
	            return this._tryNext(value);
	        }
	    };
	    ScanSubscriber.prototype._tryNext = function (value) {
	        var result;
	        try {
	            result = this.accumulator(this.seed, value);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	        this.seed = result;
	        this.destination.next(result);
	    };
	    return ScanSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=scan.js.map

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var mergeMap_1 = __webpack_require__(130);
	Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
	Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;
	//# sourceMappingURL=mergeMap.js.map

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1 = __webpack_require__(116);
	var OuterSubscriber_1 = __webpack_require__(118);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	exports.mergeMap = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	exports.MergeMapOperator = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapSubscriber = MergeMapSubscriber;
	//# sourceMappingURL=mergeMap.js.map

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var switchMap_1 = __webpack_require__(132);
	Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
	//# sourceMappingURL=switchMap.js.map

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.isUnsubscribed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMap.js.map

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var distinctUntilChanged_1 = __webpack_require__(134);
	Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var tryCatch_1 = __webpack_require__(88);
	var errorObject_1 = __webpack_require__(89);
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 * If a comparator function is not provided, an equality check is used by default.
	 * @param {function} [compare] optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} an Observable that emits items from the source Observable with distinct values.
	 * @method distinctUntilChanged
	 * @owner Observable
	 */
	function distinctUntilChanged(compare, keySelector) {
	    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
	}
	exports.distinctUntilChanged = distinctUntilChanged;
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctUntilChangedSubscriber = (function (_super) {
	    __extends(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.hasKey = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var keySelector = this.keySelector;
	        var key = value;
	        if (keySelector) {
	            key = tryCatch_1.tryCatch(this.keySelector)(value);
	            if (key === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        var result = false;
	        if (this.hasKey) {
	            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
	            if (result === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (Boolean(result) === false) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=distinctUntilChanged.js.map

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	var parseTree = __webpack_require__(138);
	var matcher = __webpack_require__(163);
	var JSONGraphError = __webpack_require__(185);
	var MAX_REF_FOLLOW = 50;
	var MAX_PATHS = 9000;
	
	var Router = function(routes, options) {
	    var opts = options || {};
	
	    this._routes = routes;
	    this._rst = parseTree(routes);
	    this._matcher = matcher(this._rst);
	    this._debug = opts.debug;
	    this.maxRefFollow = opts.maxRefFollow || MAX_REF_FOLLOW;
	    this.maxPaths = opts.maxPaths || MAX_PATHS;
	};
	
	Router.createClass = function(routes) {
	    function C(options) {
	        var opts = options || {};
	        this._debug = opts.debug;
	    }
	
	    C.prototype = new Router(routes);
	    C.prototype.constructor = C;
	
	    return C;
	};
	
	Router.prototype = {
	    /**
	     * Performs the get algorithm on the router.
	     * @param {PathSet[]} paths -
	     * @returns {Observable.<JSONGraphEnvelope>}
	     */
	    get: __webpack_require__(186),
	
	    /**
	     * Takes in a jsonGraph and outputs a Observable.<jsonGraph>.  The set
	     * method will use get until it evaluates the last key of the path inside
	     * of paths.  At that point it will produce an intermediate structure that
	     * matches the path and has the value that is found in the jsonGraph env.
	     *
	     * One of the requirements for interaction with a dataSource is that the
	     * set message must be optimized to the best of the incoming sources
	     * knowledge.
	     *
	     * @param {JSONGraphEnvelope} jsonGraph -
	     * @returns {Observable.<JSONGraphEnvelope>}
	     */
	    set: __webpack_require__(238),
	
	    /**
	     * Invokes a function in the DataSource's JSONGraph object at the path
	     * provided in the callPath argument.  If there are references that are
	     * followed, a get will be performed to get to the call function.
	     *
	     * @param {Path} callPath -
	     * @param {Array.<*>} args -
	     * @param {Array.<PathSet>} refPaths -
	     * @param {Array.<PathSet>} thisPaths -
	     */
	    call: __webpack_require__(243),
	
	    /**
	     * When a route misses on a call, get, or set the unhandledDataSource will
	     * have a chance to fulfill that request.
	     * @param {DataSource} dataSource -
	     */
	    routeUnhandledPathsTo: function routeUnhandledPathsTo(dataSource) {
	        this._unhandled = dataSource;
	    }
	};
	
	Router.ranges = Keys.ranges;
	Router.integers = Keys.integers;
	Router.keys = Keys.keys;
	Router.JSONGraphError = JSONGraphError;
	module.exports = Router;
	
	


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	var prefix = __webpack_require__(137);
	var Keys = {
	    ranges: prefix + 'ranges',
	    integers: prefix + 'integers',
	    keys: prefix + 'keys',
	    named: prefix + 'named',
	    name: prefix + 'name',
	    match: prefix + 'match'
	};
	
	module.exports = Keys;


/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = String.fromCharCode(30);
	


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	var actionWrapper = __webpack_require__(139);
	var pathSyntax = __webpack_require__(149);
	var convertTypes = __webpack_require__(159);
	var prettifyRoute = __webpack_require__(160);
	var errors = __webpack_require__(161);
	var cloneArray = __webpack_require__(162);
	var ROUTE_ID = -3;
	
	module.exports = function parseTree(routes) {
	    var pTree = {};
	    var parseMap = {};
	    routes.forEach(function forEachRoute(route) {
	        // converts the virtual string path to a real path with
	        // extended syntax on.
	        if (typeof route.route === 'string') {
	            route.route = pathSyntax(route.route, true);
	            convertTypes(route);
	        }
	        if (route.get) {
	            route.getId = ++ROUTE_ID;
	        }
	        if (route.set) {
	            route.setId = ++ROUTE_ID;
	        }
	        if (route.call) {
	            route.callId = ++ROUTE_ID;
	        }
	
	        setHashOrThrowError(parseMap, route);
	        buildParseTree(pTree, route, 0, []);
	    });
	    return pTree;
	};
	
	function buildParseTree(node, routeObject, depth) {
	
	    var route = routeObject.route;
	    var get = routeObject.get;
	    var set = routeObject.set;
	    var call = routeObject.call;
	    var el = route[depth];
	
	    el = !isNaN(+el) && +el || el;
	    var isArray = Array.isArray(el);
	    var i = 0;
	
	    do {
	        var value = el;
	        var next;
	        if (isArray) {
	            value = value[i];
	        }
	
	        // There is a ranged token in this location with / without name.
	        // only happens from parsed path-syntax paths.
	        if (typeof value === 'object') {
	            var routeType = value.type;
	            next = decendTreeByRoutedToken(node, routeType, value);
	        }
	
	        // This is just a simple key.  Could be a ranged key.
	        else {
	            next = decendTreeByRoutedToken(node, value);
	
	            // we have to create a falcor-router virtual object
	            // so that the rest of the algorithm can match and coerse
	            // when needed.
	            if (next) {
	                route[depth] = {type: value, named: false};
	            }
	            else {
	                if (!node[value]) {
	                    node[value] = {};
	                }
	                next = node[value];
	            }
	        }
	
	        // Continue to recurse or put get/set.
	        if (depth + 1 === route.length) {
	
	            // Insert match into routeSyntaxTree
	            var matchObject = next[Keys.match] || {};
	            if (!next[Keys.match]) {
	                next[Keys.match] = matchObject;
	            }
	
	            if (get) {
	                matchObject.get = actionWrapper(route, get);
	                matchObject.getId = routeObject.getId;
	            }
	            if (set) {
	                matchObject.set = actionWrapper(route, set);
	                matchObject.setId = routeObject.setId;
	            }
	            if (call) {
	                matchObject.call = actionWrapper(route, call);
	                matchObject.callId = routeObject.callId;
	            }
	        } else {
	            buildParseTree(next, routeObject, depth + 1);
	        }
	
	    } while (isArray && ++i < el.length);
	}
	
	/**
	 * ensure that two routes of the same precedence do not get
	 * set in.
	 */
	function setHashOrThrowError(parseMap, routeObject) {
	    var route = routeObject.route;
	    var get = routeObject.get;
	    var set = routeObject.set;
	    var call = routeObject.call;
	
	    getHashesFromRoute(route).
	        map(function mapHashToString(hash) { return hash.join(','); }).
	        forEach(function forEachRouteHash(hash) {
	            if (get && parseMap[hash + 'get'] ||
	                set && parseMap[hash + 'set'] ||
	                    call && parseMap[hash + 'call']) {
	                throw new Error(errors.routeWithSamePrecedence + ' ' +
	                               prettifyRoute(route));
	            }
	            if (get) {
	                parseMap[hash + 'get'] = true;
	            }
	            if (set) {
	                parseMap[hash + 'set'] = true;
	            }
	            if (call) {
	                parseMap[hash + 'call'] = true;
	            }
	        });
	}
	
	/**
	 * decends the rst and fills in any naming information at the node.
	 * if what is passed in is not a routed token identifier, then the return
	 * value will be null
	 */
	function decendTreeByRoutedToken(node, value, routeToken) {
	    var next = null;
	    switch (value) {
	        case Keys.keys:
	        case Keys.integers:
	        case Keys.ranges:
	            next = node[value];
	            if (!next) {
	                next = node[value] = {};
	            }
	            break;
	        default:
	            break;
	    }
	    if (next && routeToken) {
	        // matches the naming information on the node.
	        next[Keys.named] = routeToken.named;
	        next[Keys.name] = routeToken.name;
	    }
	
	    return next;
	}
	
	/**
	 * creates a hash of the virtual path where integers and ranges
	 * will collide but everything else is unique.
	 */
	function getHashesFromRoute(route, depth, hashes, hash) {
	    /*eslint-disable no-func-assign, no-param-reassign*/
	    depth = depth || 0;
	    hashes = hashes || [];
	    hash = hash || [];
	    /*eslint-enable no-func-assign, no-param-reassign*/
	
	    var routeValue = route[depth];
	    var isArray = Array.isArray(routeValue);
	    var length = isArray && routeValue.length || 0;
	    var idx = 0;
	    var value;
	
	    if (typeof routeValue === 'object' && !isArray) {
	        value = routeValue.type;
	    }
	
	    else if (!isArray) {
	        value = routeValue;
	    }
	
	    do {
	        if (isArray) {
	            value = routeValue[idx];
	        }
	
	        if (value === Keys.integers || value === Keys.ranges) {
	            hash[depth] = '__I__';
	        }
	
	        else if (value === Keys.keys) {
	            hash[depth] ='__K__';
	        }
	
	        else {
	            hash[depth] = value;
	        }
	
	        // recurse down the routed token
	        if (depth + 1 !== route.length) {
	            getHashesFromRoute(route, depth + 1, hashes, hash);
	        }
	
	        // Or just add it to hashes
	        else {
	            hashes.push(cloneArray(hash));
	        }
	    } while (isArray && ++idx < length);
	
	    return hashes;
	}
	


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var convertPathToRoute = __webpack_require__(140);
	var isPathValue = __webpack_require__(147);
	var slice = __webpack_require__(148);
	var isArray = Array.isArray;
	
	/**
	 *   Creates the named variables and coerces it into its
	 * virtual type.
	 *
	 * @param {Array} route - The route that produced this action wrapper
	 * @private
	 */
	function createNamedVariables(route, action) {
	    return function innerCreateNamedVariables(matchedPath) {
	        var convertedArguments;
	        var len = -1;
	        var restOfArgs = slice(arguments, 1);
	        var isJSONObject = !isArray(matchedPath);
	
	        // A set uses a json object
	        if (isJSONObject) {
	            restOfArgs = [];
	            convertedArguments = matchedPath;
	        }
	
	        // Could be an array of pathValues for a set operation.
	        else if (isPathValue(matchedPath[0])) {
	            convertedArguments = [];
	
	            matchedPath.forEach(function(pV) {
	                pV.path = convertPathToRoute(pV.path, route);
	                convertedArguments[++len] = pV;
	            });
	        }
	
	        // else just convert and assign
	        else {
	            convertedArguments =
	                convertPathToRoute(matchedPath, route);
	        }
	        return action.apply(this, [convertedArguments].concat(restOfArgs));
	    };
	}
	module.exports = createNamedVariables;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	// Disable eslint for import statements
	/* eslint-disable max-len */
	var Keys = __webpack_require__(136);
	var convertPathKeyToRange = __webpack_require__(141);
	var convertPathKeyToIntegers = __webpack_require__(144);
	var convertPathKeyToKeys = __webpack_require__(146);
	var isArray = Array.isArray;
	/* eslint-enable max-len */
	
	/**
	 * takes the path that was matched and converts it to the
	 * virtual path.
	 */
	module.exports = function convertPathToRoute(path, route) {
	    var matched = [];
	    // Always use virtual path since path can be longer since
	    // it contains suffixes.
	    for (var i = 0, len = route.length; i < len; ++i) {
	
	        if (route[i].type) {
	            var virt = route[i];
	            switch (virt.type) {
	                case Keys.ranges:
	                    matched[i] =
	                        convertPathKeyToRange(path[i]);
	                    break;
	                case Keys.integers:
	                    matched[i] =
	                        convertPathKeyToIntegers(path[i]);
	                    break;
	                case Keys.keys:
	                    matched[i] =
	                        convertPathKeyToKeys(path[i]);
	                    break;
	                default:
	                    var err = new Error('Unknown route type.');
	                    err.throwToNext = true;
	                    break;
	            }
	            if (virt.named) {
	                matched[virt.name] = matched[matched.length - 1];
	            }
	        }
	
	        // Dealing with specific keys or array of specific keys.
	        // If route has an array at this position, arrayify the
	        // path[i] element.
	        else {
	            if (isArray(route[i]) && !isArray(path[i])) {
	                matched[matched.length] = [path[i]];
	            }
	
	            else {
	                matched[matched.length] = path[i];
	            }
	        }
	    }
	
	    return matched;
	};
	
	


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var convertPathKeyTo = __webpack_require__(142);
	var isNumber = __webpack_require__(143);
	
	function onRange(out, range) {
	    out[out.length] = range;
	}
	
	/**
	 * @param {Number|String} key must be a number
	 */
	function keyReduce(out, key, range) {
	    if (!isNumber(key)) {
	        return range;
	    }
	
	    /* eslint-disable no-param-reassign */
	    key = +key;
	    if (range) {
	        if (key - 1 === range.to) {
	            range.to = key;
	        }
	
	        else if (key + 1 === range.from) {
	            range.from = key;
	        }
	
	        else {
	            range = null;
	        }
	    }
	
	    if (!range) {
	        range = {to: key, from: key};
	        out[out.length] = range;
	    }
	    /* eslint-enable no-param-reassign */
	
	    return range;
	}
	
	module.exports = convertPathKeyTo(onRange, keyReduce);


/***/ },
/* 142 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	module.exports = function convertPathKeyTo(onRange, onKey) {
	    return function converter(keySet) {
	        var isKeySet = typeof keySet === 'object';
	        var out = [];
	
	        // The keySet we determine what type is this keyset.
	        if (isKeySet) {
	            if (isArray(keySet)) {
	                var reducer = null;
	                keySet.forEach(function(key) {
	                    if (typeof key === 'object') {
	                        reducer = onRange(out, key, reducer);
	                    }
	                    else {
	                        reducer = onKey(out, key, reducer);
	                    }
	                });
	            }
	
	            // What passed in is a range.
	            else {
	                onRange(out, keySet);
	            }
	        }
	
	        // simple value for keyset.
	        else {
	            onKey(out, keySet);
	        }
	
	        return out;
	    };
	};


/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Will determine of the argument is a number.
	 *
	 * '1' returns true
	 * 1 returns true
	 * [1] returns false
	 * null returns false
	 * @param {*} x
	 */
	module.exports = function(x) {
	    return String(Number(x)) === String(x) && typeof x !== 'object';
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var convertPathKeyTo = __webpack_require__(142);
	var isNumber = __webpack_require__(143);
	var rangeToArray = __webpack_require__(145);
	
	function onRange(out, range) {
	    var len = out.length - 1;
	    rangeToArray(range).forEach(function(el) {
	        out[++len] = el;
	    });
	}
	
	function onKey(out, key) {
	    if (isNumber(key)) {
	        out[out.length] = key;
	    }
	}
	
	/**
	 * will attempt to get integers from the key
	 * or keySet provided. assumes everything passed in is an integer
	 * or range of integers.
	 */
	module.exports = convertPathKeyTo(onRange, onKey);


/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = function onRange(range) {
	    var out = [];
	    var i = range.from;
	    var to = range.to;
	    var outIdx = out.length;
	    for (; i <= to; ++i, ++outIdx) {
	        out[outIdx] = i;
	    }
	
	    return out;
	};


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var convertPathKeyTo = __webpack_require__(142);
	var rangeToArray = __webpack_require__(145);
	
	function onKey(out, key) {
	    out[out.length] = key;
	}
	
	function onRange(out, range) {
	    var len = out.length - 1;
	    rangeToArray(range).forEach(function(el) {
	        out[++len] = el;
	    });
	}
	
	/**
	 * will attempt to get integers from the key
	 * or keySet provided. assumes everything passed in is an integer
	 * or range of integers.
	 */
	module.exports = convertPathKeyTo(onRange, onKey);
	


/***/ },
/* 147 */
/***/ function(module, exports) {

	module.exports = function(x) {
	    return x.hasOwnProperty('path') && x.hasOwnProperty('value');
	};


/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = function slice(args, index) {
	    var len = args.length;
	    var out = [];
	    var j = 0;
	    var i = index;
	    while (i < len) {
	        out[j] = args[i];
	        ++i;
	        ++j;
	    }
	    return out;
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var Tokenizer = __webpack_require__(150);
	var head = __webpack_require__(152);
	var RoutedTokens = __webpack_require__(158);
	
	var parser = function parser(string, extendedRules) {
	    return head(new Tokenizer(string, extendedRules));
	};
	
	module.exports = parser;
	
	// Constructs the paths from paths / pathValues that have strings.
	// If it does not have a string, just moves the value into the return
	// results.
	parser.fromPathsOrPathValues = function(paths, ext) {
	    if (!paths) {
	        return [];
	    }
	
	    var out = [];
	    for (var i = 0, len = paths.length; i < len; i++) {
	
	        // Is the path a string
	        if (typeof paths[i] === 'string') {
	            out[i] = parser(paths[i], ext);
	        }
	
	        // is the path a path value with a string value.
	        else if (typeof paths[i].path === 'string') {
	            out[i] = {
	                path: parser(paths[i].path, ext), value: paths[i].value
	            };
	        }
	
	        // just copy it over.
	        else {
	            out[i] = paths[i];
	        }
	    }
	
	    return out;
	};
	
	// If the argument is a string, this with convert, else just return
	// the path provided.
	parser.fromPath = function(path, ext) {
	    if (!path) {
	        return [];
	    }
	
	    if (typeof path === 'string') {
	        return parser(path, ext);
	    }
	
	    return path;
	};
	
	// Potential routed tokens.
	parser.RoutedTokens = RoutedTokens;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(151);
	var DOT_SEPARATOR = '.';
	var COMMA_SEPARATOR = ',';
	var OPENING_BRACKET = '[';
	var CLOSING_BRACKET = ']';
	var OPENING_BRACE = '{';
	var CLOSING_BRACE = '}';
	var COLON = ':';
	var ESCAPE = '\\';
	var DOUBLE_OUOTES = '"';
	var SINGE_OUOTES = "'";
	var TAB = "\t";
	var SPACE = " ";
	var LINE_FEED = '\n';
	var CARRIAGE_RETURN = '\r';
	var SPECIAL_CHARACTERS = '\\\'"[]., \t\n\r';
	var EXT_SPECIAL_CHARACTERS = '\\{}\'"[]., :\t\n\r';
	
	var Tokenizer = module.exports = function(string, ext) {
	    this._string = string;
	    this._idx = -1;
	    this._extended = ext;
	    this.parseString = '';
	};
	
	Tokenizer.prototype = {
	    /**
	     * grabs the next token either from the peek operation or generates the
	     * next token.
	     */
	    next: function() {
	        var nextToken = this._nextToken ?
	            this._nextToken : getNext(this._string, this._idx, this._extended);
	
	        this._idx = nextToken.idx;
	        this._nextToken = false;
	        this.parseString += nextToken.token.token;
	
	        return nextToken.token;
	    },
	
	    /**
	     * will peak but not increment the tokenizer
	     */
	    peek: function() {
	        var nextToken = this._nextToken ?
	            this._nextToken : getNext(this._string, this._idx, this._extended);
	        this._nextToken = nextToken;
	
	        return nextToken.token;
	    }
	};
	
	Tokenizer.toNumber = function toNumber(x) {
	    if (!isNaN(+x)) {
	        return +x;
	    }
	    return NaN;
	};
	
	function toOutput(token, type, done) {
	    return {
	        token: token,
	        done: done,
	        type: type
	    };
	}
	
	function getNext(string, idx, ext) {
	    var output = false;
	    var token = '';
	    var specialChars = ext ?
	        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;
	    var done;
	
	    do {
	
	        done = idx + 1 >= string.length;
	        if (done) {
	            break;
	        }
	
	        // we have to peek at the next token
	        var character = string[idx + 1];
	
	        if (character !== undefined &&
	            specialChars.indexOf(character) === -1) {
	
	            token += character;
	            ++idx;
	            continue;
	        }
	
	        // The token to delimiting character transition.
	        else if (token.length) {
	            break;
	        }
	
	        ++idx;
	        var type;
	        switch (character) {
	            case DOT_SEPARATOR:
	                type = TokenTypes.dotSeparator;
	                break;
	            case COMMA_SEPARATOR:
	                type = TokenTypes.commaSeparator;
	                break;
	            case OPENING_BRACKET:
	                type = TokenTypes.openingBracket;
	                break;
	            case CLOSING_BRACKET:
	                type = TokenTypes.closingBracket;
	                break;
	            case OPENING_BRACE:
	                type = TokenTypes.openingBrace;
	                break;
	            case CLOSING_BRACE:
	                type = TokenTypes.closingBrace;
	                break;
	            case TAB:
	            case SPACE:
	            case LINE_FEED:
	            case CARRIAGE_RETURN:
	                type = TokenTypes.space;
	                break;
	            case DOUBLE_OUOTES:
	            case SINGE_OUOTES:
	                type = TokenTypes.quote;
	                break;
	            case ESCAPE:
	                type = TokenTypes.escape;
	                break;
	            case COLON:
	                type = TokenTypes.colon;
	                break;
	            default:
	                type = TokenTypes.unknown;
	                break;
	        }
	        output = toOutput(character, type, false);
	        break;
	    } while (!done);
	
	    if (!output && token.length) {
	        output = toOutput(token, TokenTypes.token, false);
	    }
	
	    if (!output) {
	        output = {done: true};
	    }
	
	    return {
	        token: output,
	        idx: idx
	    };
	}
	
	


/***/ },
/* 151 */
/***/ function(module, exports) {

	var TokenTypes = {
	    token: 'token',
	    dotSeparator: '.',
	    commaSeparator: ',',
	    openingBracket: '[',
	    closingBracket: ']',
	    openingBrace: '{',
	    closingBrace: '}',
	    escape: '\\',
	    space: ' ',
	    colon: ':',
	    quote: 'quote',
	    unknown: 'unknown'
	};
	
	module.exports = TokenTypes;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(151);
	var E = __webpack_require__(153);
	var indexer = __webpack_require__(154);
	
	/**
	 * The top level of the parse tree.  This returns the generated path
	 * from the tokenizer.
	 */
	module.exports = function head(tokenizer) {
	    var token = tokenizer.next();
	    var state = {};
	    var out = [];
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	                var first = +token.token[0];
	                if (!isNaN(first)) {
	                    E.throwError(E.invalidIdentifier, tokenizer);
	                }
	                out[out.length] = token.token;
	                break;
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (out.length === 0) {
	                    E.throwError(E.unexpectedToken, tokenizer);
	                }
	                break;
	
	            // Spaces do nothing.
	            case TokenTypes.space:
	                // NOTE: Spaces at the top level are allowed.
	                // titlesById  .summary is a valid path.
	                break;
	
	
	            // Its time to decend the parse tree.
	            case TokenTypes.openingBracket:
	                indexer(tokenizer, token, state, out);
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	                break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (out.length === 0) {
	        E.throwError(E.invalidPath, tokenizer);
	    }
	
	    return out;
	};
	


/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = {
	    indexer: {
	        nested: 'Indexers cannot be nested.',
	        needQuotes: 'unquoted indexers must be numeric.',
	        empty: 'cannot have empty indexers.',
	        leadingDot: 'Indexers cannot have leading dots.',
	        leadingComma: 'Indexers cannot have leading comma.',
	        requiresComma: 'Indexers require commas between indexer args.',
	        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'
	    },
	    range: {
	        precedingNaN: 'ranges must be preceded by numbers.',
	        suceedingNaN: 'ranges must be suceeded by numbers.'
	    },
	    routed: {
	        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'
	    },
	    quote: {
	        empty: 'cannot have empty quoted keys.',
	        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'
	    },
	    unexpectedToken: 'Unexpected token.',
	    invalidIdentifier: 'Invalid Identifier.',
	    invalidPath: 'Please provide a valid path.',
	    throwError: function(err, tokenizer, token) {
	        if (token) {
	            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;
	        }
	        throw err + ' -- ' + tokenizer.parseString;
	    }
	};
	


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(151);
	var E = __webpack_require__(153);
	var idxE = E.indexer;
	var range = __webpack_require__(155);
	var quote = __webpack_require__(156);
	var routed = __webpack_require__(157);
	
	/**
	 * The indexer is all the logic that happens in between
	 * the '[', opening bracket, and ']' closing bracket.
	 */
	module.exports = function indexer(tokenizer, openingToken, state, out) {
	    var token = tokenizer.next();
	    var done = false;
	    var allowedMaxLength = 1;
	    var routedIndexer = false;
	
	    // State variables
	    state.indexer = [];
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	            case TokenTypes.quote:
	
	                // ensures that token adders are properly delimited.
	                if (state.indexer.length === allowedMaxLength) {
	                    E.throwError(idxE.requiresComma, tokenizer);
	                }
	                break;
	        }
	
	        switch (token.type) {
	            // Extended syntax case
	            case TokenTypes.openingBrace:
	                routedIndexer = true;
	                routed(tokenizer, token, state, out);
	                break;
	
	
	            case TokenTypes.token:
	                var t = +token.token;
	                if (isNaN(t)) {
	                    E.throwError(idxE.needQuotes, tokenizer);
	                }
	                state.indexer[state.indexer.length] = t;
	                break;
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (!state.indexer.length) {
	                    E.throwError(idxE.leadingDot, tokenizer);
	                }
	                range(tokenizer, token, state, out);
	                break;
	
	            // Spaces do nothing.
	            case TokenTypes.space:
	                break;
	
	            case TokenTypes.closingBracket:
	                done = true;
	                break;
	
	
	            // The quotes require their own tree due to what can be in it.
	            case TokenTypes.quote:
	                quote(tokenizer, token, state, out);
	                break;
	
	
	            // Its time to decend the parse tree.
	            case TokenTypes.openingBracket:
	                E.throwError(idxE.nested, tokenizer);
	                break;
	
	            case TokenTypes.commaSeparator:
	                ++allowedMaxLength;
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	                break;
	        }
	
	        // If done, leave loop
	        if (done) {
	            break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (state.indexer.length === 0) {
	        E.throwError(idxE.empty, tokenizer);
	    }
	
	    if (state.indexer.length > 1 && routedIndexer) {
	        E.throwError(idxE.routedTokens, tokenizer);
	    }
	
	    // Remember, if an array of 1, keySets will be generated.
	    if (state.indexer.length === 1) {
	        state.indexer = state.indexer[0];
	    }
	
	    out[out.length] = state.indexer;
	
	    // Clean state.
	    state.indexer = undefined;
	};
	


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var Tokenizer = __webpack_require__(150);
	var TokenTypes = __webpack_require__(151);
	var E = __webpack_require__(153);
	
	/**
	 * The indexer is all the logic that happens in between
	 * the '[', opening bracket, and ']' closing bracket.
	 */
	module.exports = function range(tokenizer, openingToken, state, out) {
	    var token = tokenizer.peek();
	    var dotCount = 1;
	    var done = false;
	    var inclusive = true;
	
	    // Grab the last token off the stack.  Must be an integer.
	    var idx = state.indexer.length - 1;
	    var from = Tokenizer.toNumber(state.indexer[idx]);
	    var to;
	
	    if (isNaN(from)) {
	        E.throwError(E.range.precedingNaN, tokenizer);
	    }
	
	    // Why is number checking so difficult in javascript.
	
	    while (!done && !token.done) {
	
	        switch (token.type) {
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (dotCount === 3) {
	                    E.throwError(E.unexpectedToken, tokenizer);
	                }
	                ++dotCount;
	
	                if (dotCount === 3) {
	                    inclusive = false;
	                }
	                break;
	
	            case TokenTypes.token:
	                // move the tokenizer forward and save to.
	                to = Tokenizer.toNumber(tokenizer.next().token);
	
	                // throw potential error.
	                if (isNaN(to)) {
	                    E.throwError(E.range.suceedingNaN, tokenizer);
	                }
	
	                done = true;
	                break;
	
	            default:
	                done = true;
	                break;
	        }
	
	        // Keep cycling through the tokenizer.  But ranges have to peek
	        // before they go to the next token since there is no 'terminating'
	        // character.
	        if (!done) {
	            tokenizer.next();
	
	            // go to the next token without consuming.
	            token = tokenizer.peek();
	        }
	
	        // break and remove state information.
	        else {
	            break;
	        }
	    }
	
	    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};
	};
	


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(151);
	var E = __webpack_require__(153);
	var quoteE = E.quote;
	
	/**
	 * quote is all the parse tree in between quotes.  This includes the only
	 * escaping logic.
	 *
	 * parse-tree:
	 * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>
	 */
	module.exports = function quote(tokenizer, openingToken, state, out) {
	    var token = tokenizer.next();
	    var innerToken = '';
	    var openingQuote = openingToken.token;
	    var escaping = false;
	    var done = false;
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	            case TokenTypes.space:
	
	            case TokenTypes.dotSeparator:
	            case TokenTypes.commaSeparator:
	
	            case TokenTypes.openingBracket:
	            case TokenTypes.closingBracket:
	            case TokenTypes.openingBrace:
	            case TokenTypes.closingBrace:
	                if (escaping) {
	                    E.throwError(quoteE.illegalEscape, tokenizer);
	                }
	
	                innerToken += token.token;
	                break;
	
	
	            case TokenTypes.quote:
	                // the simple case.  We are escaping
	                if (escaping) {
	                    innerToken += token.token;
	                    escaping = false;
	                }
	
	                // its not a quote that is the opening quote
	                else if (token.token !== openingQuote) {
	                    innerToken += token.token;
	                }
	
	                // last thing left.  Its a quote that is the opening quote
	                // therefore we must produce the inner token of the indexer.
	                else {
	                    done = true;
	                }
	
	                break;
	            case TokenTypes.escape:
	                escaping = true;
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	        }
	
	        // If done, leave loop
	        if (done) {
	            break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (innerToken.length === 0) {
	        E.throwError(quoteE.empty, tokenizer);
	    }
	
	    state.indexer[state.indexer.length] = innerToken;
	};
	


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(151);
	var RoutedTokens = __webpack_require__(158);
	var E = __webpack_require__(153);
	var routedE = E.routed;
	
	/**
	 * The routing logic.
	 *
	 * parse-tree:
	 * <opening-brace><routed-token>(:<token>)<closing-brace>
	 */
	module.exports = function routed(tokenizer, openingToken, state, out) {
	    var routeToken = tokenizer.next();
	    var named = false;
	    var name = '';
	
	    // ensure the routed token is a valid ident.
	    switch (routeToken.token) {
	        case RoutedTokens.integers:
	        case RoutedTokens.ranges:
	        case RoutedTokens.keys:
	            //valid
	            break;
	        default:
	            E.throwError(routedE.invalid, tokenizer);
	            break;
	    }
	
	    // Now its time for colon or ending brace.
	    var next = tokenizer.next();
	
	    // we are parsing a named identifier.
	    if (next.type === TokenTypes.colon) {
	        named = true;
	
	        // Get the token name or a white space character.
	        next = tokenizer.next();
	
	        // Skip over preceeding white space
	        while (next.type === TokenTypes.space) {
	            next = tokenizer.next();
	        }
	
	        if (next.type !== TokenTypes.token) {
	            E.throwError(routedE.invalid, tokenizer);
	        }
	        name = next.token;
	
	        // Move to the closing brace or white space character
	        next = tokenizer.next();
	
	        // Skip over any white space to get to the closing brace
	        while (next.type === TokenTypes.space) {
	            next = tokenizer.next();
	        }
	    }
	
	    // must close with a brace.
	
	    if (next.type === TokenTypes.closingBrace) {
	        var outputToken = {
	            type: routeToken.token,
	            named: named,
	            name: name
	        };
	        state.indexer[state.indexer.length] = outputToken;
	    }
	
	    // closing brace expected
	    else {
	        E.throwError(routedE.invalid, tokenizer);
	    }
	
	};
	


/***/ },
/* 158 */
/***/ function(module, exports) {

	module.exports = {
	    integers: 'integers',
	    ranges: 'ranges',
	    keys: 'keys'
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	module.exports = function convertTypes(virtualPath) {
	    virtualPath.route = virtualPath.route.map(function(key) {
	        if (typeof key === 'object') {
	            switch (key.type) {
	                case 'keys':
	                    key.type = Keys.keys;
	                    break;
	                case 'integers':
	                    key.type = Keys.integers;
	                    break;
	                case 'ranges':
	                    key.type = Keys.ranges;
	                    break;
	                default:
	                    var err = new Error('Unknown route type.');
	                    err.throwToNext = true;
	                    break;
	            }
	        }
	        return key;
	    });
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	
	/**
	 * beautify the virtual path, meaning paths with virtual keys will
	 * not be displayed as a stringified object but instead as a string.
	 *
	 * @param {Array} route -
	 */
	module.exports = function prettifyRoute(route) {
	    var length = 0;
	    var str = [];
	    for (var i = 0, len = route.length; i < len; ++i, ++length) {
	        var value = route[i];
	        if (typeof value === 'object') {
	            value = value.type;
	        }
	
	        if (value === Keys.integers) {
	            str[length] = 'integers';
	        }
	
	        else if (value === Keys.ranges) {
	            str[length] = 'ranges';
	        }
	
	        else if (value === Keys.keys) {
	            str[length] = 'keys';
	        }
	
	        else {
	            if (Array.isArray(value)) {
	                str[length] = JSON.stringify(value);
	            }
	
	            else {
	                str[length] = value;
	            }
	        }
	    }
	
	    return str;
	}


/***/ },
/* 161 */
/***/ function(module, exports) {

	/*eslint-disable*/
	module.exports = {
	    innerReferences: 'References with inner references are not allowed.',
	    unknown: 'Unknown Error',
	    routeWithSamePrecedence: 'Two routes cannot have the same precedence or path.',
	    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'
	};


/***/ },
/* 162 */
/***/ function(module, exports) {

	function cloneArray(arr, index) {
	    var a = [];
	    var len = arr.length;
	    for (var i = index || 0; i < len; i++) {
	        a[i] = arr[i];
	    }
	    return a;
	}
	
	module.exports = cloneArray;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	var Precedence = __webpack_require__(164);
	var cloneArray = __webpack_require__(162);
	var specificMatcher = __webpack_require__(165);
	var pluckIntegers = __webpack_require__(182);
	var pathUtils = __webpack_require__(166);
	var collapse = pathUtils.collapse;
	var isRoutedToken = __webpack_require__(183);
	var CallNotFoundError = __webpack_require__(184);
	
	var intTypes = [{
	        type: Keys.ranges,
	        precedence: Precedence.ranges
	    }, {
	        type: Keys.integers,
	        precedence: Precedence.integers
	    }];
	var keyTypes = [{
	        type: Keys.keys,
	        precedence: Precedence.keys
	    }];
	var allTypes = intTypes.concat(keyTypes);
	var get = 'get';
	var set = 'set';
	var call = 'call';
	
	/**
	 * Creates a custom matching function for the match tree.
	 * @param Object rst The routed syntax tree
	 * @param String method the method to call at the end of the path.
	 * @return {matched: Array.<Match>, missingPaths: Array.<Array>}
	 */
	module.exports = function matcher(rst) {
	
	    /**
	     * This is where the matching is done.  Will recursively
	     * match the paths until it has found all the matchable
	     * functions.
	     * @param {[]} paths
	     */
	    return function innerMatcher(method, paths) {
	        var matched = [];
	        var missing = [];
	        match(rst, paths, method, matched, missing);
	
	        // We are at the end of the path but there is no match and its a
	        // call.  Therefore we are going to throw an informative error.
	        if (method === call && matched.length === 0) {
	            var err = new CallNotFoundError();
	            err.throwToNext = true;
	
	            throw err;
	        }
	
	        // Reduce into groups multiple matched routes into route sets where
	        // each match matches the same route endpoint.  From here we can reduce
	        // the matched paths into the most optimal pathSet with collapse.
	        var reducedMatched = matched.reduce(function(acc, matchedRoute) {
	            if (!acc[matchedRoute.id]) {
	                acc[matchedRoute.id] = [];
	            }
	            acc[matchedRoute.id].push(matchedRoute);
	
	            return acc;
	        }, {});
	
	        var collapsedMatched = [];
	
	        // For every set of matched routes, collapse and reduce its matched set
	        // down to the minimal amount of collapsed sets.
	        Object.
	            keys(reducedMatched).
	            forEach(function(k) {
	                var reducedMatch = reducedMatched[k];
	
	                // If the reduced match is of length one then there is no
	                // need to perform collapsing, as there is nothing to collapse
	                // over.
	                if (reducedMatch.length === 1) {
	                    collapsedMatched.push(reducedMatch[0]);
	                    return;
	                }
	
	                // Since there are more than 1 routes, we need to see if
	                // they can collapse and alter the amount of arrays.
	                var collapsedResults =
	                        collapse(
	                            reducedMatch.
	                                map(function(x) {
	                                    return x.requested;
	                                }));
	
	                // For every collapsed result we use the previously match result
	                // and update its requested and virtual path.  Then add that
	                // match to the collapsedMatched set.
	                collapsedResults.forEach(function(path, i) {
	                    var collapsedMatch = reducedMatch[i];
	                    var reducedVirtualPath = collapsedMatch.virtual;
	                    path.forEach(function(atom, index) {
	
	                        // If its not a routed atom then wholesale replace
	                        if (!isRoutedToken(reducedVirtualPath[index])) {
	                            reducedVirtualPath[index] = atom;
	                        }
	                    });
	                    collapsedMatch.requested = path;
	                    collapsedMatched.push(reducedMatch[i]);
	                });
	            });
	        return collapsedMatched;
	    };
	};
	
	function match(
	        curr, path, method, matchedFunctions,
	        missingPaths, depth, requested, virtual, precedence) {
	
	    // Nothing left to match
	    if (!curr) {
	        return;
	    }
	
	    /* eslint-disable no-param-reassign */
	    depth = depth || 0;
	    requested = requested || [];
	    virtual = virtual || [];
	    precedence = precedence || [];
	    matchedFunctions = matchedFunctions || [];
	    /* eslint-disable no-param-reassign */
	
	    // At this point in the traversal we have hit a matching function.
	    // Its time to terminate.
	    // Get: simple method matching
	    // Set/Call: The method is unique.  If the path is not complete,
	    // meaning the depth is equivalent to the length,
	    // then we match a 'get' method, else we match a 'set' or 'call' method.
	    var atEndOfPath = path.length === depth;
	    var isSet = method === set;
	    var isCall = method === call;
	    var methodToUse = method;
	    if ((isCall || isSet) && !atEndOfPath) {
	        methodToUse = get;
	    }
	
	    // Stores the matched result if found along or at the end of
	    // the path.  If we are doing a set and there is no set handler
	    // but there is a get handler, then we need to use the get
	    // handler.  This is so that the current value that is in the
	    // clients cache does not get materialized away.
	    var currentMatch = curr[Keys.match];
	
	    // From https://github.com/Netflix/falcor-router/issues/76
	    // Set: When there is no set hander then we should default to running
	    // the get handler so that we do not destroy the client local values.
	    if (currentMatch && isSet && !currentMatch[set]) {
	        methodToUse = get;
	    }
	
	    // Check to see if we have
	    if (currentMatch && currentMatch[methodToUse]) {
	        matchedFunctions[matchedFunctions.length] = {
	
	            // Used for collapsing paths that use routes with multiple
	            // string indexers.
	            id: currentMatch[methodToUse + 'Id'],
	            requested: cloneArray(requested),
	
	            action: currentMatch[methodToUse],
	            authorize: currentMatch.authorize,
	            virtual: cloneArray(virtual),
	            precedence: +(precedence.join('')),
	            suffix: path.slice(depth),
	            isSet: atEndOfPath && isSet,
	            isCall: atEndOfPath && isCall
	        };
	    }
	
	    // If the depth has reached the end then we need to stop recursing.  This
	    // can cause odd side effects with matching against {keys} as the last
	    // argument when a path has been exhausted (undefined is still a key value).
	    //
	    // Example:
	    // route1: [{keys}]
	    // route2: [{keys}][{keys}]
	    //
	    // path: ['('].
	    //
	    // This will match route1 and 2 since we do not bail out on length and there
	    // is a {keys} matcher which will match "undefined" value.
	    if (depth === path.length) {
	        return;
	    }
	
	    var keySet = path[depth];
	    var i, len, key, next;
	
	    // -------------------------------------------
	    // Specific key matcher.
	    // -------------------------------------------
	    var specificKeys = specificMatcher(keySet, curr);
	    for (i = 0, len = specificKeys.length; i < len; ++i) {
	        key = specificKeys[i];
	        virtual[depth] = key;
	        requested[depth] = key;
	        precedence[depth] = Precedence.specific;
	
	        // Its time to recurse
	        match(
	            curr[specificKeys[i]],
	            path, method, matchedFunctions,
	            missingPaths, depth + 1,
	            requested, virtual, precedence);
	
	        // Removes the virtual, requested, and precedence info
	        virtual.length = depth;
	        requested.length = depth;
	        precedence.length = depth;
	    }
	
	    var ints = pluckIntegers(keySet);
	    var keys = keySet;
	    var intsLength = ints.length;
	
	    // -------------------------------------------
	    // ints, ranges, and keys matcher.
	    // -------------------------------------------
	    allTypes.
	        filter(function(typeAndPrecedence) {
	            var type = typeAndPrecedence.type;
	            // one extra move required for int types
	            if (type === Keys.integers || type === Keys.ranges) {
	                return curr[type] && intsLength;
	            }
	            return curr[type];
	        }).
	        forEach(function(typeAndPrecedence) {
	            var type = typeAndPrecedence.type;
	            var prec = typeAndPrecedence.precedence;
	            next = curr[type];
	
	            virtual[depth] = {
	                type: type,
	                named: next[Keys.named],
	                name: next[Keys.name]
	            };
	
	            // The requested set of info needs to be set either
	            // as ints, if int matchers or keys
	            if (type === Keys.integers || type === Keys.ranges) {
	                requested[depth] = ints;
	            } else {
	                requested[depth] = keys;
	            }
	
	            precedence[depth] = prec;
	
	            // Continue the matching algo.
	            match(
	                next,
	                path, method, matchedFunctions,
	                missingPaths, depth + 1,
	                requested, virtual, precedence);
	
	            // removes the added keys
	            virtual.length = depth;
	            requested.length = depth;
	            precedence.length = depth;
	        });
	}


/***/ },
/* 164 */
/***/ function(module, exports) {

	var Precedence = {
	    specific: 4,
	    ranges: 2,
	    integers: 2,
	    keys: 1
	};
	module.exports = Precedence;
	


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(166).iterateKeySet;
	
	module.exports = function specificMatcher(keySet, currentNode) {
	    // --------------------------------------
	    // Specific key
	    // --------------------------------------
	    var iteratorNote = {};
	    var nexts = [];
	
	    var key = iterateKeySet(keySet, iteratorNote);
	    do {
	
	        if (currentNode[key]) {
	            nexts[nexts.length] = key;
	        }
	
	        if (!iteratorNote.done) {
	            key = iterateKeySet(keySet, iteratorNote);
	        }
	    } while (!iteratorNote.done);
	
	    return nexts;
	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    iterateKeySet: __webpack_require__(167),
	    toTree: __webpack_require__(168),
	    toTreeWithUnion: __webpack_require__(169),
	    pathsComplementFromTree: __webpack_require__(170),
	    pathsComplementFromLengthTree: __webpack_require__(172),
	    hasIntersection: __webpack_require__(171),
	    toPaths: __webpack_require__(173),
	    collapse: __webpack_require__(174),
	    optimizePathSets: __webpack_require__(175),
	    pathCount: __webpack_require__(181)
	};


/***/ },
/* 167 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	
	/**
	 * Takes in a keySet and a note attempts to iterate over it.
	 * If the value is a primitive, the key will be returned and the note will
	 * be marked done
	 * If the value is an object, then each value of the range will be returned
	 * and when finished the note will be marked done.
	 * If the value is an array, each value will be iterated over, if any of the
	 * inner values are ranges, those will be iterated over.  When fully done,
	 * the note will be marked done.
	 *
	 * @param {Object|Array|String|Number} keySet -
	 * @param {Object} note - The non filled note
	 * @returns {String|Number|undefined} - The current iteration value.
	 * If undefined, then the keySet is empty
	 * @public
	 */
	module.exports = function iterateKeySet(keySet, note) {
	    if (note.isArray === undefined) {
	        initializeNote(keySet, note);
	    }
	
	    // Array iteration
	    if (note.isArray) {
	        var nextValue;
	
	        // Cycle through the array and pluck out the next value.
	        do {
	            if (note.loaded && note.rangeOffset > note.to) {
	                ++note.arrayOffset;
	                note.loaded = false;
	            }
	
	            var idx = note.arrayOffset, length = keySet.length;
	            if (idx >= length) {
	                note.done = true;
	                break;
	            }
	
	            var el = keySet[note.arrayOffset];
	            var type = typeof el;
	
	            // Inner range iteration.
	            if (type === 'object') {
	                if (!note.loaded) {
	                    initializeRange(el, note);
	                }
	
	                // Empty to/from
	                if (note.empty) {
	                    continue;
	                }
	
	                nextValue = note.rangeOffset++;
	            }
	
	            // Primitive iteration in array.
	            else {
	                ++note.arrayOffset;
	                nextValue = el;
	            }
	        } while (nextValue === undefined);
	
	        return nextValue;
	    }
	
	    // Range iteration
	    else if (note.isObject) {
	        if (!note.loaded) {
	            initializeRange(keySet, note);
	        }
	        if (note.rangeOffset > note.to) {
	            note.done = true;
	            return undefined;
	        }
	
	        return note.rangeOffset++;
	    }
	
	    // Primitive value
	    else {
	        note.done = true;
	        return keySet;
	    }
	};
	
	function initializeRange(key, memo) {
	    var from = memo.from = key.from || 0;
	    var to = memo.to = key.to ||
	        (typeof key.length === 'number' &&
	        memo.from + key.length - 1 || 0);
	    memo.rangeOffset = memo.from;
	    memo.loaded = true;
	    if (from > to) {
	        memo.empty = true;
	    }
	}
	
	function initializeNote(key, note) {
	    note.done = false;
	    var isObject = note.isObject = !!(key && typeof key === 'object');
	    note.isArray = isObject && isArray(key);
	    note.arrayOffset = 0;
	}


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(167);
	var isArray = Array.isArray;
	
	/**
	 * @param {Array} paths -
	 * @returns {Object} -
	 */
	module.exports = function toTree(paths) {
	    return paths.reduce(function(acc, path) {
	        innerToTree(acc, path, 0);
	        return acc;
	    }, {});
	};
	
	function innerToTree(seed, path, depth) {
	
	    var keySet = path[depth];
	    var iteratorNote = {};
	    var key;
	    var nextDepth = depth + 1;
	
	    key = iterateKeySet(keySet, iteratorNote);
	
	    do {
	
	        var next = seed[key];
	        if (!next) {
	            if (nextDepth === path.length) {
	                seed[key] = null;
	            } else {
	                next = seed[key] = {};
	            }
	        }
	
	        if (nextDepth < path.length) {
	            innerToTree(next, path, nextDepth);
	        }
	
	        if (!iteratorNote.done) {
	            key = iterateKeySet(keySet, iteratorNote);
	        }
	    } while (!iteratorNote.done);
	}
	


/***/ },
/* 169 */
/***/ function(module, exports) {



/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var hasIntersection = __webpack_require__(171);
	
	/**
	 * Compares the paths passed in with the tree.  Any of the paths that are in
	 * the tree will be stripped from the paths.
	 *
	 * **Does not mutate** the incoming paths object.
	 * **Proper subset** only matching.
	 *
	 * @param {Array} paths - A list of paths (complex or simple) to strip the
	 * intersection
	 * @param {Object} tree -
	 * @public
	 */
	module.exports = function pathsComplementFromTree(paths, tree) {
	    var out = [];
	    var outLength = -1;
	
	    for (var i = 0, len = paths.length; i < len; ++i) {
	        // If this does not intersect then add it to the output.
	        if (!hasIntersection(tree, paths[i], 0)) {
	            out[++outLength] = paths[i];
	        }
	    }
	    return out;
	};
	


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(167);
	
	/**
	 * Tests to see if the intersection should be stripped from the
	 * total paths.  The only way this happens currently is if the entirety
	 * of the path is contained in the tree.
	 * @private
	 */
	module.exports = function hasIntersection(tree, path, depth) {
	    var current = tree;
	    var intersects = true;
	
	    // Continue iteratively going down a path until a complex key is
	    // encountered, then recurse.
	    for (;intersects && depth < path.length; ++depth) {
	        var key = path[depth];
	        var keyType = typeof key;
	
	        // We have to iterate key set
	        if (key && keyType === 'object') {
	            var note = {};
	            var innerKey = iterateKeySet(key, note);
	            var nextDepth = depth + 1;
	
	            // Loop through the innerKeys setting the intersects flag
	            // to each result.  Break out on false.
	            do {
	                var next = current[innerKey];
	                intersects = next !== undefined;
	
	                if (intersects) {
	                    intersects = hasIntersection(next, path, nextDepth);
	                }
	                innerKey = iterateKeySet(key, note);
	            } while (intersects && !note.done);
	
	            // Since we recursed, we shall not pass any further!
	            break;
	        }
	
	        // Its a simple key, just move forward with the testing.
	        current = current[key];
	        intersects = current !== undefined;
	    }
	
	    return intersects;
	};


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var hasIntersection = __webpack_require__(171);
	
	/**
	 * Compares the paths passed in with the tree.  Any of the paths that are in
	 * the tree will be stripped from the paths.
	 *
	 * **Does not mutate** the incoming paths object.
	 * **Proper subset** only matching.
	 *
	 * @param {Array} paths - A list of paths (complex or simple) to strip the
	 * intersection
	 * @param {Object} tree -
	 * @public
	 */
	module.exports = function pathsComplementFromLengthTree(paths, tree) {
	    var out = [];
	    var outLength = -1;
	
	    for (var i = 0, len = paths.length; i < len; ++i) {
	        // If this does not intersect then add it to the output.
	        var path = paths[i];
	        if (!hasIntersection(tree[path.length], path, 0)) {
	            out[++outLength] = path;
	        }
	    }
	    return out;
	};
	


/***/ },
/* 173 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	var typeOfObject = "object";
	
	/* jshint forin: false */
	module.exports = function toPaths(lengths) {
	    var pathmap;
	    var allPaths = [];
	    var allPathsLength = 0;
	    for (var length in lengths) {
	        if (isNumber(length) && isObject(pathmap = lengths[length])) {
	            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;
	            var pathsIndex = -1;
	            var pathsCount = paths.length;
	            while (++pathsIndex < pathsCount) {
	                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);
	            }
	        }
	    }
	    return allPaths;
	};
	
	function isObject(value) {
	    return value !== null && typeof value === typeOfObject;
	}
	
	function collapsePathMap(pathmap, depth, length) {
	
	    var key;
	    var code = getHashCode(String(depth));
	    var subs = Object.create(null);
	
	    var codes = [];
	    var codesIndex = -1;
	    var codesCount = 0;
	
	    var pathsets = [];
	    var pathsetsCount = 0;
	
	    var subPath, subCode,
	        subKeys, subKeysIndex, subKeysCount,
	        subSets, subSetsIndex, subSetsCount,
	        pathset, pathsetIndex, pathsetCount,
	        firstSubKey, pathsetClone;
	
	    subKeys = [];
	    subKeysIndex = -1;
	
	    if (depth < length - 1) {
	
	        subKeysCount = getSortedKeys(pathmap, subKeys);
	
	        while (++subKeysIndex < subKeysCount) {
	            key = subKeys[subKeysIndex];
	            subPath = collapsePathMap(pathmap[key], depth + 1, length);
	            subCode = subPath.code;
	            if(subs[subCode]) {
	                subPath = subs[subCode];
	            } else {
	                codes[codesCount++] = subCode;
	                subPath = subs[subCode] = {
	                    keys: [],
	                    sets: subPath.sets
	                };
	            }
	            code = getHashCode(code + key + subCode);
	
	            isNumber(key) &&
	                subPath.keys.push(parseInt(key, 10)) ||
	                subPath.keys.push(key);
	        }
	
	        while(++codesIndex < codesCount) {
	
	            key = codes[codesIndex];
	            subPath = subs[key];
	            subKeys = subPath.keys;
	            subKeysCount = subKeys.length;
	
	            if (subKeysCount > 0) {
	
	                subSets = subPath.sets;
	                subSetsIndex = -1;
	                subSetsCount = subSets.length;
	                firstSubKey = subKeys[0];
	
	                while (++subSetsIndex < subSetsCount) {
	
	                    pathset = subSets[subSetsIndex];
	                    pathsetIndex = -1;
	                    pathsetCount = pathset.length;
	                    pathsetClone = new Array(pathsetCount + 1);
	                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;
	
	                    while (++pathsetIndex < pathsetCount) {
	                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];
	                    }
	
	                    pathsets[pathsetsCount++] = pathsetClone;
	                }
	            }
	        }
	    } else {
	        subKeysCount = getSortedKeys(pathmap, subKeys);
	        if (subKeysCount > 1) {
	            pathsets[pathsetsCount++] = [subKeys];
	        } else {
	            pathsets[pathsetsCount++] = subKeys;
	        }
	        while (++subKeysIndex < subKeysCount) {
	            code = getHashCode(code + subKeys[subKeysIndex]);
	        }
	    }
	
	    return {
	        code: code,
	        sets: pathsets
	    };
	}
	
	function collapsePathSetIndexes(pathset) {
	
	    var keysetIndex = -1;
	    var keysetCount = pathset.length;
	
	    while (++keysetIndex < keysetCount) {
	        var keyset = pathset[keysetIndex];
	        if (isArray(keyset)) {
	            pathset[keysetIndex] = collapseIndex(keyset);
	        }
	    }
	
	    return pathset;
	}
	
	/**
	 * Collapse range indexers, e.g. when there is a continuous
	 * range in an array, turn it into an object instead:
	 *
	 * [1,2,3,4,5,6] => {"from":1, "to":6}
	 *
	 * @private
	 */
	function collapseIndex(keyset) {
	
	    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?
	    // var hash = {};
	    var keyIndex = -1;
	    var keyCount = keyset.length - 1;
	    var isSparseRange = keyCount > 0;
	
	    while (++keyIndex <= keyCount) {
	
	        var key = keyset[keyIndex];
	
	        if (!isNumber(key) /* || hash[key] === true*/ ) {
	            isSparseRange = false;
	            break;
	        }
	        // hash[key] = true;
	        // Cast number indexes to integers.
	        keyset[keyIndex] = parseInt(key, 10);
	    }
	
	    if (isSparseRange === true) {
	
	        keyset.sort(sortListAscending);
	
	        var from = keyset[0];
	        var to = keyset[keyCount];
	
	        // If we re-introduce deduped integer indexers, change this comparson to "===".
	        if (to - from <= keyCount) {
	            return {
	                from: from,
	                to: to
	            };
	        }
	    }
	
	    return keyset;
	}
	
	function sortListAscending(a, b) {
	    return a - b;
	}
	
	/* jshint forin: false */
	function getSortedKeys(map, keys, sort) {
	    var len = 0;
	    for (var key in map) {
	        keys[len++] = key;
	    }
	    if (len > 1) {
	        keys.sort(sort);
	    }
	    return len;
	}
	
	function getHashCode(key) {
	    var code = 5381;
	    var index = -1;
	    var count = key.length;
	    while (++index < count) {
	        code = (code << 5) + code + key.charCodeAt(index);
	    }
	    return String(code);
	}
	
	/**
	 * Return true if argument is a number or can be cast to a number
	 * @private
	 */
	function isNumber(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var toPaths = __webpack_require__(173);
	var toTree = __webpack_require__(168);
	
	module.exports = function collapse(paths) {
	    var collapseMap = paths.
	        reduce(function(acc, path) {
	            var len = path.length;
	            if (!acc[len]) {
	                acc[len] = [];
	            }
	            acc[len].push(path);
	            return acc;
	        }, {});
	
	    Object.
	        keys(collapseMap).
	        forEach(function(collapseKey) {
	            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);
	        });
	
	    return toPaths(collapseMap);
	};


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(167);
	var cloneArray = __webpack_require__(176);
	var catAndSlice = __webpack_require__(177);
	var $types = __webpack_require__(178);
	var $ref = $types.$ref;
	var followReference = __webpack_require__(179);
	
	/**
	 * The fastest possible optimize of paths.
	 *
	 * What it does:
	 * - Any atom short-circuit / found value will be removed from the path.
	 * - All paths will be exploded which means that collapse will need to be
	 *   ran afterwords.
	 * - Any missing path will be optimized as much as possible.
	 */
	module.exports = function optimizePathSets(cache, paths, maxRefFollow) {
	    var optimized = [];
	    paths.forEach(function(p) {
	        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow);
	    });
	
	    return optimized;
	};
	
	
	/**
	 * optimizes one pathSet at a time.
	 */
	function optimizePathSet(cache, cacheRoot, pathSet,
	                         depth, out, optimizedPath, maxRefFollow) {
	
	    // at missing, report optimized path.
	    if (cache === undefined) {
	        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);
	        return;
	    }
	
	    // all other sentinels are short circuited.
	    // Or we found a primitive (which includes null)
	    if (cache === null || (cache.$type && cache.$type !== $ref) ||
	            (typeof cache !== 'object')) {
	        return;
	    }
	
	    // If the reference is the last item in the path then do not
	    // continue to search it.
	    if (cache.$type === $ref && depth === pathSet.length) {
	        return;
	    }
	
	    var keySet = pathSet[depth];
	    var isKeySet = typeof keySet === 'object';
	    var nextDepth = depth + 1;
	    var iteratorNote = false;
	    var key = keySet;
	    if (isKeySet) {
	        iteratorNote = {};
	        key = iterateKeySet(keySet, iteratorNote);
	    }
	    var next, nextOptimized;
	    do {
	        next = cache[key];
	        var optimizedPathLength = optimizedPath.length;
	        if (key !== null) {
	            optimizedPath[optimizedPathLength] = key;
	        }
	
	        if (next && next.$type === $ref && nextDepth < pathSet.length) {
	            var refResults =
	                followReference(cacheRoot, next.value, maxRefFollow);
	            next = refResults[0];
	
	            // must clone to avoid the mutation from above destroying the cache.
	            nextOptimized = cloneArray(refResults[1]);
	        } else {
	            nextOptimized = optimizedPath;
	        }
	
	        optimizePathSet(next, cacheRoot, pathSet, nextDepth,
	                        out, nextOptimized, maxRefFollow);
	        optimizedPath.length = optimizedPathLength;
	
	        if (iteratorNote && !iteratorNote.done) {
	            key = iterateKeySet(keySet, iteratorNote);
	        }
	    } while (iteratorNote && !iteratorNote.done);
	}
	
	


/***/ },
/* 176 */
/***/ function(module, exports) {

	function cloneArray(arr, index) {
	    var a = [];
	    var len = arr.length;
	    for (var i = index || 0; i < len; i++) {
	        a[i] = arr[i];
	    }
	    return a;
	}
	
	module.exports = cloneArray;
	


/***/ },
/* 177 */
/***/ function(module, exports) {

	module.exports = function catAndSlice(a, b, slice) {
	    var next = [], i, j, len;
	    for (i = 0, len = a.length; i < len; ++i) {
	        next[i] = a[i];
	    }
	
	    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {
	        next[i] = b[j];
	    }
	
	    return next;
	};
	


/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = {
	    $ref: 'ref',
	    $atom: 'atom',
	    $error: 'error'
	};
	


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var cloneArray = __webpack_require__(176);
	var $ref = __webpack_require__(178).$ref;
	var errors = __webpack_require__(180);
	
	/**
	 * performs the simplified cache reference follow.  This
	 * differs from get as there is just following and reporting,
	 * not much else.
	 *
	 * @param {Object} cacheRoot
	 * @param {Array} ref
	 */
	module.exports = function followReference(cacheRoot, ref, maxRefFollow) {
	    var current = cacheRoot;
	    var refPath = ref;
	    var depth = -1;
	    var length = refPath.length;
	    var key, next, type;
	    var referenceCount = 0;
	
	    while (++depth < length) {
	        key = refPath[depth];
	        next = current[key];
	        type = next && next.$type;
	
	        if (!next || type && type !== $ref) {
	            current = next;
	            break;
	        }
	
	        // Show stopper exception.  This route is malformed.
	        if (type && type === $ref && depth + 1 < length) {
	            var err = new Error(errors.innerReferences);
	            err.throwToNext = true;
	            throw err;
	        }
	
	        // potentially follow reference
	        if (depth + 1 === length) {
	            if (type === $ref) {
	                depth = -1;
	                refPath = next.value;
	                length = refPath.length;
	                next = cacheRoot;
	                referenceCount++;
	            }
	
	            if (referenceCount > maxRefFollow) {
	                throw new Error(errors.circularReference);
	            }
	        }
	        current = next;
	    }
	
	    return [current, cloneArray(refPath)];
	};
	


/***/ },
/* 180 */
/***/ function(module, exports) {

	/*eslint-disable*/
	module.exports = {
	    innerReferences: 'References with inner references are not allowed.',
	    circularReference: 'There appears to be a circular reference, maximum reference following exceeded.'
	};
	


/***/ },
/* 181 */
/***/ function(module, exports) {

	"use strict";
	
	/**
	 * Helper for getPathCount. Used to determine the size of a key or range.
	 * @function
	 * @param {Object} rangeOrKey
	 * @return The size of the key or range passed in.
	 */
	function getRangeOrKeySize(rangeOrKey) {
	    if (rangeOrKey == null) {
	        return 1;
	    } else if (Array.isArray(rangeOrKey)) {
	        throw new Error("Unexpected Array found in keySet: " + JSON.stringify(rangeOrKey));
	    } else if (typeof rangeOrKey === "object") {
	        return getRangeSize(rangeOrKey);
	    } else {
	        return 1;
	    }
	}
	
	/**
	 * Returns the size (number of items) in a Range,
	 * @function
	 * @param {Object} range The Range with both "from" and "to", or just "to"
	 * @return The number of items in the range.
	 */
	function getRangeSize(range) {
	
	    var to = range.to;
	    var length = range.length;
	
	    if (to != null) {
	        if (isNaN(to) || parseInt(to, 10) !== to) {
	            throw new Error("Invalid range, 'to' is not an integer: " + JSON.stringify(range));
	        }
	        var from = range.from || 0;
	        if (isNaN(from) || parseInt(from, 10) !== from) {
	            throw new Error("Invalid range, 'from' is not an integer: " + JSON.stringify(range));
	        }
	        if (from <= to) {
	            return (to - from) + 1;
	        } else {
	            return 0;
	        }
	    } else if (length != null) {
	        if (isNaN(length) || parseInt(length, 10) !== length) {
	            throw new Error("Invalid range, 'length' is not an integer: " + JSON.stringify(range));
	        } else {
	            return length;
	        }
	    } else {
	        throw new Error("Invalid range, expected 'to' or 'length': " + JSON.stringify(range));
	    }
	}
	
	/**
	 * Returns a count of the number of paths this pathset
	 * represents.
	 *
	 * For example, ["foo", {"from":0, "to":10}, "bar"],
	 * would represent 11 paths (0 to 10, inclusive), and
	 * ["foo, ["baz", "boo"], "bar"] would represent 2 paths.
	 *
	 * @function
	 * @param {Object[]} pathSet the path set.
	 *
	 * @return The number of paths this represents
	 */
	function getPathCount(pathSet) {
	    if (pathSet.length === 0) {
	        throw new Error("All paths must have length larger than zero.");
	    }
	
	    var numPaths = 1;
	
	    for (var i = 0; i < pathSet.length; i++) {
	        var segment = pathSet[i];
	
	        if (Array.isArray(segment)) {
	
	            var numKeys = 0;
	
	            for (var j = 0; j < segment.length; j++) {
	                var keySet = segment[j];
	
	                numKeys += getRangeOrKeySize(keySet);
	            }
	
	            numPaths *= numKeys;
	
	        } else {
	            numPaths *= getRangeOrKeySize(segment);
	        }
	    }
	
	    return numPaths;
	}
	
	
	module.exports = getPathCount;


/***/ },
/* 182 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	/**
	 * plucks any integers from the path key.  Makes no effort
	 * to convert the key into any specific format.
	 */
	module.exports = function pluckIntegers(keySet) {
	    var ints = [];
	
	    if (typeof keySet === 'object') {
	        if (isArray(keySet)) {
	            keySet.forEach(function(key) {
	                // Range case
	                if (typeof key === 'object') {
	                    ints[ints.length] = key;
	                }
	
	                else if (!isNaN(+key)) {
	                    ints[ints.length] = +key;
	                }
	            });
	        }
	        // Range case
	        else {
	            ints[ints.length] = keySet;
	        }
	    }
	
	    else if (!isNaN(+keySet)) {
	        ints[ints.length] = +keySet;
	    }
	
	    return ints;
	};


/***/ },
/* 183 */
/***/ function(module, exports) {

	/**
	 * Determines if the object is a routed token by hasOwnProperty
	 * of type and named
	 */
	module.exports = function isRoutedToken(obj) {
	    return obj.hasOwnProperty('type') && obj.hasOwnProperty('named');
	};


/***/ },
/* 184 */
/***/ function(module, exports) {

	var MESSAGE = 'function does not exist.';
	var CallNotFoundError = module.exports = function CallNotFoundError() {
	    this.message = MESSAGE;
	    this.stack = (new Error()).stack;
	};
	
	CallNotFoundError.prototype = new Error();
	


/***/ },
/* 185 */
/***/ function(module, exports) {

	var JSONGraphError = module.exports = function JSONGraphError(typeValue) {
	    this.typeValue = typeValue;
	};
	JSONGraphError.prototype = new Error();
	


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var runGetAction = __webpack_require__(187);
	var get = 'get';
	var recurseMatchAndExecute = __webpack_require__(215);
	var normalizePathSets = __webpack_require__(233);
	var materialize = __webpack_require__(235);
	var Observable = __webpack_require__(189).Observable;
	var mCGRI = __webpack_require__(228);
	var MaxPathsExceededError = __webpack_require__(236);
	var getPathsCount = __webpack_require__(237);
	
	/**
	 * The router get function
	 */
	module.exports = function routerGet(paths) {
	
	    var router = this;
	
	    return Observable.defer(function() {
	
	        var jsongCache = {};
	        var action = runGetAction(router, jsongCache);
	        var normPS = normalizePathSets(paths);
	
	        if (getPathsCount(normPS) > router.maxPaths) {
	            throw new MaxPathsExceededError();
	        }
	
	        return recurseMatchAndExecute(router._matcher, action, normPS,
	                                      get, router, jsongCache).
	
	            // Turn it(jsongGraph, invalidations, missing, etc.) into a
	            // jsonGraph envelope
	            flatMap(function flatMapAfterRouterGet(details) {
	                var out = {
	                    jsonGraph: details.jsonGraph
	                };
	
	
	                // If the unhandledPaths are present then we need to
	                // call the backup method for generating materialized.
	                if (details.unhandledPaths.length && router._unhandled) {
	                    var unhandledPaths = details.unhandledPaths;
	
	                    // The 3rd argument is the beginning of the actions
	                    // arguments, which for get is the same as the 
	                    // unhandledPaths.
	                    return router._unhandled.
	                        get(unhandledPaths).
	
	                        // Merge the solution back into the overall message.
	                        map(function(jsonGraphFragment) {
	                            mCGRI(out.jsonGraph, [{
	                                jsonGraph: jsonGraphFragment.jsonGraph,
	                                paths: unhandledPaths
	                            }]);
	                            return out;
	                        }).
	                        defaultIfEmpty(out);
	                }
	
	                return Observable.return(out);
	            }).
	
	            // We will continue to materialize over the whole jsonGraph message.
	            // This makes sense if you think about pathValues and an API that if
	            // ask for a range of 10 and only 8 were returned, it would not
	            // materialize for you, instead, allow the router to do that.
	            map(function(jsonGraphEnvelope) {
	                return materialize(router, normPS, jsonGraphEnvelope);
	            });
	    });
	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var outputToObservable = __webpack_require__(188);
	var noteToJsongOrPV = __webpack_require__(212);
	var Observable = __webpack_require__(189).Observable;
	
	module.exports = function runGetAction(routerInstance, jsongCache) {
	    return function innerGetAction(matchAndPath) {
	        return getAction(routerInstance, matchAndPath, jsongCache);
	    };
	};
	
	function getAction(routerInstance, matchAndPath, jsongCache) {
	    var match = matchAndPath.match;
	    var out;
	    try {
	        out = match.action.call(routerInstance, matchAndPath.path);
	        out = outputToObservable(out);
	    } catch (e) {
	        out = Observable.throw(e);
	    }
	
	    return out.
	        materialize().
	        filter(function(note) {
	            return note.kind !== 'C';
	        }).
	        map(noteToJsongOrPV(matchAndPath.path)).
	        map(function(jsonGraphOrPV) {
	            return [matchAndPath.match, jsonGraphOrPV];
	        });
	}
	


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var Observable = __webpack_require__(189).Observable;
	var isArray = Array.isArray;
	
	/**
	 * For the router there are several return types from user
	 * functions.  The standard set are: synchronous type (boolean or
	 * json graph) or an async type (observable or a thenable).
	 */
	module.exports = function outputToObservable(valueOrObservable) {
	    var value = valueOrObservable,
	        oldObservable;
	
	    // falsy value
	    if (!value) {
	        return Observable.return(value);
	    }
	
	    // place holder.  Observables have highest precedence.
	    else if (value.subscribe) {
	        if (!(value instanceof Observable)) {
	            oldObservable = value;
	            value = Observable.create(function(observer) {
	                return oldObservable.subscribe(observer);
	            });
	        }
	    }
	
	    // promise
	    else if (value.then) {
	        value = Observable.fromPromise(value);
	    }
	
	    // from array of pathValues.
	    else if (isArray(value)) {
	        value = Observable.of(value);
	    }
	
	    // this will be jsong or pathValue at this point.
	    // NOTE: For the case of authorize this will be a boolean
	    else {
	        value = Observable.of(value);
	    }
	
	    return value;
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var Observable = __webpack_require__(79).Observable;
	
	__webpack_require__(113);
	__webpack_require__(119);
	__webpack_require__(103);
	__webpack_require__(190);
	__webpack_require__(97);
	__webpack_require__(192);
	
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(200);
	__webpack_require__(123);
	__webpack_require__(202);
	__webpack_require__(204);
	__webpack_require__(125);
	__webpack_require__(206);
	__webpack_require__(129);
	__webpack_require__(208);
	__webpack_require__(210);
	
	Observable.return = Observable.of;
	
	module.exports = { Observable: Observable };


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var fromPromise_1 = __webpack_require__(191);
	Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;
	//# sourceMappingURL=fromPromise.js.map

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PromiseObservable_1 = __webpack_require__(107);
	exports.fromPromise = PromiseObservable_1.PromiseObservable.create;
	//# sourceMappingURL=fromPromise.js.map

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var throw_1 = __webpack_require__(193);
	Observable_1.Observable.throw = throw_1._throw;
	//# sourceMappingURL=throw.js.map

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ErrorObservable_1 = __webpack_require__(194);
	exports._throw = ErrorObservable_1.ErrorObservable.create;
	//# sourceMappingURL=throw.js.map

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ErrorObservable = (function (_super) {
	    __extends(ErrorObservable, _super);
	    function ErrorObservable(error, scheduler) {
	        _super.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits an error notification.
	     *
	     * <span class="informal">Just emits 'error', and nothing else.
	     * </span>
	     *
	     * <img src="./img/throw.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the error notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then emit an error.</caption>
	     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @example <caption>Map and flattens numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x === 13 ?
	     *     Rx.Observable.throw('Thirteens are bad') :
	     *     Rx.Observable.of('a', 'b', 'c')
	     * );
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link of}
	     *
	     * @param {any} error The particular Error to pass to the error notification.
	     * @param {Scheduler} [scheduler] A {@link Scheduler} to use for scheduling
	     * the emission of the error notification.
	     * @return {Observable} An error Observable: emits only the error notification
	     * using the given error argument.
	     * @static true
	     * @name throw
	     * @owner Observable
	     */
	    ErrorObservable.create = function (error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };
	    ErrorObservable.dispatch = function (arg) {
	        var error = arg.error, subscriber = arg.subscriber;
	        subscriber.error(error);
	    };
	    ErrorObservable.prototype._subscribe = function (subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.error(error);
	        }
	    };
	    return ErrorObservable;
	}(Observable_1.Observable));
	exports.ErrorObservable = ErrorObservable;
	//# sourceMappingURL=ErrorObservable.js.map

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var catch_1 = __webpack_require__(196);
	Observable_1.Observable.prototype.catch = catch_1._catch;
	//# sourceMappingURL=catch.js.map

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} an observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @owner Observable
	 */
	function _catch(selector) {
	    var operator = new CatchOperator(selector);
	    var caught = this.lift(operator);
	    return (operator.caught = caught);
	}
	exports._catch = _catch;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err) {
	                this.destination.error(err);
	                return;
	            }
	            this._innerSub(result);
	        }
	    };
	    CatchSubscriber.prototype._innerSub = function (result) {
	        this.unsubscribe();
	        this.destination.remove(this);
	        result.subscribe(this.destination);
	    };
	    return CatchSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=catch.js.map

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var concat_1 = __webpack_require__(198);
	Observable_1.Observable.prototype.concat = concat_1.concat;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(102);
	var ArrayObservable_1 = __webpack_require__(99);
	var mergeAll_1 = __webpack_require__(199);
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return concatStatic.apply(void 0, [this].concat(observables));
	}
	exports.concat = concat;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins multiple Observables together by subscribing to them one at a time and
	 * merging their results into the output Observable. Will wait for each
	 * Observable to complete before moving on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat(timer1, timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {Observable} input1 An input Observable to concatenate with others.
	 * @param {Observable} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional Scheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatStatic = concatStatic;
	//# sourceMappingURL=concat.js.map

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;
	//# sourceMappingURL=mergeAll.js.map

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var defaultIfEmpty_1 = __webpack_require__(201);
	Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Returns an Observable that emits the elements of the source or a specified default value if empty.
	 * @param {any} defaultValue the default value used if source is empty; defaults to null.
	 * @return {Observable} an Observable of the items emitted by the where empty values are replaced by the specified default value or null.
	 * @method defaultIfEmpty
	 * @owner Observable
	 */
	function defaultIfEmpty(defaultValue) {
	    if (defaultValue === void 0) { defaultValue = null; }
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	exports.defaultIfEmpty = defaultIfEmpty;
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DefaultIfEmptySubscriber = (function (_super) {
	    __extends(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _super.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=defaultIfEmpty.js.map

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var expand_1 = __webpack_require__(203);
	Observable_1.Observable.prototype.expand = expand_1.expand;
	//# sourceMappingURL=expand.js.map

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(88);
	var errorObject_1 = __webpack_require__(89);
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * Returns an Observable where for each item in the source Observable, the supplied function is applied to each item,
	 * resulting in a new value to then be applied again with the function.
	 * @param {function} project the function for projecting the next emitted item of the Observable.
	 * @param {number} [concurrent] the max number of observables that can be created concurrently. defaults to infinity.
	 * @param {Scheduler} [scheduler] The Scheduler to use for managing the expansions.
	 * @return {Observable} an Observable containing the expansions of the source Observable.
	 * @method expand
	 * @owner Observable
	 */
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (scheduler === void 0) { scheduler = undefined; }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return this.lift(new ExpandOperator(project, concurrent, scheduler));
	}
	exports.expand = expand;
	var ExpandOperator = (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	exports.ExpandOperator = ExpandOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ExpandSubscriber = (function (_super) {
	    __extends(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        _super.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.isUnsubscribed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            var result = tryCatch_1.tryCatch(this.project)(value, index);
	            if (result === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else if (!this.scheduler) {
	                this.subscribeToProjection(result, value, index);
	            }
	            else {
	                var state = { subscriber: this, result: result, value: value, index: index };
	                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.ExpandSubscriber = ExpandSubscriber;
	//# sourceMappingURL=expand.js.map

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var filter_1 = __webpack_require__(205);
	Observable_1.Observable.prototype.filter = filter_1.filter;
	//# sourceMappingURL=filter.js.map

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctKey}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=filter.js.map

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var materialize_1 = __webpack_require__(207);
	Observable_1.Observable.prototype.materialize = materialize_1.materialize;
	//# sourceMappingURL=materialize.js.map

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var Notification_1 = __webpack_require__(112);
	/**
	 * Returns an Observable that represents all of the emissions and notifications
	 * from the source Observable into emissions marked with their original types
	 * within a `Notification` objects.
	 *
	 * <img src="./img/materialize.png" width="100%">
	 *
	 * @see {@link Notification}
	 *
	 * @scheduler materialize does not operate by default on a particular Scheduler.
	 * @return {Observable<Notification<T>>} an Observable that emits items that are the result of
	 * materializing the items and notifications of the source Observable.
	 * @method materialize
	 * @owner Observable
	 */
	function materialize() {
	    return this.lift(new MaterializeOperator());
	}
	exports.materialize = materialize;
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MaterializeSubscriber = (function (_super) {
	    __extends(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification_1.Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=materialize.js.map

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var reduce_1 = __webpack_require__(209);
	Observable_1.Observable.prototype.reduce = reduce_1.reduce;
	//# sourceMappingURL=reduce.js.map

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * Returns an Observable that applies a specified accumulator function to the first item emitted by a source Observable,
	 * then feeds the result of that function along with the second item emitted by the source Observable into the same
	 * function, and so on until all items have been emitted by the source Observable, and emits the final result from
	 * the final call to your function as its sole item.
	 * This technique, which is called "reduce" here, is sometimes called "aggregate," "fold," "accumulate," "compress," or
	 * "inject" in other programming contexts.
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * @param {initialValue} the initial (seed) accumulator value
	 * @param {accumulator} an accumulator function to be invoked on each item emitted by the source Observable, the
	 * result of which will be used in the next accumulator call.
	 * @return {Observable} an Observable that emits a single item that is the result of accumulating the output from the
	 * items emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce(project, seed) {
	    return this.lift(new ReduceOperator(project, seed));
	}
	exports.reduce = reduce;
	var ReduceOperator = (function () {
	    function ReduceOperator(project, seed) {
	        this.project = project;
	        this.seed = seed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ReduceSubscriber(subscriber, this.project, this.seed));
	    };
	    return ReduceOperator;
	}());
	exports.ReduceOperator = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, project, seed) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.acc = seed;
	        this.project = project;
	        this.hasSeed = typeof seed !== 'undefined';
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.project(this.acc, value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ReduceSubscriber = ReduceSubscriber;
	//# sourceMappingURL=reduce.js.map

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var toArray_1 = __webpack_require__(211);
	Observable_1.Observable.prototype.toArray = toArray_1.toArray;
	//# sourceMappingURL=toArray.js.map

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	/**
	 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
	 * @method toArray
	 * @owner Observable
	 */
	function toArray() {
	    return this.lift(new ToArrayOperator());
	}
	exports.toArray = toArray;
	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	    }
	    ToArrayOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new ToArraySubscriber(subscriber));
	    };
	    return ToArrayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ToArraySubscriber = (function (_super) {
	    __extends(ToArraySubscriber, _super);
	    function ToArraySubscriber(destination) {
	        _super.call(this, destination);
	        this.array = [];
	    }
	    ToArraySubscriber.prototype._next = function (x) {
	        this.array.push(x);
	    };
	    ToArraySubscriber.prototype._complete = function () {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };
	    return ToArraySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=toArray.js.map

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var isJSONG = __webpack_require__(213);
	var onNext = 'N';
	var errorToPathValue = __webpack_require__(214);
	
	/**
	 * Takes a path and for every onNext / onError it will attempt
	 * to pluck the value or error from the note and process it
	 * with the path object passed in.
	 * @param {PathSet|PathSet[]} pathOrPathSet -
	 * @param {Boolean} isPathSet -
	 */
	module.exports = function noteToJsongOrPV(pathOrPathSet, isPathSet) {
	    return function(note) {
	        return convertNoteToJsongOrPV(pathOrPathSet, note, isPathSet);
	    };
	};
	
	function convertNoteToJsongOrPV(pathOrPathSet, note, isPathSet) {
	    var incomingJSONGOrPathValues;
	    var kind = note.kind;
	
	    // Take what comes out of the function and assume its either a pathValue or
	    // jsonGraph.
	    if (kind === onNext) {
	        incomingJSONGOrPathValues = note.value;
	    }
	
	    // Convert the error to a pathValue.
	    else {
	        incomingJSONGOrPathValues =
	            errorToPathValue(note.exception, pathOrPathSet);
	    }
	
	    // If its jsong we may need to optionally attach the
	    // paths if the paths do not exist
	    if (isJSONG(incomingJSONGOrPathValues) &&
	        !incomingJSONGOrPathValues.paths) {
	
	        incomingJSONGOrPathValues = {
	            jsonGraph: incomingJSONGOrPathValues.jsonGraph,
	            paths: isPathSet && pathOrPathSet || [pathOrPathSet]
	        };
	    }
	
	    return incomingJSONGOrPathValues;
	}
	


/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = function isJSONG(x) {
	    return x.jsonGraph;
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	var JSONGraphError = __webpack_require__(185);
	module.exports = function errorToPathValue(error, path) {
	    var typeValue = {
	        $type: 'error',
	        value: {}
	    };
	
	    if (error.throwToNext) {
	        throw error;
	    }
	
	    // If it is a special JSONGraph error then pull all the data
	    if (error instanceof JSONGraphError) {
	        typeValue = error.typeValue;
	    }
	
	    else if (error instanceof Error) {
	        typeValue.value.message = error.message;
	    }
	
	    return {
	        path: path,
	        value: typeValue
	    };
	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var Rx = __webpack_require__(189);
	var Observable = Rx.Observable;
	var runByPrecedence = __webpack_require__(216);
	var pathUtils = __webpack_require__(166);
	var collapse = pathUtils.collapse;
	var optimizePathSets = __webpack_require__(226);
	var mCGRI = __webpack_require__(228);
	var isArray = Array.isArray;
	
	/**
	 * The recurse and match function will async recurse as long as
	 * there are still more paths to be executed.  The match function
	 * will return a set of objects that have how much of the path that
	 * is matched.  If there still is more, denoted by suffixes,
	 * paths to be matched then the recurser will keep running.
	 */
	module.exports = function recurseMatchAndExecute(
	        match, actionRunner, paths,
	        method, routerInstance, jsongCache) {
	
	    return _recurseMatchAndExecute(
	        match, actionRunner, paths,
	        method, routerInstance, jsongCache);
	};
	
	/**
	 * performs the actual recursing
	 */
	function _recurseMatchAndExecute(
	        match, actionRunner, paths,
	        method, routerInstance, jsongCache) {
	    var unhandledPaths = [];
	    var invalidated = [];
	    var reportedPaths = [];
	    var currentMethod = method;
	
	    return Observable.
	
	        // Each pathSet (some form of collapsed path) need to be sent
	        // independently.  for each collapsed pathSet will, if producing
	        // refs, be the highest likelihood of collapsibility.
	        from(paths).
	        expand(function(nextPaths) {
	            if (!nextPaths.length) {
	                return Observable.empty();
	            }
	
	            // We have to return an Observable of error instead of just
	            // throwing.
	            var matchedResults;
	            try {
	                matchedResults = match(currentMethod, nextPaths);
	            } catch (e) {
	                return Observable.throw(e);
	            }
	
	            // When there is explicitly not a match then we need to handle
	            // the unhandled paths.
	            if (!matchedResults.length) {
	                unhandledPaths.push(nextPaths);
	                return Observable.empty();
	            }
	
	            return runByPrecedence(nextPaths, matchedResults, actionRunner).
	
	                // Generate from the combined results the next requestable paths
	                // and insert errors / values into the cache.
	                flatMap(function(results) {
	                    var value = results.value;
	                    var suffix = results.match.suffix;
	
	                    // TODO: MaterializedPaths, use result.path to build up a
	                    // "foundPaths" array.  This could be used to materialize
	                    // if that is the case.  I don't think this is a
	                    // requirement, but it could be.
	                    if (!isArray(value)) {
	                        value = [value];
	                    }
	
	                    var invsRefsAndValues = mCGRI(jsongCache, value);
	                    var invalidations = invsRefsAndValues.invalidations;
	                    var unhandled = invsRefsAndValues.unhandledPaths;
	                    var messages = invsRefsAndValues.messages;
	                    var pathsToExpand = [];
	
	                    if (suffix.length > 0) {
	                        pathsToExpand = invsRefsAndValues.references;
	                    }
	
	                    // Merge the invalidations and unhandledPaths.
	                    invalidations.forEach(function(invalidation) {
	                        invalidated[invalidated.length] = invalidation.path;
	                    });
	
	                    unhandled.forEach(function(unhandledPath) {
	                        unhandledPaths[unhandledPaths.length] = unhandledPath;
	                    });
	
	                    // Merges the remaining suffix with remaining nextPaths
	                    pathsToExpand = pathsToExpand.map(function(next) {
	                        return next.value.concat(suffix);
	                    });
	
	                    // Alters the behavior of the expand
	                    messages.forEach(function(message) {
	                        // mutates the method type for the matcher
	                        if (message.method) {
	                            currentMethod = message.method;
	                        }
	
	                        // Mutates the nextPaths and adds any additionalPaths
	                        else if (message.additionalPath) {
	                            var path = message.additionalPath;
	                            pathsToExpand[pathsToExpand.length] = path;
	                            reportedPaths[reportedPaths.length] = path;
	                        }
	
	                        // Any invalidations that come down from a call
	                        else if (message.invalidations) {
	                            message.
	                                invalidations.
	                                forEach(function(invalidation) {
	                                    invalidated.push(invalidation);
	                                });
	                        }
	
	                        // We need to add the unhandledPaths to the jsonGraph
	                        // response.
	                        else if (message.unhandledPaths) {
	                            unhandledPaths = unhandledPaths.
	                                concat(message.unhandledPaths);
	                        }
	                    });
	
	                    // Explodes and collapse the tree to remove
	                    // redundants and get optimized next set of
	                    // paths to evaluate.
	                    pathsToExpand = optimizePathSets(
	                        jsongCache, pathsToExpand, routerInstance.maxRefFollow);
	
	                    if (pathsToExpand.length) {
	                        pathsToExpand = collapse(pathsToExpand);
	                    }
	
	                    return Observable.
	                        from(pathsToExpand);
	                }).
	                defaultIfEmpty([]);
	
	        }).
	        reduce(function(acc, x) {
	            return acc;
	        }, null).
	        map(function() {
	            return {
	                unhandledPaths: unhandledPaths,
	                invalidated: invalidated,
	                jsonGraph: jsongCache,
	                reportedPaths: reportedPaths
	            };
	        });
	}
	


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var Observable = __webpack_require__(189).Observable;
	var getExecutableMatches = __webpack_require__(217);
	
	/**
	 * Sorts and strips the set of available matches given the pathSet.
	 */
	module.exports = function runByPrecedence(pathSet, matches, actionRunner) {
	
	    // Precendence matching
	    var sortedMatches = matches.
	        sort(sortByPrecedence);
	
	    var execs = getExecutableMatches(sortedMatches, [pathSet]);
	
	    var setOfMatchedPaths = Observable.
	        from(execs.matchAndPaths).
	        flatMap(actionRunner).
	
	        // Note: We do not wait for each observable to finish,
	        // but repeat the cycle per onNext.
	        map(function(actionTuple) {
	
	            return {
	                match: actionTuple[0],
	                value: actionTuple[1]
	            };
	        });
	
	    if (execs.unhandledPaths) {
	        setOfMatchedPaths = setOfMatchedPaths.
	            concat(Observable.return({
	                match: {suffix: []},
	                value: {
	                    isMessage: true,
	                    unhandledPaths: execs.unhandledPaths
	                }
	            }));
	    }
	
	    return setOfMatchedPaths;
	};
	
	function sortByPrecedence(a, b) {
	
	    var aPrecedence = a.precedence;
	    var bPrecedence = b.precedence;
	
	    if (aPrecedence < bPrecedence) {
	        return 1;
	    } else if (aPrecedence > bPrecedence) {
	        return -1;
	    }
	
	    return 0;
	}


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable max-len */
	var pathUtils = __webpack_require__(166);
	var collapse = pathUtils.collapse;
	var stripPath = __webpack_require__(218);
	var hasIntersection = __webpack_require__(223);
	/* eslint-enable max-len */
	
	/**
	 * takes in the set of ordered matches and pathSet that got those matches.
	 * From there it will give back a list of matches to execute.
	 */
	module.exports = function getExecutableMatches(matches, pathSet) {
	    var remainingPaths = pathSet;
	    var matchAndPaths = [];
	    var out = {
	        matchAndPaths: matchAndPaths,
	        unhandledPaths: false
	    };
	    for (var i = 0; i < matches.length && remainingPaths.length > 0; ++i) {
	        var availablePaths = remainingPaths;
	        var match = matches[i];
	
	        remainingPaths = [];
	
	        if (i > 0) {
	            availablePaths = collapse(availablePaths);
	        }
	
	        // For every available path attempt to intersect.  If there
	        // is an intersection then strip and replace.
	        // any relative complements, add to remainingPaths
	        for (var j = 0; j < availablePaths.length; ++j) {
	            var path = availablePaths[j];
	            if (hasIntersection(path, match.virtual)) {
	                var stripResults = stripPath(path, match.virtual);
	                matchAndPaths[matchAndPaths.length] = {
	                    path: stripResults[0],
	                    match: match
	                };
	                remainingPaths = remainingPaths.concat(stripResults[1]);
	            }
	        }
	    }
	
	    // Adds the remaining paths to the unhandled paths section.
	    if (remainingPaths && remainingPaths.length) {
	        out.unhandledPaths = remainingPaths;
	    }
	
	    return out;
	};
	
	
	


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var strip = __webpack_require__(219);
	var catAndSlice = __webpack_require__(222);
	
	/**
	 * Takes in the matched path and virtual path and creates the
	 * set of paths that represent the virtualPath being stripped
	 * from the matchedPath.
	 *
	 * @example
	 * Terms:
	 * * Relative Complement: Of sets A and B the relative complement of A in B is
	 * the parts of B that A do not contain.  In our example its virtualPath (A) in
	 * matchedPath (B).
	 *
	 * Example:
	 * matchedInput = [[A, D], [B, E], [C, F]]
	 * virtualIntput = [A, Keys, C]
	 *
	 * This will produce 2 arrays from the matched operation.
	 * [
	 *   [D, [B, E], [C, F]],
	 *   [A, [B, E], [F]]
	 * ]
	 *
	 *
	 * All the complexity of this function is hidden away in strip and its inner
	 * stripping functions.
	 * @param {PathSet} matchedPath
	 * @param {PathSet} virtualPath
	 */
	module.exports = function stripPath(matchedPath, virtualPath) {
	    var relativeComplement = [];
	    var exactMatch = [];
	    var current = [];
	
	    // Always use virtual path because it can be shorter.
	    for (var i = 0, len = virtualPath.length; i < len; ++i) {
	        var matchedAtom = matchedPath[i];
	        var virtualAtom = virtualPath[i];
	        var stripResults = strip(matchedAtom, virtualAtom);
	        var innerMatch = stripResults[0];
	        var innerComplement = stripResults[1];
	        var hasComplement = innerComplement.length > 0;
	
	        // using the algorithm partially described above we need to split and
	        // combine output depending on what comes out of the split function.
	        // 1.  If there is no relative complement do no copying / slicing.
	        // 2.  If there is both the catAndslice.
	
	        if (hasComplement) {
	            var flattendIC = innerComplement.length === 1 ?
	                innerComplement[0] : innerComplement;
	            current[i] = flattendIC;
	            relativeComplement[relativeComplement.length] =
	                catAndSlice(current, matchedPath, i + 1);
	        }
	
	        // The exact match needs to be produced for calling function.
	        exactMatch[i] = innerMatch;
	        current[i] = innerMatch;
	    }
	
	    return [exactMatch, relativeComplement];
	};


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var stripFromArray = __webpack_require__(220);
	var stripFromRange = __webpack_require__(221);
	
	/**
	 *  Takes a virtual atom and the matched atom and returns an
	 * array of results that is relative complement with matchedAtom
	 * as the rhs.  I believe the proper set syntax is virutalAtom \ matchedAtom.
	 *
	 * 1) An assumption made is that the matched atom and virtual atom have
	 * an intersection.  This makes the algorithm easier since if the matched
	 * atom is a primitive and the virtual atom is an object
	 * then there is no relative complement to create.  This also means if
	 * the direct equality test fails and matchedAtom is not an object
	 * then virtualAtom is an object.  The inverse applies.
	 *
	 *
	 * @param {String|Number|Array|Object} matchedAtom
	 * @param {String|Number|Array|Object} virtualAtom
	 * @return {Array} the tuple of what was matched and the relative complenment.
	 */
	module.exports = function strip(matchedAtom, virtualAtom) {
	    var relativeComplement = [];
	    var matchedResults;
	    var typeOfMatched = typeof matchedAtom;
	    var isArrayMatched = isArray(matchedAtom);
	    var isObjectMatched = typeOfMatched === 'object';
	
	    // Lets assume they are not objects  This covers the
	    // string / number cases.
	    if (matchedAtom === virtualAtom ||
	       String(matchedAtom) === String(virtualAtom)) {
	
	        matchedResults = [matchedAtom];
	    }
	
	    // See function comment 1)
	    else if (!isObjectMatched) {
	        matchedResults = [matchedAtom];
	    }
	
	    // Its a complex object set potentially.  Let the
	    // subroutines handle the cases.
	    else {
	        var results;
	
	        // The matchedAtom needs to reduced to everything that is not in
	        // the virtualAtom.
	        if (isArrayMatched) {
	            results = stripFromArray(virtualAtom, matchedAtom);
	            matchedResults = results[0];
	            relativeComplement = results[1];
	        } else {
	            results = stripFromRange(virtualAtom, matchedAtom);
	            matchedResults = results[0];
	            relativeComplement = results[1];
	        }
	    }
	
	    if (matchedResults.length === 1) {
	        matchedResults = matchedResults[0];
	    }
	
	    return [matchedResults, relativeComplement];
	};


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var stripFromRange = __webpack_require__(221);
	var Keys = __webpack_require__(136);
	var isArray = Array.isArray;
	
	/**
	 * Takes a string, number, or RoutedToken and removes it from
	 * the array.  The results are the relative complement of what
	 * remains in the array.
	 *
	 * Don't forget: There was an intersection test performed but
	 * since we recurse over arrays, we will get elements that do
	 * not intersect.
	 *
	 * Another one is if its a routed token and a ranged array then
	 * no work needs to be done as integers, ranges, and keys match
	 * that token set.
	 *
	 * One more note.  When toStrip is an array, we simply recurse
	 * over each key.  Else it requires a lot more logic.
	 *
	 * @param {Array|String|Number|RoutedToken} toStrip
	 * @param {Array} array
	 * @return {Array} the relative complement.
	 */
	module.exports = function stripFromArray(toStrip, array) {
	    var complement;
	    var matches = [];
	    var typeToStrip = typeof toStrip;
	    var isRangedArray = typeof array[0] === 'object';
	    var isNumber = typeToStrip === 'number';
	    var isString = typeToStrip === 'string';
	    var isRoutedToken = !isNumber && !isString;
	    var routeType = isRoutedToken && toStrip.type || false;
	    var isKeys = routeType === Keys.keys;
	    var toStripIsArray = isArray(toStrip);
	
	    // The early break case.  If its a key, then there is never a
	    // relative complement.
	    if (isKeys) {
	        complement = [];
	        matches = array;
	    }
	
	    // Recurse over all the keys of the array.
	    else if (toStripIsArray) {
	        var currentArray = array;
	        toStrip.forEach(function(atom) {
	            var results = stripFromArray(atom, currentArray);
	            if (results[0] !== undefined) { // eslint-disable-line no-undefined
	                matches = matches.concat(results[0]);
	            }
	            currentArray = results[1];
	        });
	        complement = currentArray;
	    }
	
	    // The simple case, remove only the matching element from array.
	    else if (!isRangedArray && !isRoutedToken) {
	        matches = [toStrip];
	        complement = array.filter(function(x) {
	            return toStrip !== x;
	        });
	    }
	
	    // 1: from comments above
	    else if (isRangedArray && !isRoutedToken) {
	        complement = array.reduce(function(comp, range) {
	            var results = stripFromRange(toStrip, range);
	            if (results[0] !== undefined) { // eslint-disable-line no-undefined
	                matches = matches.concat(results[0]);
	            }
	            return comp.concat(results[1]);
	        }, []);
	    }
	
	    // Strips elements based on routed token type.
	    // We already matched keys above, so we only need to strip numbers.
	    else if (!isRangedArray && isRoutedToken) {
	        complement = array.filter(function(el) {
	            var type = typeof el;
	            if (type === 'number') {
	                matches[matches.length] = el;
	                return false;
	            }
	            return true;
	        });
	    }
	
	    // The final complement is rangedArray with a routedToken,
	    // relative complement is always empty.
	    else {
	        complement = [];
	        matches = array;
	    }
	
	    return [matches, complement];
	};


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var rangeToArray = __webpack_require__(145);
	var isNumber = __webpack_require__(143);
	/**
	 *  Takes the first argument, toStrip, and strips it from
	 * the range.  The output is an array of ranges that represents
	 * the remaining ranges (relative complement)
	 *
	 * One note.  When toStrip is an array, we simply recurse
	 * over each key.  Else it requires a lot more logic.
	 *
	 * Since we recurse array keys we are not guaranteed that each strip
	 * item coming in is a string integer.  That is why we are doing an isNaN
	 * check. consider: {from: 0, to: 1} and [0, 'one'] intersect at 0, but will
	 * get 'one' fed into stripFromRange.
	 *
	 * @param {Array|String|Number|Object} argToStrip can be a string, number,
	 * or a routed token.  Cannot be a range itself.
	 * @param {Range} range
	 * @return {Array.<Range>} The relative complement.
	 */
	module.exports = function stripFromRange(argToStrip, range) {
	    var ranges = [];
	    var matches = [];
	    var toStrip = argToStrip;
	    // TODO: More than likely a bug around numbers and stripping
	    var toStripIsNumber = isNumber(toStrip);
	    if (toStripIsNumber) {
	        toStrip = +toStrip;
	    }
	
	    // Strip out NaNs
	    if (!toStripIsNumber && typeof toStrip === 'string') {
	        ranges = [range];
	    }
	
	    else if (isArray(toStrip)) {
	        var currenRanges = [range];
	        toStrip.forEach(function(atom) {
	            var nextRanges = [];
	            currenRanges.forEach(function(currentRename) {
	                var matchAndComplement = stripFromRange(atom, currentRename);
	                if (matchAndComplement[0] !== undefined) {
	                    matches = matches.concat(matchAndComplement[0]);
	                }
	
	                nextRanges = nextRanges.concat(matchAndComplement[1]);
	            });
	            currenRanges = nextRanges;
	        });
	
	        ranges = currenRanges;
	    }
	
	    // The simple case, its just a number.
	    else if (toStripIsNumber) {
	
	        if (range.from < toStrip && toStrip < range.to) {
	            ranges[0] = {
	                from: range.from,
	                to: toStrip - 1
	            };
	            ranges[1] = {
	                from: toStrip + 1,
	                to: range.to
	            };
	            matches = [toStrip];
	        }
	
	        // In case its a 0 length array.
	        // Even though this assignment is redundant, its point is
	        // to capture the intention.
	        else if (range.from === toStrip && range.to === toStrip) {
	            ranges = [];
	            matches = [toStrip];
	        }
	
	        else if (range.from === toStrip) {
	            ranges[0] = {
	                from: toStrip + 1,
	                to: range.to
	            };
	            matches = [toStrip];
	        }
	
	        else if (range.to === toStrip) {
	            ranges[0] = {
	                from: range.from,
	                to: toStrip - 1
	            };
	            matches = [toStrip];
	        }
	
	        // return the range if no intersection.
	        else {
	            ranges = [range];
	        }
	    }
	
	    // Its a routed token.  Everything is matched.
	    else {
	        matches = rangeToArray(range);
	    }
	
	    // If this is a routedToken (Object) then it will match the entire
	    // range since its integers, keys, and ranges.
	    return [matches, ranges];
	};


/***/ },
/* 222 */
/***/ function(module, exports) {

	module.exports = function catAndSlice(a, b, slice) {
	    var next = [], i, j, len;
	    for (i = 0, len = a.length; i < len; ++i) {
	        next[i] = a[i];
	    }
	
	    for (j = slice || 0, len = b.length; j < len; ++j, ++i) {
	        next[i] = b[j];
	    }
	
	    return next;
	};


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var hasAtomIntersection = __webpack_require__(224);
	
	/**
	 * Checks to see if there is an intersection between the matched and
	 * virtual paths.
	 */
	module.exports = function hasIntersection(matchedPath, virtualPath) {
	    var intersection = true;
	
	    // cycles through the atoms and ensure each one has an intersection.
	    // only use the virtual path because it can be shorter than the full
	    // matched path (since it includes suffix).
	    for (var i = 0, len = virtualPath.length; i < len && intersection; ++i) {
	        intersection = hasAtomIntersection(matchedPath[i], virtualPath[i]);
	    }
	
	    return intersection;
	};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var Keys = __webpack_require__(136);
	var isArray = Array.isArray;
	var isRoutedToken = __webpack_require__(183);
	var isRange = __webpack_require__(225);
	
	/**
	 * Takes a matched and virtual atom and validates that they have an
	 * intersection.
	 */
	module.exports = function hasAtomIntersection(matchedAtom, virtualAtom) {
	    var virtualIsRoutedToken = isRoutedToken(virtualAtom);
	    var isKeys = virtualIsRoutedToken && virtualAtom.type === Keys.keys;
	    var matched = false;
	    var i, len;
	
	    // To simplify the algorithm we do not allow matched atom to be an
	    // array.  This makes the intersection test very simple.
	    if (isArray(matchedAtom)) {
	        for (i = 0, len = matchedAtom.length; i < len && !matched; ++i) {
	            matched = hasAtomIntersection(matchedAtom[i], virtualAtom);
	        }
	    }
	
	    // the == is very intentional here with all the use cases review.
	    else if (doubleEquals(matchedAtom, virtualAtom)) {
	        matched = true;
	    }
	
	    // Keys match everything.
	    else if (isKeys) {
	        matched = true;
	    }
	
	    // The routed token is for integers at this point.
	    else if (virtualIsRoutedToken) {
	        matched = isNumber(matchedAtom) || isRange(matchedAtom);
	    }
	
	    // is virtual an array
	    // Go through each of the array elements and compare against matched item.
	    else if (isArray(virtualAtom)) {
	        for (i = 0, len = virtualAtom.length; i < len && !matched; ++i) {
	            matched = hasAtomIntersection(matchedAtom, virtualAtom[i]);
	        }
	    }
	
	    // is virtual a range (last option)
	    else if (virtualAtom && typeof virtualAtom === 'object') {
	
	        var from = virtualAtom.from || 0;
	        var length = (doubleEquals(virtualAtom.to, null) ?
	            virtualAtom.length :
	            (virtualAtom.to - virtualAtom.from) + 1) || 0;
	
	        if (!isNaN(from)) {
	            if (isNumber(matchedAtom)) {
	                matched = matchedAtom >= from && matchedAtom < from + length;
	            } else if (isRange(matchedAtom)) {
	
	                var matchFrom = matchedAtom.from || 0;
	                var matchLength = (doubleEquals(matchedAtom.to, null) ?
	                    matchedAtom.length :
	                    (matchedAtom.to - matchedAtom.from) + 1) || 0;
	
	                matched = (matchFrom >= from) && (matchLength <= length);
	            }
	        }
	    }
	
	    return matched;
	};
	
	//
	function isNumber(x) {
	    return String(Number(x)) === String(x);
	}
	
	/**
	 * This was very intentional ==.  The reason is that '1' must equal 1.
	 * {} of anysort are always false and array ['one'] == 'one' but that is
	 * fine because i would have to go through the array anyways at the
	 * last elseif check.
	 */
	function doubleEquals(a, b) {
	    return a == b; // eslint-disable-line eqeqeq
	}


/***/ },
/* 225 */
/***/ function(module, exports) {

	module.exports = function isRange(range) {
	    return range.hasOwnProperty('to') && range.hasOwnProperty('from');
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(166).iterateKeySet;
	var catAndSlice = __webpack_require__(222);
	var $types = __webpack_require__(227);
	var $ref = $types.$ref;
	var errors = __webpack_require__(161);
	// var followReference = require('./followReference');
	
	/**
	 * The fastest possible optimize of paths.
	 *
	 * What it does:
	 * - Any atom short-circuit / found value will be removed from the path.
	 * - All paths will be exploded which means that collapse will need to be
	 *   ran afterwords.
	 * - Any missing path will be optimized as much as possible.
	 */
	module.exports = function optimizePathSets(cache, paths, maxRefFollow) {
	    var optimized = [];
	    paths.forEach(function(p) {
	        optimizePathSet(cache, cache, p, 0, optimized, [], maxRefFollow, 0);
	    });
	
	    return optimized;
	};
	
	
	/**
	 * optimizes one pathSet at a time.
	 */
	function optimizePathSet(cache, cacheRoot, pathSet,
	                         depth, out, optimizedPath, maxRefFollow, referenceCount) {
	
	    // at missing, report optimized path.
	    if (cache === undefined) {
	        out[out.length] = catAndSlice(optimizedPath, pathSet, depth);
	        return;
	    }
	
	    var typeofCache = cache === null ? 'undefined' : typeof cache;
	    var type = typeofCache !== 'object' ? undefined : cache.$type;
	
	    // all other sentinels are short circuited.
	    // Or we found a primitive (which includes null)
	    if (typeofCache !== 'object' || (type && type !== $ref)) {
	        return;
	    }
	
	    // If the reference is the last item in the path then do not
	    // continue to search it.
	    if (type === $ref && depth === pathSet.length) {
	        return;
	    }
	
	    var keySet = pathSet[depth];
	    var nextDepth = depth + 1;
	    var isBranchKey = nextDepth < pathSet.length;
	    var iteratorNote = {};
	    var key, next, nextOptimized;
	    var optimizedPathLength = optimizedPath.length;
	
	    key = iterateKeySet(keySet, iteratorNote);
	    do {
	        next = cache[key];
	        type = next && next.$type;
	
	        if (key !== null) {
	            optimizedPath[optimizedPathLength] = key;
	        }
	
	        if (isBranchKey && type === $ref) {
	
	            if (referenceCount > maxRefFollow) {
	                throw new Error(errors.circularReference);
	            }
	
	            nextOptimized = [];
	            var refPath = catAndSlice(next.value, pathSet, nextDepth);
	            optimizePathSet(cacheRoot, cacheRoot, refPath, 0,
	                            out, nextOptimized, maxRefFollow, referenceCount+1);
	            optimizedPath.length = optimizedPathLength;
	        } else {
	            // if (isBranchKey && type === $ref) {
	            //     var refResults =
	            //         followReference(cacheRoot, next.value, maxRefFollow);
	            //     next = refResults[0];
	
	            //     // `followReference` clones the refPath before returning it.
	            //     nextOptimized = refResults[1];
	            // } else {
	                nextOptimized = optimizedPath;
	            // }
	
	            optimizePathSet(next, cacheRoot, pathSet, nextDepth,
	                            out, nextOptimized, maxRefFollow, referenceCount);
	            optimizedPath.length = optimizedPathLength;
	        }
	
	        if (!iteratorNote.done) {
	            key = iterateKeySet(keySet, iteratorNote);
	        }
	    } while (!iteratorNote.done);
	}
	


/***/ },
/* 227 */
/***/ function(module, exports) {

	module.exports = {
	    $ref: 'ref',
	    $atom: 'atom',
	    $error: 'error'
	};


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var jsongMerge = __webpack_require__(229);
	var pathValueMerge = __webpack_require__(231);
	var isJSONG = __webpack_require__(213);
	var isMessage = __webpack_require__(232);
	module.exports = mergeCacheAndGatherRefsAndInvalidations;
	
	/**
	 * takes the response from an action and merges it into the
	 * cache.  Anything that is an invalidation will be added to
	 * the first index of the return value, and the inserted refs
	 * are the second index of the return value.  The third index
	 * of the return value is messages from the action handlers
	 *
	 * @param {Object} cache
	 * @param {Array} jsongOrPVs
	 */
	function mergeCacheAndGatherRefsAndInvalidations(cache, jsongOrPVs) {
	    var references = [];
	    var len = -1;
	    var invalidations = [];
	    var unhandledPaths = [];
	    var messages = [];
	    var values = [];
	
	    // Go through each of the outputs from the route end point and separate out
	    // each type of potential output.
	    //
	    // * There are values that need to be merged into the JSONGraphCache
	    // * There are references that need to be merged and potentially followed
	    // * There are messages that can alter the behavior of the
	    //   recurseMatchAndExecute cycle.
	    // * unhandledPaths happens when a path matches a route but the route does
	    //   not match the entire path, therefore there is unmatched paths.
	    jsongOrPVs.forEach(function(jsongOrPV) {
	        var refsAndValues = [];
	
	        if (isMessage(jsongOrPV)) {
	            messages[messages.length] = jsongOrPV;
	        }
	
	        else if (isJSONG(jsongOrPV)) {
	            refsAndValues = jsongMerge(cache, jsongOrPV);
	        }
	
	        // Last option are path values.
	        else {
	            refsAndValues = pathValueMerge(cache, jsongOrPV);
	        }
	
	        var refs = refsAndValues.references;
	        var vals = refsAndValues.values;
	        var invs = refsAndValues.invalidations;
	        var unhandled = refsAndValues.unhandledPaths;
	
	        if (vals && vals.length) {
	            values = values.concat(vals);
	        }
	
	        if (invs && invs.length) {
	            invalidations = invalidations.concat(invs);
	        }
	
	        if (unhandled && unhandled.length) {
	            unhandledPaths = unhandledPaths.concat(unhandled);
	        }
	
	        if (refs && refs.length) {
	            refs.forEach(function(ref) {
	                references[++len] = ref;
	            });
	        }
	    });
	
	    return {
	        invalidations: invalidations,
	        references: references,
	        messages: messages,
	        values: values,
	        unhandledPaths: unhandledPaths
	    };
	}


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(166).iterateKeySet;
	var types = __webpack_require__(227);
	var $ref = types.$ref;
	var clone = __webpack_require__(230);
	var cloneArray = __webpack_require__(162);
	var catAndSlice = __webpack_require__(222);
	
	/**
	 * merges jsong into a seed
	 */
	module.exports = function jsongMerge(cache, jsongEnv) {
	    var paths = jsongEnv.paths;
	    var j = jsongEnv.jsonGraph;
	    var references = [];
	    var values = [];
	
	    paths.forEach(function(p) {
	        merge({
	            cacheRoot: cache,
	            messageRoot: j,
	            references: references,
	            values: values,
	            requestedPath: [],
	            requestIdx: -1,
	            ignoreCount: 0
	        },  cache, j, 0, p);
	    });
	
	    return {
	        references: references,
	        values: values
	    };
	};
	
	function merge(config, cache, message, depth, path, fromParent, fromKey) {
	    var cacheRoot = config.cacheRoot;
	    var messageRoot = config.messageRoot;
	    var requestedPath = config.requestedPath;
	    var ignoreCount = config.ignoreCount;
	    var typeOfMessage = typeof message;
	    var messageType = message && message.$type;
	
	    // The message at this point should always be defined.
	    // Reached the end of the JSONG message path
	    if (message === null || typeOfMessage !== 'object' || messageType) {
	        fromParent[fromKey] = clone(message);
	
	        // NOTE: If we have found a reference at our cloning position
	        // and we have resolved our path then add the reference to
	        // the unfulfilledRefernces.
	        if (messageType === $ref) {
	            var references = config.references;
	            references.push({
	                path: cloneArray(requestedPath),
	                value: message.value
	            });
	        }
	
	        // We are dealing with a value.  We need this for call
	        // Call needs to report all of its values into the jsongCache
	        // and paths.
	        else {
	            var values = config.values;
	            values.push({
	                path: cloneArray(requestedPath),
	                value: messageType ? message.value : message
	            });
	        }
	
	        return;
	    }
	
	    var requestIdx = config.requestIdx;
	    var updateRequestedPath = ignoreCount <= depth;
	
	    if (updateRequestedPath) {
	        requestIdx = ++config.requestIdx;
	    }
	
	    var outerKey = path[depth];
	    var iteratorNote = {};
	    var isBranchKey = depth < path.length - 1;
	    var key = iterateKeySet(outerKey, iteratorNote);
	
	    // We always attempt this as a loop.  If the memo exists then
	    // we assume that the permutation is needed.
	    do {
	
	        // If the cache exists and we are not at our height, then
	        // just follow cache, else attempt to follow message.
	        var cacheRes = cache[key];
	        var messageRes = message[key];
	
	        // We no longer materialize inside of jsonGraph merge.  Either the
	        // client should specify all of the paths
	        if (messageRes !== undefined) {
	
	            var nextPath = path;
	            var nextDepth = depth + 1;
	            if (updateRequestedPath) {
	                requestedPath[requestIdx] = key;
	            }
	
	            // We do not continue with this branch since the cache
	            if (cacheRes === undefined) {
	                cacheRes = cache[key] = {};
	            }
	
	            var nextIgnoreCount = ignoreCount;
	
	            // TODO: Potential performance gain since we know that
	            // references are always pathSets of 1, they can be evaluated
	            // iteratively.
	
	            messageType = messageRes && messageRes.$type;
	            // There is only a need to consider message references since the
	            // merge is only for the path that is provided.
	            if (isBranchKey && messageType === $ref) {
	
	                nextDepth = 0;
	                nextPath = catAndSlice(messageRes.value, path, depth + 1);
	                cache[key] = clone(messageRes);
	
	                // Reset position in message and cache.
	                nextIgnoreCount = messageRes.value.length;
	                messageRes = messageRoot;
	                cacheRes = cacheRoot;
	            }
	
	            // move forward down the path progression.
	            config.ignoreCount = nextIgnoreCount;
	            merge(config, cacheRes, messageRes,
	                  nextDepth, nextPath, cache, key);
	            config.ignoreCount = ignoreCount;
	        }
	
	        if (updateRequestedPath) {
	            requestedPath.length = requestIdx;
	        }
	
	        // Are we done with the loop?
	        key = iterateKeySet(outerKey, iteratorNote);
	    } while (!iteratorNote.done);
	
	    if (updateRequestedPath) {
	        requestIdx = --config.requestIdx;
	    }
	}


/***/ },
/* 230 */
/***/ function(module, exports) {

	module.exports = function copy(valueType) {
	    if ((typeof valueType !== 'object') || (valueType === null)) {
	        return valueType;
	    }
	
	    return Object.
	        keys(valueType).
	        reduce(function(acc, k) {
	            acc[k] = valueType[k];
	            return acc;
	        }, {});
	};
	


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var clone = __webpack_require__(230);
	var types = __webpack_require__(227);
	var $ref = types.$ref;
	var iterateKeySet = __webpack_require__(166).iterateKeySet;
	
	/**
	 * merges pathValue into a cache
	 */
	module.exports = function pathValueMerge(cache, pathValue) {
	    var refs = [];
	    var values = [];
	    var invalidations = [];
	    var isValueType = true;
	
	    var path = pathValue.path;
	    var value = pathValue.value;
	    var type = value && value.$type;
	
	    // The pathValue invalidation shape.
	    if (pathValue.invalidated === true) {
	        invalidations.push({path: path});
	        isValueType = false;
	    }
	
	    // References and reference sets. Needed for evaluating suffixes in all
	    // three types, get, call and set.
	    else if (type === $ref) {
	        refs.push({
	            path: path,
	            value: value.value
	        });
	    }
	
	    // Values.  Needed for reporting for call.
	    else {
	        values.push(pathValue);
	    }
	
	    // If the type of pathValue is a valueType (reference or value) then merge
	    // it into the jsonGraph cache.
	    if (isValueType) {
	        innerPathValueMerge(cache, pathValue);
	    }
	
	    return {
	        references: refs,
	        values: values,
	        invalidations: invalidations
	    };
	};
	
	function innerPathValueMerge(cache, pathValue) {
	    var path = pathValue.path;
	    var curr = cache;
	    var next, key, cloned, outerKey, iteratorNote;
	    var i, len;
	
	    for (i = 0, len = path.length - 1; i < len; ++i) {
	        outerKey = path[i];
	
	        // Setup the memo and the key.
	        if (outerKey && typeof outerKey === 'object') {
	            iteratorNote = {};
	            key = iterateKeySet(outerKey, iteratorNote);
	        } else {
	            key = outerKey;
	            iteratorNote = false;
	        }
	
	        do {
	            next = curr[key];
	
	            if (!next) {
	                next = curr[key] = {};
	            }
	
	            if (iteratorNote) {
	                innerPathValueMerge(
	                    next, {
	                        path: path.slice(i + 1),
	                        value: pathValue.value
	                    });
	
	                if (!iteratorNote.done) {
	                    key = iterateKeySet(outerKey, iteratorNote);
	                }
	            }
	
	            else {
	                curr = next;
	            }
	        } while (iteratorNote && !iteratorNote.done);
	
	        // All memoized paths need to be stopped to avoid
	        // extra key insertions.
	        if (iteratorNote) {
	            return;
	        }
	    }
	
	
	    // TODO: This clearly needs a re-write.  I am just unsure of how i want
	    // this to look.  Plus i want to measure performance.
	    outerKey = path[i];
	
	    iteratorNote = {};
	    key = iterateKeySet(outerKey, iteratorNote);
	
	    do {
	
	        cloned = clone(pathValue.value);
	        curr[key] = cloned;
	
	        if (!iteratorNote.done) {
	            key = iterateKeySet(outerKey, iteratorNote);
	        }
	    } while (!iteratorNote.done);
	}


/***/ },
/* 232 */
/***/ function(module, exports) {

	module.exports = function isMessage(output) {
	    return output.hasOwnProperty('isMessage');
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var normalize = __webpack_require__(234);
	
	/**
	 * warning:  This mutates the array of arrays.
	 * It only converts the ranges to properly normalized ranges
	 * so the rest of the algos do not have to consider it.
	 */
	module.exports = function normalizePathSets(path) {
	    path.forEach(function(key, i) {
	        // the algo becomes very simple if done recursively.  If
	        // speed is needed, this is an easy optimization to make.
	        if (Array.isArray(key)) {
	            normalizePathSets(key);
	        }
	
	        else if (typeof key === 'object') {
	            path[i] = normalize(path[i]);
	        }
	    });
	    return path;
	};


/***/ },
/* 234 */
/***/ function(module, exports) {

	/**
	 * takes in a range and normalizes it to have a to / from
	 */
	module.exports = function normalize(range) {
	    var from = range.from || 0;
	    var to;
	    if (typeof range.to === 'number') {
	        to = range.to;
	    } else {
	        to = from + range.length - 1;
	    }
	
	    return {to: to, from: from};
	};


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var pathValueMerge = __webpack_require__(231);
	var optimizePathSets = __webpack_require__(226);
	var $atom = __webpack_require__(227).$atom;
	
	/**
	 * given a set of paths and a jsonGraph envelope, materialize missing will
	 * crawl all the paths to ensure that they have been fully filled in.  The
	 * paths that are missing will be filled with materialized atoms.
	 */
	module.exports = function materializeMissing(router, paths, jsongEnv) {
	    var jsonGraph = jsongEnv.jsonGraph;
	    var materializedAtom = {$type: $atom};
	
	    // Optimizes the pathSets from the jsong then
	    // inserts atoms of undefined.
	    optimizePathSets(jsonGraph, paths, router.maxRefFollow).
	        forEach(function(optMissingPath) {
	            pathValueMerge(jsonGraph, {
	                path: optMissingPath,
	                value: materializedAtom
	            });
	        });
	
	    return {jsonGraph: jsonGraph};
	}


/***/ },
/* 236 */
/***/ function(module, exports) {

	var MESSAGE = "Maximum number of paths exceeded.";
	
	var MaxPathsExceededError = function MaxPathsExceededError(message) {
	    this.message = message === undefined ? MESSAGE : message;
	    this.stack = (new Error()).stack;
	};
	
	MaxPathsExceededError.prototype = new Error();
	MaxPathsExceededError.prototype.throwToNext = true;
	
	module.exports = MaxPathsExceededError;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var falcorPathUtils = __webpack_require__(166);
	
	function getPathsCount(pathSets) {
	    return pathSets.reduce(function(numPaths, pathSet) {
	        return numPaths + falcorPathUtils.pathCount(pathSet);
	    }, 0);
	}
	
	module.exports = getPathsCount;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var set = 'set';
	var recurseMatchAndExecute = __webpack_require__(215);
	var runSetAction = __webpack_require__(239);
	var materialize = __webpack_require__(235);
	var Observable = __webpack_require__(189).Observable;
	var spreadPaths = __webpack_require__(240);
	var pathValueMerge = __webpack_require__(231);
	var optimizePathSets = __webpack_require__(226);
	var hasIntersectionWithTree =
	    __webpack_require__(241);
	var getValue = __webpack_require__(242);
	var normalizePathSets = __webpack_require__(233);
	var pathUtils = __webpack_require__(166);
	var collapse = pathUtils.collapse;
	var mCGRI = __webpack_require__(228);
	var MaxPathsExceededError = __webpack_require__(236);
	var getPathsCount = __webpack_require__(237);
	
	/**
	 * @returns {Observable.<JSONGraph>}
	 * @private
	 */
	module.exports = function routerSet(jsonGraph) {
	
	    var router = this;
	
	    return Observable.defer(function() {
	        var jsongCache = {};
	        var action = runSetAction(router, jsonGraph, jsongCache);
	        jsonGraph.paths = normalizePathSets(jsonGraph.paths);
	
	        if (getPathsCount(jsonGraph.paths) > router.maxPaths) {
	            throw new MaxPathsExceededError();
	        }
	
	        return recurseMatchAndExecute(router._matcher, action, jsonGraph.paths,
	                                      set, router, jsongCache).
	
	            // Takes the jsonGraphEnvelope and extra details that comes out
	            // of the recursive matching algorithm and either attempts the 
	            // fallback options or returns the built jsonGraph.
	            flatMap(function(details) {
	                var out = {
	                    jsonGraph: details.jsonGraph
	                };
	
	                // If there is an unhandler then we should call that method and
	                // provide the subset of jsonGraph that represents the missing
	                // routes.
	                if (details.unhandledPaths.length && router._unhandled) {
	                    var unhandledPaths = details.unhandledPaths;
	                    var jsonGraphFragment = {};
	
	                    // PERFORMANCE: 
	                    //   We know this is a potential performance downfall
	                    //   but we want to see if its even a corner case.
	                    //   Most likely this will not be hit, but if it does
	                    //   then we can take care of it
	                    // Set is interesting.  This is what has to happen.
	                    // 1. incoming paths are spread so that each one is simple.
	                    // 2. incoming path, one at a time, are optimized by the
	                    //    incoming jsonGraph.
	                    // 3. test intersection against incoming optimized path and
	                    //    unhandledPathSet
	                    // 4. If 3 is true, build the jsonGraphFragment by using a
	                    //    pathValue of optimizedPath and vale from un-optimized
	                    //    path and original jsonGraphEnvelope.
	                    var jsonGraphEnvelope = {jsonGraph: jsonGraphFragment};
	                    var unhandledPathsTree = unhandledPaths.
	                        reduce(function(acc, path) {
	                            pathValueMerge(acc, {path: path, value: null});
	                            return acc;
	                        }, {});
	
	                    // 1. Spread
	                    var pathIntersection = spreadPaths(jsonGraph.paths).
	
	                        // 2.1 Optimize.  We know its one at a time therefore we
	                        // just pluck [0] out.
	                        map(function(path) {
	                            return [
	                                // full path
	                                path,
	
	                                // optimized path
	                                optimizePathSets(details.jsonGraph, [path],
	                                                    router.maxRefFollow)[0]]
	                        }).
	
	                        // 2.2 Remove all the optimized paths that were found in
	                        // the cache.
	                        filter(function(x) { return x[1]; }).
	
	                        // 3.1 test intersection.
	                        map(function(pathAndOPath) {
	                            var oPath = pathAndOPath[1];
	                            var hasIntersection = hasIntersectionWithTree(
	                                oPath, unhandledPathsTree);
	
	                            // Creates the pathValue if there are a path
	                            // intersection
	                            if (hasIntersection) {
	                                var value =
	                                    getValue(jsonGraph.jsonGraph, 
	                                        pathAndOPath[0]);
	
	                                return {
	                                    path: oPath,
	                                    value: value
	                                };
	                            }
	
	                            return null;
	                        }).
	
	                        // 3.2 strip out nulls (the non-intersection paths).
	                        filter(function(x) { return x !== null; });
	
	                        // 4. build the optimized JSONGraph envelope.
	                        pathIntersection.
	                            reduce(function(acc, pathValue) {
	                                pathValueMerge(acc, pathValue);
	                                return acc;
	                            }, jsonGraphFragment);
	
	                    jsonGraphEnvelope.paths = collapse(
	                        pathIntersection.map(function(pV) {
	                            return pV.path;
	                        }));
	
	                    return router._unhandled.
	                        set(jsonGraphEnvelope).
	
	                        // Merge the solution back into the overall message.
	                        map(function(unhandledJsonGraphEnv) {
	                            mCGRI(out.jsonGraph, [{
	                                jsonGraph: unhandledJsonGraphEnv.jsonGraph,
	                                paths: unhandledPaths
	                            }]);
	                            return out;
	                        }).
	                        defaultIfEmpty(out);
	                }
	
	                return Observable.return(out);
	            }).
	
	            // We will continue to materialize over the whole jsonGraph message.
	            // This makes sense if you think about pathValues and an API that
	            // if ask for a range of 10 and only 8 were returned, it would not
	            // materialize for you, instead, allow the router to do that.
	            map(function(jsonGraphEnvelope) {
	                return materialize(router, jsonGraph.paths, jsonGraphEnvelope);
	            });
	    });
	};


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* eslint-disable max-len */
	var outputToObservable = __webpack_require__(188);
	var noteToJsongOrPV = __webpack_require__(212);
	var spreadPaths = __webpack_require__(240);
	var jsongMerge = __webpack_require__(229);
	var optimizePathSets = __webpack_require__(226);
	var hasIntersection = __webpack_require__(223);
	var pathValueMerge = __webpack_require__(231);
	var Observable = __webpack_require__(189).Observable;
	/* eslint-enable max-len */
	
	module.exports = function outerRunSetAction(routerInstance, modelContext,
	                                            jsongCache) {
	    return function innerRunSetAction(matchAndPath) {
	        return runSetAction(routerInstance, modelContext,
	                            matchAndPath, jsongCache);
	    };
	};
	
	function runSetAction(routerInstance, jsongMessage, matchAndPath, jsongCache) {
	    var out;
	    var match = matchAndPath.match;
	    var arg = matchAndPath.path;
	
	    // We are at our destination. Its time to get out
	    // the pathValues from the JSONGraph message.
	    if (match.isSet) {
	
	        var paths = spreadPaths(jsongMessage.paths);
	
	        // Determine which paths from the JSONGraph message haven't been set
	        // into the JSONGraph cache. The `spreadPaths` operation takes care of
	        // splitting complex paths into simple paths, but with the addition of
	        // complex refs, a reference can now explode out to multiple paths too.
	        //
	        // Select each requested path with at least one corresponding optimized
	        // path that intersects with the matched requested path.
	        var pathIntersections =
	            paths.
	                // Optimizes each path.
	                map(function(path) {
	                    return {
	                        requestedPath: path,
	                        optimizedPaths: optimizePathSets(
	                            jsongCache, [path], routerInstance.maxRefFollow)
	                    };
	                }).
	                // only includes the paths from the set that intersect
	                // the virtual path
	                reduce(function(intersections, pair) {
	
	                    var requested = match.requested;
	                    var optimizedPaths = pair.optimizedPaths;
	                    var rIntersectingPaths = intersections.requestedPaths;
	                    var oIntersectingPaths = intersections.optimizedPaths;
	
	                    var startLen = oIntersectingPaths.length;
	                    var i = 0, n = optimizedPaths.length, optimizedPath;
	                    for(; i < n; ++i) {
	                        optimizedPath = optimizedPaths[i];
	                        if (hasIntersection(optimizedPath, requested)) {
	                            oIntersectingPaths.push(optimizedPath);
	                        }
	                    }
	
	                    // If at least one optimized path intersects with the
	                    // matched requested path, add the corresponding original
	                    // requested path to the outer list.
	                    if (oIntersectingPaths.length > startLen) {
	                        rIntersectingPaths.push(pair.requestedPath);
	                    }
	
	                    return intersections;
	                }, {
	                    requestedPaths: [],
	                    optimizedPaths: []
	                });
	
	        var requestedIntersectingPaths = pathIntersections.requestedPaths;
	        var optimizedIntersectingPaths = pathIntersections.optimizedPaths;
	
	        // Select a list of the intersecting path values.
	        var intersectingPathValues = jsongMerge({}, {
	            paths: requestedIntersectingPaths,
	            jsonGraph: jsongMessage.jsonGraph
	        }).values;
	
	        // Build the optimized JSON tree for each intersecting path value to
	        // pass to the set route handler.
	        arg = intersectingPathValues.reduce(function(json, pv, index) {
	            pathValueMerge(json, {
	                value: pv.value,
	                path: optimizedIntersectingPaths[index]
	            });
	            return json;
	        }, {});
	    }
	    try {
	        out = match.action.call(routerInstance, arg);
	        out = outputToObservable(out);
	    } catch (e) {
	        out = Observable.throw(e);
	    }
	
	    return out.
	        materialize().
	        filter(function(note) {
	            return note.kind !== 'C';
	        }).
	        map(noteToJsongOrPV(matchAndPath.path)).
	        map(function(jsonGraphOrPV) {
	            return [matchAndPath.match, jsonGraphOrPV];
	        });
	}


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(166).iterateKeySet;
	var cloneArray = __webpack_require__(162);
	
	/**
	 * Takes in a ptahSet and will create a set of simple paths.
	 * @param {Array} paths
	 */
	module.exports = function spreadPaths(paths) {
	    var allPaths = [];
	    paths.forEach(function(x) {
	        _spread(x, 0, allPaths);
	    });
	
	    return allPaths;
	};
	
	function _spread(pathSet, depth, out, currentPath) {
	
	    /* eslint-disable no-param-reassign */
	    currentPath = currentPath || [];
	    /* eslint-enable no-param-reassign */
	
	    if (depth === pathSet.length) {
	        out[out.length] = cloneArray(currentPath);
	        return;
	    }
	
	    // Simple case
	    var key = pathSet[depth];
	    if (typeof key !== 'object') {
	        currentPath[depth] = key;
	        _spread(pathSet, depth + 1, out, currentPath);
	        return;
	    }
	
	    // complex key.
	    var iteratorNote = {};
	    var innerKey = iterateKeySet(key, iteratorNote);
	    do {
	        // spreads the paths
	        currentPath[depth] = innerKey;
	        _spread(pathSet, depth + 1, out, currentPath);
	        currentPath.length = depth;
	
	        innerKey = iterateKeySet(key, iteratorNote);
	    } while (!iteratorNote.done);
	}


/***/ },
/* 241 */
/***/ function(module, exports) {

	/**
	 * @param {PathSet} path - A simple path
	 * @param {Object} tree - The tree should have `null` leaves to denote a
	 * leaf node.
	 */
	module.exports = function hasIntersectionWithTree(path, tree) {
	    return _hasIntersection(path, tree, 0);
	};
	
	function _hasIntersection(path, node, depth) {
	
	    // Exit / base condition.  We have reached the
	    // length of our path and we are at a node of null.
	    if (depth === path.length && node === null) {
	        return true;
	    }
	
	    var key = path[depth];
	    var next = node[key];
	
	    // If its not undefined, then its a branch.
	    if (node !== undefined) {
	        return _hasIntersection(path, next, depth + 1);
	    }
	
	    return false;
	}


/***/ },
/* 242 */
/***/ function(module, exports) {

	/**
	 * To simplify this algorithm, the path must be a simple
	 * path with no complex keys.
	 *
	 * Note: The path coming in must contain no references, as
	 * all set data caches have no references.
	 * @param {Object} cache
	 * @param {PathSet} path
	 */
	module.exports = function getValue(cache, path) {
	    return path.reduce(function(acc, key) {
	        return acc[key];
	    }, cache);
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var call = 'call';
	var runCallAction = __webpack_require__(244);
	var recurseMatchAndExecute = __webpack_require__(215);
	var normalizePathSets = __webpack_require__(233);
	var CallNotFoundError = __webpack_require__(184);
	var materialize = __webpack_require__(235);
	var pathUtils = __webpack_require__(166);
	var collapse = pathUtils.collapse;
	var Observable = __webpack_require__(189).Observable;
	var MaxPathsExceededError = __webpack_require__(236);
	var getPathsCount = __webpack_require__(237);
	
	/**
	 * Performs the call mutation.  If a call is unhandled, IE throws error, then
	 * we will chain to the next dataSource in the line.
	 */
	module.exports = function routerCall(callPath, args,
	                                     refPathsArg, thisPathsArg) {
	    var router = this;
	
	    return Observable.defer(function() {
	
	        var refPaths = normalizePathSets(refPathsArg || []);
	        var thisPaths = normalizePathSets(thisPathsArg || []);
	        var jsongCache = {};
	        var action = runCallAction(router, callPath, args,
	                                   refPaths, thisPaths, jsongCache);
	        var callPaths = [callPath];
	
	        if (getPathsCount(refPaths) +
	            getPathsCount(thisPaths) +
	            getPathsCount(callPaths) >
	            router.maxPaths) {
	            throw new MaxPathsExceededError();
	        }
	
	        return recurseMatchAndExecute(router._matcher, action, callPaths, call,
	                                      router, jsongCache).
	
	            // Take that
	            map(function(jsongResult) {
	                var reportedPaths = jsongResult.reportedPaths;
	                var jsongEnv = {
	                    jsonGraph: jsongResult.jsonGraph
	                };
	
	                // Call must report the paths that have been produced.
	                if (reportedPaths.length) {
	                    // Collapse the reported paths as they may be inefficient
	                    // to send across the wire.
	                    jsongEnv.paths = collapse(reportedPaths);
	                }
	                else {
	                    jsongEnv.paths = [];
	                    jsongEnv.jsonGraph = {};
	                }
	
	                // add the invalidated paths to the jsonGraph Envelope
	                var invalidated = jsongResult.invalidated;
	                if (invalidated && invalidated.length) {
	                    jsongEnv.invalidated = invalidated;
	                }
	
	                // Calls are currently materialized.
	                materialize(router, reportedPaths, jsongEnv);
	                return jsongEnv;
	            }).
	
	            // For us to be able to chain call requests then the error that is
	            // caught has to be a 'function does not exist.' error.  From that
	            // we will try the next dataSource in the line.
	            catch(function catchException(e) {
	                if (e instanceof CallNotFoundError && router._unhandled) {
	                    return router._unhandled.
	                        call(callPath, args, refPaths, thisPaths);
	                }
	                throw e;
	            });
	    });
	};


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var isJSONG = __webpack_require__(213);
	var outputToObservable = __webpack_require__(188);
	var noteToJsongOrPV = __webpack_require__(212);
	var CallRequiresPathsError = __webpack_require__(245);
	var mCGRI = __webpack_require__(228);
	var Observable = __webpack_require__(189).Observable;
	
	module.exports =  outerRunCallAction;
	
	function outerRunCallAction(routerInstance, callPath, args,
	                            suffixes, paths, jsongCache) {
	    return function innerRunCallAction(matchAndPath) {
	        return runCallAction(matchAndPath, routerInstance, callPath,
	                             args, suffixes, paths, jsongCache);
	    };
	}
	
	function runCallAction(matchAndPath, routerInstance, callPath, args,
	                       suffixes, paths, jsongCache) {
	
	    var match = matchAndPath.match;
	    var matchedPath = matchAndPath.path;
	    var out;
	
	    // We are at out destination.  Its time to get out
	    // the pathValues from the
	    if (match.isCall) {
	
	        // This is where things get interesting
	        out = Observable.
	            defer(function() {
	            var next;
	                try {
	                    next = match.
	                        action.call(
	                            routerInstance, matchedPath, args, suffixes, paths);
	                } catch (e) {
	                    e.throwToNext = true;
	                    throw e;
	                }
	                return outputToObservable(next).
	                    toArray();
	            }).
	
	            // Required to get the references from the outputting jsong
	            // and pathValues.
	            map(function(res) {
	
	                // checks call for isJSONG and if there is jsong without paths
	                // throw errors.
	                var refs = [];
	                var values = [];
	
	                // Will flatten any arrays of jsong/pathValues.
	                var callOutput = res.
	
	                    // Filters out any falsy values
	                    filter(function(x) {
	                        return x;
	                    }).
	                    reduce(function(flattenedRes, next) {
	                        return flattenedRes.concat(next);
	                    }, []);
	
	                // An empty output from call
	                if (callOutput.length === 0) {
	                    return [];
	                }
	
	                var refLen = -1;
	                callOutput.forEach(function(r) {
	
	                    // its json graph.
	                    if (isJSONG(r)) {
	
	                        // This is a hard error and must fully stop the server
	                        if (!r.paths) {
	                            var err =
	                                new CallRequiresPathsError();
	                            err.throwToNext = true;
	                            throw err;
	                        }
	                    }
	
	                });
	
	                var invsRefsAndValues = mCGRI(jsongCache, callOutput);
	                invsRefsAndValues.references.forEach(function(ref) {
	                    refs[++refLen] = ref;
	                });
	
	                values = invsRefsAndValues.values.map(function(pv) {
	                    return pv.path;
	                });
	
	                var callLength = callOutput.length;
	                var callPathSave1 = callPath.slice(0, callPath.length - 1);
	                var hasSuffixes = suffixes && suffixes.length;
	                var hasPaths = paths && paths.length;
	
	                // We are going to use recurseMatchAndExecute to run
	                // the paths and suffixes for call.  For that to happen
	                // we must send a message to the outside to switch from
	                // call to get.
	                callOutput[++callLength] = {isMessage: true, method: 'get'};
	
	                // If there are paths to add then push them into the next
	                // paths through 'additionalPaths' message.
	                if (hasPaths && (callLength + 1)) {
	                    paths.forEach(function(path) {
	                        callOutput[++callLength] = {
	                            isMessage: true,
	                            additionalPath: callPathSave1.concat(path)
	                        };
	                    });
	                }
	
	                // Suffix is the same as paths except for how to calculate
	                // a path per reference found from the callPath.
	                if (hasSuffixes) {
	
	                    // matchedPath is the optimized path to call.
	                    // e.g:
	                    // callPath: [genreLists, 0, add] ->
	                    // matchedPath: [lists, 'abc', add]
	                    var optimizedPathLength = matchedPath.length - 1;
	
	                    // For every reference build the complete path
	                    // from the callPath - 1 and concat remaining
	                    // path from the PathReference (path is where the
	                    // reference was found, not the value of the reference).
	                    // e.g: from the above example the output is:
	                    // output = {path: [lists, abc, 0], value: [titles, 123]}
	                    //
	                    // This means the refs object = [output];
	                    // callPathSave1: [genreLists, 0],
	                    // optimizedPathLength: 3 - 1 = 2
	                    // ref.path.slice(2): [lists, abc, 0].slice(2) = [0]
	                    // deoptimizedPath: [genreLists, 0, 0]
	                    //
	                    // Add the deoptimizedPath to the callOutput messages.
	                    // This will make the outer expand run those as a 'get'
	                    refs.forEach(function(ref) {
	                        var deoptimizedPath = callPathSave1.concat(
	                                ref.path.slice(optimizedPathLength));
	                        suffixes.forEach(function(suffix) {
	                            var additionalPath =
	                                deoptimizedPath.concat(suffix);
	                            callOutput[++callLength] = {
	                                isMessage: true,
	                                additionalPath: additionalPath
	                            };
	                        });
	                    });
	                }
	
	                // If there are no suffixes but there are references, report
	                // the paths to the references.  There may be values as well,
	                // add those to the output.
	                if (refs.length && !hasSuffixes || values.length) {
	                    var additionalPaths = [];
	                    if (refs.length && !hasSuffixes) {
	                        additionalPaths = refs.
	                            map(function(x) { return x.path; });
	                    }
	                    additionalPaths.
	                        concat(values).
	                        forEach(function(path) {
	                            callOutput[++callLength] = {
	                                isMessage: true,
	                                additionalPath: path
	                            };
	                        });
	                }
	
	                return callOutput;
	            }).
	
	            // When call has an error it needs to be propagated to the next
	            // level instead of onCompleted'ing
	            do(null, function(e) {
	                e.throwToNext = true;
	                throw e;
	            });
	    } else {
	        out = match.action.call(routerInstance, matchAndPath.path);
	        out = outputToObservable(out);
	    }
	
	    return out.
	        materialize().
	        filter(function(note) {
	            return note.kind !== 'C';
	        }).
	        map(noteToJsongOrPV(matchAndPath.path)).
	        map(function(jsonGraphOrPV) {
	            return [matchAndPath.match, jsonGraphOrPV];
	        });
	}


/***/ },
/* 245 */
/***/ function(module, exports) {

	var MESSAGE = 'Any JSONG-Graph returned from call must have paths.';
	var CallRequiresPathsError = function CallRequiresPathsError() {
	    this.message = MESSAGE;
	    this.stack = (new Error()).stack;
	};
	
	CallRequiresPathsError.prototype = new Error();
	
	module.exports = CallRequiresPathsError;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Model = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _falcor = __webpack_require__(247);
	
	var _Observable2 = __webpack_require__(79);
	
	var _falcorPathSyntax = __webpack_require__(149);
	
	var _falcorPathSyntax2 = _interopRequireDefault(_falcorPathSyntax);
	
	var _InvalidateResponse = __webpack_require__(377);
	
	var _InvalidateResponse2 = _interopRequireDefault(_InvalidateResponse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var ObservableModelResponse = function (_Observable) {
	    _inherits(ObservableModelResponse, _Observable);
	
	    function ObservableModelResponse(source) {
	        _classCallCheck(this, ObservableModelResponse);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ObservableModelResponse).call(this));
	
	        _this.source = source;
	        return _this;
	    }
	
	    _createClass(ObservableModelResponse, [{
	        key: 'lift',
	        value: function lift(operator) {
	            var response = new ObservableModelResponse(this);
	            response.operator = operator;
	            return response;
	        }
	    }, {
	        key: '_toJSONG',
	        value: function _toJSONG() {
	            return new ObservableModelResponse(this.source._toJSONG());
	        }
	    }, {
	        key: 'progressively',
	        value: function progressively() {
	            return new ObservableModelResponse(this.source.progressively());
	        }
	    }]);
	
	    return ObservableModelResponse;
	}(_Observable2.Observable);
	
	var Model = exports.Model = function (_FalcorModel) {
	    _inherits(Model, _FalcorModel);
	
	    function Model() {
	        _classCallCheck(this, Model);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Model).apply(this, arguments));
	    }
	
	    _createClass(Model, [{
	        key: 'inspect',
	
	        /* implement inspect method for node's inspect utility */
	        value: function inspect() {
	            return '{ v' + this.getVersion() + ' ' + JSON.stringify(this.getPath()) + ' }';
	        }
	    }, {
	        key: 'get',
	        value: function get() {
	            for (var _len = arguments.length, getArgs = Array(_len), _key = 0; _key < _len; _key++) {
	                getArgs[_key] = arguments[_key];
	            }
	
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'get', this).apply(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(getArgs)));
	        }
	    }, {
	        key: 'set',
	        value: function set() {
	            for (var _len2 = arguments.length, setArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	                setArgs[_key2] = arguments[_key2];
	            }
	
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'set', this).apply(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(setArgs)));
	        }
	    }, {
	        key: 'call',
	        value: function call(fnPath, fnArgs, refPaths, thisPaths) {
	            fnPath = (0, _falcorPathSyntax.fromPath)(fnPath);
	            refPaths = refPaths && (0, _falcorPathSyntax.fromPathsOrPathValues)(refPaths) || [];
	            thisPaths = thisPaths && (0, _falcorPathSyntax.fromPathsOrPathValues)(thisPaths) || [];
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'call', this).call(this, fnPath, fnArgs, refPaths, thisPaths));
	        }
	    }, {
	        key: 'getItems',
	        value: function getItems() {
	            var _this3 = this;
	
	            var thisPathsSelector = arguments.length <= 0 || arguments[0] === undefined ? function () {
	                return [['length']];
	            } : arguments[0];
	            var restPathsSelector = arguments.length <= 1 || arguments[1] === undefined ? function (_ref) {
	                var length = _ref.json.length;
	                return [];
	            } : arguments[1];
	
	
	            var thisPaths = (0, _falcorPathSyntax.fromPathsOrPathValues)([].concat(thisPathsSelector(this)));
	
	            return thisPaths.length === 0 ? _Observable2.Observable.empty() : this.get.apply(this, _toConsumableArray(thisPaths)).mergeMap(function (result) {
	
	                var restPaths = (0, _falcorPathSyntax.fromPathsOrPathValues)([].concat(restPathsSelector(result)));
	
	                return restPaths.length === 0 ? _Observable2.Observable.of(result) : _this3.get.apply(_this3, _toConsumableArray(thisPaths.concat(restPaths)));
	            });
	        }
	    }, {
	        key: 'invalidateAsync',
	        value: function invalidateAsync() {
	            for (var _len3 = arguments.length, invalidateArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	                invalidateArgs[_key3] = arguments[_key3];
	            }
	
	            return new ObservableModelResponse(new _InvalidateResponse2.default(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(invalidateArgs)));
	        }
	    }, {
	        key: 'preload',
	        value: function preload() {
	            for (var _len4 = arguments.length, preloadArgs = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	                preloadArgs[_key4] = arguments[_key4];
	            }
	
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'preload', this).apply(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(preloadArgs)));
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue() {
	            for (var _len5 = arguments.length, getValueArgs = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	                getValueArgs[_key5] = arguments[_key5];
	            }
	
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'getValue', this).apply(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(getValueArgs)));
	        }
	    }, {
	        key: 'setValue',
	        value: function setValue() {
	            for (var _len6 = arguments.length, setValueArgs = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
	                setValueArgs[_key6] = arguments[_key6];
	            }
	
	            return new ObservableModelResponse(_get(Object.getPrototypeOf(Model.prototype), 'setValue', this).apply(this, (0, _falcorPathSyntax.fromPathsOrPathValues)(setValueArgs)));
	        }
	    }, {
	        key: '_clone',
	        value: function _clone(opts) {
	            var clone = new Model(this);
	            for (var key in opts) {
	                var value = opts[key];
	                if (value === "delete") {
	                    delete clone[key];
	                } else {
	                    clone[key] = value;
	                }
	            }
	            if (clone._path.length > 0) {
	                clone.setCache = void 0;
	            }
	            return clone;
	        }
	    }]);
	
	    return Model;
	}(_falcor.Model);
	//# sourceMappingURL=Model.js.map

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	function falcor(opts) {
	    return new falcor.Model(opts);
	}
	
	var hasOwn = __webpack_require__(248);
	var internalKeys = __webpack_require__(250);
	
	/**
	 * A filtering method for keys from a falcor json response.  The only gotcha
	 * to this method is when the incoming json is undefined, then undefined will
	 * be returned.
	 *
	 * @public
	 * @param {Object} json - The json response from a falcor model.
	 * @returns {Array} - the keys that are in the model response minus the deref
	 * _private_ meta data.
	 */
	falcor.keys = function getJSONKeys(json) {
	    if (!json) {
	        return undefined;
	    }
	
	    return Object.
	        keys(json).
	        filter(function(key) {
	            return !hasOwn(internalKeys, key);
	        });
	};
	
	if (typeof Promise === "function") {
	    falcor.Promise = Promise;
	} else {
	    falcor.Promise = __webpack_require__(251);
	}
	
	module.exports = falcor;
	
	falcor.Model = __webpack_require__(260);


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	var hasOwn = Object.prototype.hasOwnProperty;
	
	module.exports = function(obj, prop) {
	  return isObject(obj) && hasOwn.call(obj, prop);
	};


/***/ },
/* 249 */
/***/ function(module, exports) {

	var objTypeof = "object";
	module.exports = function isObject(value) {
	    return value !== null && typeof value === objTypeof;
	};


/***/ },
/* 250 */
/***/ function(module, exports) {

	/**
	 * The list of internal keys.  Instead of a bunch of little files,
	 * have them as one exports.  This makes the bundling overhead smaller!
	 */
	module.exports = {
	    $toReference: "$toReference",
	    $path: "$path",
	    $refPath: "$refPath",
	    $version: "$version",
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(252)


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(253);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var asap = __webpack_require__(254);
	
	function noop() {}
	
	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable
	
	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.
	
	
	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	module.exports = Promise;
	
	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._37 = 0;
	  this._12 = null;
	  this._59 = [];
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._99 = noop;
	
	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};
	
	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._37 === 3) {
	    self = self._12;
	  }
	  if (self._37 === 0) {
	    self._59.push(deferred);
	    return;
	  }
	  asap(function() {
	    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._37 === 1) {
	        resolve(deferred.promise, self._12);
	      } else {
	        reject(deferred.promise, self._12);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._12);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._37 = 3;
	      self._12 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._37 = 1;
	  self._12 = newValue;
	  finale(self);
	}
	
	function reject(self, newValue) {
	  self._37 = 2;
	  self._12 = newValue;
	  finale(self);
	}
	function finale(self) {
	  for (var i = 0; i < self._59.length; i++) {
	    handle(self, self._59[i]);
	  }
	  self._59 = null;
	}
	
	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}
	
	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 254 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}
	
	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;
	
	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}
	
	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
	
	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;
	
	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);
	
	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.
	
	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396
	
	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}
	
	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;
	
	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}
	
	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html
	
	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.
	
	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }
	
	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.
	
	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }
	
	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.
	
	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.
	
	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);
	
	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}
	
	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
	
	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(253);
	
	module.exports = Promise;
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this;
	  self.then(null, function (err) {
	    setTimeout(function () {
	      throw err;
	    }, 0);
	  });
	};


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(253);
	
	module.exports = Promise;
	Promise.prototype['finally'] = function (f) {
	  return this.then(function (value) {
	    return Promise.resolve(f()).then(function () {
	      return value;
	    });
	  }, function (err) {
	    return Promise.resolve(f()).then(function () {
	      throw err;
	    });
	  });
	};


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//This file contains the ES6 extensions to the core Promises/A+ API
	
	var Promise = __webpack_require__(253);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');
	
	function valuePromise(value) {
	  var p = new Promise(Promise._99);
	  p._37 = 1;
	  p._12 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;
	
	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;
	
	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};
	
	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);
	
	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._37 === 3) {
	            val = val._12;
	          }
	          if (val._37 === 1) return res(i, val._12);
	          if (val._37 === 2) reject(val._12);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};
	
	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};
	
	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};
	
	/* Prototype Methods */
	
	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	// This file contains then/promise specific extensions that are only useful
	// for node.js interop
	
	var Promise = __webpack_require__(253);
	var asap = __webpack_require__(259);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	Promise.denodeify = function (fn, argumentCount) {
	  argumentCount = argumentCount || Infinity;
	  return function () {
	    var self = this;
	    var args = Array.prototype.slice.call(arguments, 0,
	        argumentCount > 0 ? argumentCount : 0);
	    return new Promise(function (resolve, reject) {
	      args.push(function (err, res) {
	        if (err) reject(err);
	        else resolve(res);
	      })
	      var res = fn.apply(self, args);
	      if (res &&
	        (
	          typeof res === 'object' ||
	          typeof res === 'function'
	        ) &&
	        typeof res.then === 'function'
	      ) {
	        resolve(res);
	      }
	    })
	  }
	}
	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments);
	    var callback =
	      typeof args[args.length - 1] === 'function' ? args.pop() : null;
	    var ctx = this;
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx);
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) {
	          reject(ex);
	        });
	      } else {
	        asap(function () {
	          callback.call(ctx, ex);
	        })
	      }
	    }
	  }
	}
	
	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this;
	
	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value);
	    });
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err);
	    });
	  });
	}


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	// rawAsap provides everything we need except exception management.
	var rawAsap = __webpack_require__(254);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
	
	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}
	
	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}
	
	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}
	
	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	var ModelRoot = __webpack_require__(261);
	var ModelDataSourceAdapter = __webpack_require__(264);
	
	var RequestQueue = __webpack_require__(265);
	var ModelResponse = __webpack_require__(333);
	var CallResponse = __webpack_require__(337);
	var InvalidateResponse = __webpack_require__(377);
	
	var ASAPScheduler = __webpack_require__(378);
	var TimeoutScheduler = __webpack_require__(379);
	var ImmediateScheduler = __webpack_require__(263);
	
	var arrayClone = __webpack_require__(380);
	var arraySlice = __webpack_require__(331);
	
	var promoteLru = __webpack_require__(352);
	var collectLru = __webpack_require__(373);
	var pathSyntax = __webpack_require__(149);
	
	var getSize = __webpack_require__(301);
	var isObject = __webpack_require__(249);
	var isPrimitive = __webpack_require__(325);
	var isJSONEnvelope = __webpack_require__(341);
	var isJSONGraphEnvelope = __webpack_require__(340);
	
	var setCache = __webpack_require__(381);
	var setJSONGraphs = __webpack_require__(269);
	var jsong = __webpack_require__(383);
	var ID = 0;
	var validateInput = __webpack_require__(384);
	var noOp = function() {};
	var getCache = __webpack_require__(386);
	var get = __webpack_require__(346);
	var GET_VALID_INPUT = __webpack_require__(388);
	
	module.exports = Model;
	
	Model.ref = jsong.ref;
	Model.atom = jsong.atom;
	Model.error = jsong.error;
	Model.pathValue = jsong.pathValue;
	/**
	 * This callback is invoked when the Model's cache is changed.
	 * @callback Model~onChange
	 */
	
	 /**
	 * This function is invoked on every JSONGraph Error retrieved from the DataSource. This function allows Error objects to be transformed before being stored in the Model's cache.
	 * @callback Model~errorSelector
	 * @param {Object} jsonGraphError - the JSONGraph Error object to transform before it is stored in the Model's cache.
	 * @returns {Object} the JSONGraph Error object to store in the Model cache.
	 */
	
	 /**
	 * This function is invoked every time a value in the Model cache is about to be replaced with a new value. If the function returns true, the existing value is replaced with a new value and the version flag on all of the value's ancestors in the tree are incremented.
	 * @callback Model~comparator
	 * @param {Object} existingValue - the current value in the Model cache.
	 * @param {Object} newValue - the value about to be set into the Model cache.
	 * @returns {Boolean} the Boolean value indicating whether the new value and the existing value are equal.
	 */
	
	/**
	 * A Model object is used to execute commands against a {@link JSONGraph} object. {@link Model}s can work with a local JSONGraph cache, or it can work with a remote {@link JSONGraph} object through a {@link DataSource}.
	 * @constructor
	 * @param {?Object} options - a set of options to customize behavior
	 * @param {?DataSource} options.source - a data source to retrieve and manage the {@link JSONGraph}
	 * @param {?JSONGraph} options.cache - initial state of the {@link JSONGraph}
	 * @param {?number} options.maxSize - the maximum size of the cache
	 * @param {?number} options.collectRatio - the ratio of the maximum size to collect when the maxSize is exceeded
	 * @param {?Model~errorSelector} options.errorSelector - a function used to translate errors before they are returned
	 * @param {?Model~onChange} options.onChange - a function called whenever the Model's cache is changed
	 * @param {?Model~comparator} options.comparator - a function called whenever a value in the Model's cache is about to be replaced with a new value.
	 */
	function Model(o) {
	
	    var options = o || {};
	    this._root = options._root || new ModelRoot(options, this);
	    this._path = options.path || options._path || [];
	    this._scheduler = options.scheduler || options._scheduler || new ImmediateScheduler();
	    this._source = options.source || options._source;
	    this._request = options.request || options._request || new RequestQueue(this, this._scheduler);
	    this._ID = ID++;
	
	    if (typeof options.maxSize === "number") {
	        this._maxSize = options.maxSize;
	    } else {
	        this._maxSize = options._maxSize || Model.prototype._maxSize;
	    }
	
	    if (typeof options.collectRatio === "number") {
	        this._collectRatio = options.collectRatio;
	    } else {
	        this._collectRatio = options._collectRatio || Model.prototype._collectRatio;
	    }
	
	    if (options.boxed || options.hasOwnProperty("_boxed")) {
	        this._boxed = options.boxed || options._boxed;
	    }
	
	    if (options.materialized || options.hasOwnProperty("_materialized")) {
	        this._materialized = options.materialized || options._materialized;
	    }
	
	    if (typeof options.treatErrorsAsValues === "boolean") {
	        this._treatErrorsAsValues = options.treatErrorsAsValues;
	    } else if (options.hasOwnProperty("_treatErrorsAsValues")) {
	        this._treatErrorsAsValues = options._treatErrorsAsValues;
	    }
	
	    this._allowFromWhenceYouCame = options.allowFromWhenceYouCame ||
	        options._allowFromWhenceYouCame || false;
	
	    if (options.cache) {
	        this.setCache(options.cache);
	    }
	}
	
	Model.prototype.constructor = Model;
	
	Model.prototype._materialized = false;
	Model.prototype._boxed = false;
	Model.prototype._progressive = false;
	Model.prototype._treatErrorsAsValues = false;
	Model.prototype._maxSize = Math.pow(2, 53) - 1;
	Model.prototype._collectRatio = 0.75;
	
	/**
	 * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.
	 * @function
	 * @param {...PathSet} path - the path(s) to retrieve
	 * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON
	 */
	Model.prototype.get = __webpack_require__(389);
	
	/**
	 * The get method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model}. The get method loads each value into a JSON object and returns in a ModelResponse.
	 * @function
	 * @private
	 * @param {Array.<PathSet>} paths - the path(s) to retrieve
	 * @return {ModelResponse.<JSONEnvelope>} - the requested data as JSON
	 */
	Model.prototype._getWithPaths = __webpack_require__(390);
	
	/**
	 * Sets the value at one or more places in the JSONGraph model. The set method accepts one or more {@link PathValue}s, each of which is a combination of a location in the document and the value to place there.  In addition to accepting  {@link PathValue}s, the set method also returns the values after the set operation is complete.
	 * @function
	 * @return {ModelResponse.<JSONEnvelope>} - an {@link Observable} stream containing the values in the JSONGraph model after the set was attempted
	 */
	Model.prototype.set = __webpack_require__(391);
	
	/**
	 * The preload method retrieves several {@link Path}s or {@link PathSet}s from a {@link Model} and loads them into the Model cache.
	 * @function
	 * @param {...PathSet} path - the path(s) to retrieve
	 * @return {ModelResponse.<JSONEnvelope>} - a ModelResponse that completes when the data has been loaded into the cache.
	 */
	Model.prototype.preload = function preload() {
	    var out = validateInput(arguments, GET_VALID_INPUT, "preload");
	    if (out !== true) {
	        return new ModelResponse(function(o) {
	            o.onError(out);
	        });
	    }
	    var args = Array.prototype.slice.call(arguments);
	    var self = this;
	    return new ModelResponse(function(obs) {
	        return self.get.apply(self, args).subscribe(function() {
	        }, function(err) {
	            obs.onError(err);
	        }, function() {
	            obs.onCompleted();
	        });
	    });
	};
	
	/**
	 * Invokes a function in the JSON Graph.
	 * @function
	 * @param {Path} functionPath - the path to the function to invoke
	 * @param {Array.<Object>} args - the arguments to pass to the function
	 * @param {Array.<PathSet>} refPaths - the paths to retrieve from the JSON Graph References in the message returned from the function
	 * @param {Array.<PathSet>} thisPaths - the paths to retrieve from function's this object after successful function execution
	 * @return {ModelResponse.<JSONEnvelope> - a JSONEnvelope contains the values returned from the function
	 */
	Model.prototype.call = function call() {
	    var args;
	    var argsIdx = -1;
	    var argsLen = arguments.length;
	    args = new Array(argsLen);
	    while (++argsIdx < argsLen) {
	        var arg = arguments[argsIdx];
	        args[argsIdx] = arg;
	        var argType = typeof arg;
	        if (argsIdx > 1 && !Array.isArray(arg) ||
	            argsIdx === 0 && !Array.isArray(arg) && argType !== "string" ||
	            argsIdx === 1 && !Array.isArray(arg) && !isPrimitive(arg)) {
	            /* eslint-disable no-loop-func */
	            return new ModelResponse(function(o) {
	                o.onError(new Error("Invalid argument"));
	            });
	            /* eslint-enable no-loop-func */
	        }
	    }
	
	    return new CallResponse(this, args[0], args[1], args[2], args[3]);
	};
	
	/**
	 * The invalidate method synchronously removes several {@link Path}s or {@link PathSet}s from a {@link Model} cache.
	 * @function
	 * @param {...PathSet} path - the  paths to remove from the {@link Model}'s cache.
	 */
	Model.prototype.invalidate = function invalidate() {
	    var args;
	    var argsIdx = -1;
	    var argsLen = arguments.length;
	    args = [];
	    while (++argsIdx < argsLen) {
	        args[argsIdx] = pathSyntax.fromPath(arguments[argsIdx]);
	        if (!Array.isArray(args[argsIdx])) {
	            throw new Error("Invalid argument");
	        }
	    }
	
	    // creates the obs, subscribes and will throw the errors if encountered.
	    (new InvalidateResponse(this, args)).
	        subscribe(noOp, function(e) {
	            throw e;
	        });
	};
	
	/**
	 * Returns a new {@link Model} bound to a location within the {@link
	 * JSONGraph}. The bound location is never a {@link Reference}: any {@link
	 * Reference}s encountered while resolving the bound {@link Path} are always
	 * replaced with the {@link Reference}s target value. For subsequent operations
	 * on the {@link Model}, all paths will be evaluated relative to the bound
	 * path. Deref allows you to:
	 * - Expose only a fragment of the {@link JSONGraph} to components, rather than
	 *   the entire graph
	 * - Hide the location of a {@link JSONGraph} fragment from components
	 * - Optimize for executing multiple operations and path looksup at/below the
	 *   same location in the {@link JSONGraph}
	 * @method
	 * @param {Object} responseObject - an object previously retrieved from the
	 * Model
	 * @return {Model} - the dereferenced {@link Model}
	 * @example
	var Model = falcor.Model;
	var model = new Model({
	  cache: {
	    users: [
	      Model.ref(["usersById", 32])
	    ],
	    usersById: {
	      32: {
	        name: "Steve",
	        surname: "McGuire"
	      }
	    }
	  }
	});
	
	model.
	    get(['users', 0, 'name']).
	    subscribe(function(jsonEnv) {
	        var userModel = model.deref(jsonEnv.json.users[0]);
	        console.log(model.getPath());
	        console.log(userModel.getPath());
	   });
	});
	
	// prints the following:
	// []
	// ["usersById", 32] - because userModel refers to target of reference at ["users", 0]
	 */
	Model.prototype.deref = __webpack_require__(393);
	
	/**
	 * A dereferenced model can become invalid when the reference from which it was
	 * built has been removed/collected/expired/etc etc.  To fix the issue, a from
	 * the parent request should be made (no parent, then from the root) for a valid
	 * path and re-dereference performed to update what the model is bound too.
	 *
	 * @method
	 * @private
	 * @return {Boolean} - If the currently deref'd model is still considered a
	 * valid deref.
	 */
	Model.prototype._hasValidParentReference = __webpack_require__(395);
	
	/**
	 * Get data for a single {@link Path}.
	 * @param {Path} path - the path to retrieve
	 * @return {Observable.<*>} - the value for the path
	 * @example
	 var model = new falcor.Model({source: new falcor.HttpDataSource("/model.json") });
	
	 model.
	     getValue('user.name').
	     subscribe(function(name) {
	         console.log(name);
	     });
	
	 // The code above prints "Jim" to the console.
	 */
	Model.prototype.getValue = __webpack_require__(396);
	
	/**
	 * Set value for a single {@link Path}.
	 * @param {Path} path - the path to set
	 * @param {Object} value - the value to set
	 * @return {Observable.<*>} - the value for the path
	 * @example
	 var model = new falcor.Model({source: new falcor.HttpDataSource("/model.json") });
	
	 model.
	     setValue('user.name', 'Jim').
	     subscribe(function(name) {
	         console.log(name);
	     });
	
	 // The code above prints "Jim" to the console.
	 */
	Model.prototype.setValue = __webpack_require__(397);
	
	// TODO: Does not throw if given a PathSet rather than a Path, not sure if it should or not.
	// TODO: Doc not accurate? I was able to invoke directly against the Model, perhaps because I don't have a data source?
	// TODO: Not clear on what it means to "retrieve objects in addition to JSONGraph values"
	/**
	 * Synchronously retrieves a single path from the local {@link Model} only and will not retrieve missing paths from the {@link DataSource}. This method can only be invoked when the {@link Model} does not have a {@link DataSource} or from within a selector function. See {@link Model.prototype.get}. The getValueSync method differs from the asynchronous get methods (ex. get, getValues) in that it can be used to retrieve objects in addition to JSONGraph values.
	 * @method
	 * @private
	 * @arg {Path} path - the path to retrieve
	 * @return {*} - the value for the specified path
	 */
	Model.prototype._getValueSync = __webpack_require__(398);
	
	/**
	 * @private
	 */
	Model.prototype._setValueSync = __webpack_require__(399);
	
	/**
	 * @private
	 */
	Model.prototype._derefSync = __webpack_require__(400);
	
	/**
	 * Set the local cache to a {@link JSONGraph} fragment. This method can be a useful way of mocking a remote document, or restoring the local cache from a previously stored state.
	 * @param {JSONGraph} jsonGraph - the {@link JSONGraph} fragment to use as the local cache
	 */
	Model.prototype.setCache = function modelSetCache(cacheOrJSONGraphEnvelope) {
	    var cache = this._root.cache;
	    if (cacheOrJSONGraphEnvelope !== cache) {
	        var modelRoot = this._root;
	        var boundPath = this._path;
	        this._path = [];
	        this._root.cache = {};
	        if (typeof cache !== "undefined") {
	            collectLru(modelRoot, modelRoot.expired, getSize(cache), 0);
	        }
	        if (isJSONGraphEnvelope(cacheOrJSONGraphEnvelope)) {
	            setJSONGraphs(this, [cacheOrJSONGraphEnvelope], promoteLru);
	        } else if (isJSONEnvelope(cacheOrJSONGraphEnvelope)) {
	            setCache(this, [cacheOrJSONGraphEnvelope], promoteLru);
	        } else if (isObject(cacheOrJSONGraphEnvelope)) {
	            setCache(this, [{ json: cacheOrJSONGraphEnvelope }], promoteLru);
	        }
	        this._path = boundPath;
	    } else if (typeof cache === "undefined") {
	        this._root.cache = {};
	    }
	    return this;
	};
	
	/**
	 * Get the local {@link JSONGraph} cache. This method can be a useful to store the state of the cache.
	 * @param {...Array.<PathSet>} [pathSets] - The path(s) to retrieve. If no paths are specified, the entire {@link JSONGraph} is returned.
	 * @return {JSONGraph} all of the {@link JSONGraph} data in the {@link Model} cache.
	 * @example
	 // Storing the boxshot of the first 10 titles in the first 10 genreLists to local storage.
	 localStorage.setItem('cache', JSON.stringify(model.getCache("genreLists[0...10][0...10].boxshot")));
	 */
	Model.prototype.getCache = function _getCache() {
	    var paths = arraySlice(arguments);
	    if (paths.length === 0) {
	        return getCache(this._root.cache);
	    }
	
	    var result = [{}];
	    var path = this._path;
	    get.getWithPathsAsJSONGraph(this, paths, result);
	    this._path = path;
	    return result[0].jsonGraph;
	};
	
	/**
	 * Retrieves a number which is incremented every single time a value is changed underneath the Model or the object at an optionally-provided Path beneath the Model.
	 * @param {Path?} path - a path at which to retrieve the version number
	 * @return {Number} a version number which changes whenever a value is changed underneath the Model or provided Path
	 */
	Model.prototype.getVersion = function getVersion(pathArg) {
	    var path = pathArg && pathSyntax.fromPath(pathArg) || [];
	    if (Array.isArray(path) === false) {
	        throw new Error("Model#getVersion must be called with an Array path.");
	    }
	    if (this._path.length) {
	        path = this._path.concat(path);
	    }
	    return this._getVersion(this, path);
	};
	
	Model.prototype._syncCheck = function syncCheck(name) {
	    if (Boolean(this._source) && this._root.syncRefCount <= 0 && this._root.unsafeMode === false) {
	        throw new Error("Model#" + name + " may only be called within the context of a request selector.");
	    }
	    return true;
	};
	
	/* eslint-disable guard-for-in */
	Model.prototype._clone = function cloneModel(opts) {
	    var clone = new Model(this);
	    for (var key in opts) {
	        var value = opts[key];
	        if (value === "delete") {
	            delete clone[key];
	        } else {
	            clone[key] = value;
	        }
	    }
	    clone.setCache = void 0;
	    return clone;
	};
	/* eslint-enable */
	
	/**
	 * Returns a clone of the {@link Model} that enables batching. Within the configured time period, paths for get operations are collected and sent to the {@link DataSource} in a batch. Batching can be more efficient if the {@link DataSource} access the network, potentially reducing the number of HTTP requests to the server.
	 * @param {?Scheduler|number} schedulerOrDelay - Either a {@link Scheduler} that determines when to send a batch to the {@link DataSource}, or the number in milliseconds to collect a batch before sending to the {@link DataSource}. If this parameter is omitted, then batch collection ends at the end of the next tick.
	 * @return {Model} a Model which schedules a batch of get requests to the DataSource.
	 */
	Model.prototype.batch = function batch(schedulerOrDelayArg) {
	    var schedulerOrDelay = schedulerOrDelayArg;
	    if (typeof schedulerOrDelay === "number") {
	        schedulerOrDelay = new TimeoutScheduler(Math.round(Math.abs(schedulerOrDelay)));
	    } else if (!schedulerOrDelay || !schedulerOrDelay.schedule) {
	        schedulerOrDelay = new ASAPScheduler();
	    }
	    var clone = this._clone();
	    clone._request = new RequestQueue(clone, schedulerOrDelay);
	
	    return clone;
	};
	
	/**
	 * Returns a clone of the {@link Model} that disables batching. This is the default mode. Each get operation will be executed on the {@link DataSource} separately.
	 * @name unbatch
	 * @memberof Model.prototype
	 * @function
	 * @return {Model} a {@link Model} that batches requests of the same type and sends them to the data source together
	 */
	Model.prototype.unbatch = function unbatch() {
	    var clone = this._clone();
	    clone._request = new RequestQueue(clone, new ImmediateScheduler());
	    return clone;
	};
	
	/**
	 * Returns a clone of the {@link Model} that treats errors as values. Errors will be reported in the same callback used to report data. Errors will appear as objects in responses, rather than being sent to the {@link Observable~onErrorCallback} callback of the {@link ModelResponse}.
	 * @return {Model}
	 */
	Model.prototype.treatErrorsAsValues = function treatErrorsAsValues() {
	    return this._clone({
	        _treatErrorsAsValues: true
	    });
	};
	
	/**
	 * Adapts a Model to the {@link DataSource} interface.
	 * @return {DataSource}
	 * @example
	var model =
	    new falcor.Model({
	        cache: {
	            user: {
	                name: "Steve",
	                surname: "McGuire"
	            }
	        }
	    }),
	    proxyModel = new falcor.Model({ source: model.asDataSource() });
	
	// Prints "Steve"
	proxyModel.getValue("user.name").
	    then(function(name) {
	        console.log(name);
	    });
	 */
	Model.prototype.asDataSource = function asDataSource() {
	    return new ModelDataSourceAdapter(this);
	};
	
	Model.prototype._materialize = function materialize() {
	    return this._clone({
	        _materialized: true
	    });
	};
	
	Model.prototype._dematerialize = function dematerialize() {
	    return this._clone({
	        _materialized: "delete"
	    });
	};
	
	/**
	 * Returns a clone of the {@link Model} that boxes values returning the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the value inside it. This allows any metadata attached to the wrapper to be inspected.
	 * @return {Model}
	 */
	Model.prototype.boxValues = function boxValues() {
	    return this._clone({
	        _boxed: true
	    });
	};
	
	/**
	 * Returns a clone of the {@link Model} that unboxes values, returning the value inside of the wrapper ({@link Atom}, {@link Reference}, or {@link Error}), rather than the wrapper itself. This is the default mode.
	 * @return {Model}
	 */
	Model.prototype.unboxValues = function unboxValues() {
	    return this._clone({
	        _boxed: "delete"
	    });
	};
	
	/**
	 * Returns a clone of the {@link Model} that only uses the local {@link JSONGraph} and never uses a {@link DataSource} to retrieve missing paths.
	 * @return {Model}
	 */
	Model.prototype.withoutDataSource = function withoutDataSource() {
	    return this._clone({
	        _source: "delete"
	    });
	};
	
	Model.prototype.toJSON = function toJSON() {
	    return {
	        $type: "ref",
	        value: this._path
	    };
	};
	
	/**
	 * Returns the {@link Path} to the object within the JSON Graph that this Model references.
	 * @return {Path}
	 * @example
	var Model = falcor.Model;
	var model = new Model({
	  cache: {
	    users: [
	      Model.ref(["usersById", 32])
	    ],
	    usersById: {
	      32: {
	        name: "Steve",
	        surname: "McGuire"
	      }
	    }
	  }
	});
	
	model.
	    get(['users', 0, 'name']).
	    subscribe(function(jsonEnv) {
	        var userModel = model.deref(jsonEnv.json.users[0]);
	        console.log(model.getPath());
	        console.log(userModel.getPath());
	   });
	});
	
	// prints the following:
	// []
	// ["usersById", 32] - because userModel refers to target of reference at ["users", 0]
	 */
	Model.prototype.getPath = function getPath() {
	    return arrayClone(this._path);
	};
	
	/**
	 * This one is actually private.  I would not use this without talking to
	 * jhusain, sdesai, or michaelbpaulson (github).
	 * @private
	 */
	Model.prototype._fromWhenceYouCame = function fromWhenceYouCame(allow) {
	    return this._clone({
	        _allowFromWhenceYouCame: allow === undefined ? true : allow
	    });
	};
	
	Model.prototype._getBoundValue = __webpack_require__(355);
	Model.prototype._getVersion = __webpack_require__(401);
	Model.prototype._getValueSync = __webpack_require__(347);
	
	Model.prototype._getPathValuesAsPathMap = get.getWithPathsAsPathMap;
	Model.prototype._getPathValuesAsJSONG = get.getWithPathsAsJSONGraph;
	
	Model.prototype._setPathValues = __webpack_require__(319);
	Model.prototype._setPathMaps = __webpack_require__(381);
	Model.prototype._setJSONGs = __webpack_require__(269);
	Model.prototype._setCache = __webpack_require__(381);
	
	Model.prototype._invalidatePathValues = __webpack_require__(402);
	Model.prototype._invalidatePathMaps = __webpack_require__(403);


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(262);
	var hasOwn = __webpack_require__(248);
	var ImmediateScheduler = __webpack_require__(263);
	
	function ModelRoot(o, topLevelModel) {
	
	    var options = o || {};
	
	    this.version = 0;
	    this.syncRefCount = 0;
	    this.expired = options.expired || [];
	    this.unsafeMode = options.unsafeMode || false;
	    this.collectionScheduler = options.collectionScheduler || new ImmediateScheduler();
	    this.cache = {};
	    this.topLevelModel = topLevelModel;
	
	    if (isFunction(options.comparator)) {
	        this.comparator = options.comparator;
	    }
	
	    if (isFunction(options.errorSelector)) {
	        this.errorSelector = options.errorSelector;
	    }
	
	    if (isFunction(options.onChange)) {
	        this.onChange = options.onChange;
	    }
	
	    if (isFunction(options.onChangesCompleted)) {
	        this.onChangesCompleted = options.onChangesCompleted;
	    }
	}
	
	ModelRoot.prototype.errorSelector = function errorSelector(x, y) {
	    return y;
	};
	ModelRoot.prototype.comparator = function comparator(cacheNode, messageNode) {
	    if (hasOwn(cacheNode, "value") && hasOwn(messageNode, "value")) {
	        // They are the same only if the following fields are the same.
	        return cacheNode.value === messageNode.value &&
	            cacheNode.$type === messageNode.$type &&
	            cacheNode.$expires === messageNode.$expires;
	    }
	    return cacheNode === messageNode;
	};
	
	module.exports = ModelRoot;


/***/ },
/* 262 */
/***/ function(module, exports) {

	var functionTypeof = "function";
	
	module.exports = function isFunction(func) {
	    return Boolean(func) && typeof func === functionTypeof;
	};


/***/ },
/* 263 */
/***/ function(module, exports) {

	var empty = {dispose: function() {}};
	
	function ImmediateScheduler() {}
	
	ImmediateScheduler.prototype.schedule = function schedule(action) {
	    action();
	    return empty;
	};
	
	ImmediateScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
	    action(this, state);
	    return empty;
	};
	
	module.exports = ImmediateScheduler;


/***/ },
/* 264 */
/***/ function(module, exports) {

	function ModelDataSourceAdapter(model) {
	    this._model = model._materialize().boxValues().treatErrorsAsValues();
	}
	
	ModelDataSourceAdapter.prototype.get = function get(pathSets) {
	    return this._model.get.apply(this._model, pathSets)._toJSONG();
	};
	
	ModelDataSourceAdapter.prototype.set = function set(jsongResponse) {
	    return this._model.set(jsongResponse)._toJSONG();
	};
	
	ModelDataSourceAdapter.prototype.call = function call(path, args, suffixes, paths) {
	    var params = [path, args, suffixes].concat(paths);
	    return this._model.call.apply(this._model, params)._toJSONG();
	};
	
	module.exports = ModelDataSourceAdapter;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var RequestTypes = __webpack_require__(266);
	var sendSetRequest = __webpack_require__(267);
	var GetRequest = __webpack_require__(329);
	var falcorPathUtils = __webpack_require__(282);
	
	/**
	 * The request queue is responsible for queuing the operations to
	 * the model"s dataSource.
	 *
	 * @param {Model} model -
	 * @param {Scheduler} scheduler -
	 */
	function RequestQueueV2(model, scheduler) {
	    this.model = model;
	    this.scheduler = scheduler;
	    this.requests = this._requests = [];
	}
	
	RequestQueueV2.prototype = {
	    /**
	     * Sets the scheduler, but will not affect any current requests.
	     */
	    setScheduler: function(scheduler) {
	        this.scheduler = scheduler;
	    },
	
	    /**
	     * performs a set against the dataSource.  Sets, though are not batched
	     * currently could be batched potentially in the future.  Since no batching
	     * is required the setRequest action is simplified significantly.
	     *
	     * @param {JSONGraphEnvelope) jsonGraph -
	     */
	    set: function(jsonGraph, cb) {
	        jsonGraph.paths = falcorPathUtils.collapse(jsonGraph.paths);
	        return sendSetRequest(jsonGraph, this.model, cb);
	    },
	
	    /**
	     * Creates a get request to the dataSource.  Depending on the current
	     * scheduler is how the getRequest will be flushed.
	     * @param {Array} requestedPaths -
	     * @param {Array} optimizedPaths -
	     * @param {Function} cb -
	     */
	    get: function(requestedPaths, optimizedPaths, cb) {
	        var self = this;
	        var disposables = [];
	        var count = 0;
	        var requests = self._requests;
	        var i, len;
	        var oRemainingPaths = optimizedPaths;
	        var rRemainingPaths = requestedPaths;
	        var disposed = false;
	        var request;
	
	        for (i = 0, len = requests.length; i < len; ++i) {
	            request = requests[i];
	            if (request.type !== RequestTypes.GetRequest) {
	                continue;
	            }
	
	            // The request has been sent, attempt to jump on the request
	            // if possible.
	            if (request.sent) {
	                var results = request.add(
	                    rRemainingPaths, oRemainingPaths, refCountCallback);
	
	                // Checks to see if the results were successfully inserted
	                // into the outgoing results.  Then our paths will be reduced
	                // to the complement.
	                if (results[0]) {
	                    rRemainingPaths = results[1];
	                    oRemainingPaths = results[2];
	                    disposables[disposables.length] = results[3];
	                    ++count;
	                }
	            }
	
	            // If there is a non sent request, then we can batch and leave.
	            else {
	                request.batch(
	                    rRemainingPaths, oRemainingPaths, refCountCallback);
	                oRemainingPaths = [];
	                rRemainingPaths = [];
	                ++count;
	            }
	
	            // If there are no more remaining paths then exit the loop.
	            if (!oRemainingPaths.length) {
	                break;
	            }
	        }
	
	        // After going through all the available requests if there are more
	        // paths to process then a new request must be made.
	        if (oRemainingPaths.length) {
	            request = new GetRequest(self.scheduler, self);
	            requests[requests.length] = request;
	            ++count;
	            var disposable = request.batch(
	                rRemainingPaths, oRemainingPaths, refCountCallback);
	            disposables[disposables.length] = disposable;
	        }
	
	        // This is a simple refCount callback.
	        function refCountCallback(err) {
	            if (disposed) {
	                return;
	            }
	
	            --count;
	
	            // If the count becomes 0, then its time to notify the
	            // listener that the request is done.
	            if (count === 0) {
	                cb(err);
	            }
	        }
	
	        // When disposing the request all of the outbound requests will be
	        // disposed of.
	        return function() {
	            if (disposed || count === 0) {
	                return;
	            }
	
	            disposed = true;
	            var length = disposables.length;
	            for (var idx = 0; idx < length; ++idx) {
	                disposables[idx]();
	            }
	        };
	    },
	
	    /**
	     * Removes the request from the request
	     */
	    removeRequest: function(request) {
	        var requests = this._requests;
	        var i = requests.length;
	        while (--i >= 0) {
	            if (requests[i].id === request.id) {
	                requests.splice(i, 1);
	                break;
	            }
	        }
	    }
	};
	
	module.exports = RequestQueueV2;


/***/ },
/* 266 */
/***/ function(module, exports) {

	module.exports = {
	    GetRequest: "GET"
	};


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(268);
	var setJSONGraphs = __webpack_require__(269);
	var setPathValues = __webpack_require__(319);
	var InvalidSourceError = __webpack_require__(328);
	
	var emptyArray = [];
	var emptyDisposable = {dispose: function() {}};
	
	/**
	 * A set request is not an object like GetRequest.  It simply only needs to
	 * close over a couple values and its never batched together (at least not now).
	 *
	 * @private
	 * @param {JSONGraphEnvelope} jsonGraph -
	 * @param {Model} model -
	 * @param {Function} callback -
	 */
	var sendSetRequest = function(originalJsonGraph, model, callback) {
	    var paths = originalJsonGraph.paths;
	    var modelRoot = model._root;
	    var errorSelector = modelRoot.errorSelector;
	    var comparator = modelRoot.comparator;
	    var boundPath = model._path;
	    var resultingJsonGraphEnvelope;
	
	    // This is analogous to GetRequest _merge / flushGetRequest
	    // SetRequests are just considerably simplier.
	    var setObservable;
	    try {
	        setObservable = model._source.
	            set(originalJsonGraph);
	    } catch (e) {
	        callback(new InvalidSourceError());
	        return emptyDisposable;
	    }
	
	    var disposable = setObservable.
	        subscribe(function onNext(jsonGraphEnvelope) {
	            // When disposed, no data is inserted into.  This can sync resolve
	            // and if thats the case then its undefined.
	            if (disposable && disposable.disposed) {
	                return;
	            }
	
	            // onNext will insert all data into the model then save the json
	            // envelope from the incoming result.
	            model._path = emptyArray;
	
	            var successfulPaths = setJSONGraphs(model, [{
	                paths: paths,
	                jsonGraph: jsonGraphEnvelope.jsonGraph
	            }], null, errorSelector, comparator);
	
	            jsonGraphEnvelope.paths = successfulPaths[1];
	
	            model._path = boundPath;
	            resultingJsonGraphEnvelope = jsonGraphEnvelope;
	        }, function onError(dataSourceError) {
	            if (disposable && disposable.disposed) {
	                return;
	            }
	            model._path = emptyArray;
	
	            setPathValues(model, arrayMap(paths, function(path) {
	                return {
	                    path: path,
	                    value: dataSourceError
	                };
	            }), null, errorSelector, comparator);
	
	            model._path = boundPath;
	
	            callback(dataSourceError);
	        }, function onCompleted() {
	            callback(null, resultingJsonGraphEnvelope);
	        });
	
	    return disposable;
	};
	
	module.exports = sendSetRequest;


/***/ },
/* 268 */
/***/ function(module, exports) {

	module.exports = function arrayMap(array, selector) {
	    var i = -1;
	    var n = array.length;
	    var array2 = new Array(n);
	    while (++i < n) {
	        array2[i] = selector(array[i], i, array);
	    }
	    return array2;
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setJSONGraphs;
	
	var isFunction = __webpack_require__(262);
	var setGraphPath = __webpack_require__(270);
	var BoundJSONGraphModelError = __webpack_require__(318);
	
	/**
	 * Merges a list of {@link JSONGraphEnvelope}s into a {@link JSONGraph}.
	 * @function
	 * @param {Object} model - the Model for which to merge the {@link JSONGraphEnvelope}s.
	 * @param {Array.<PathValue>} jsonGraphEnvelopes - the {@link JSONGraphEnvelope}s to merge.
	 * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.
	 */
	
	function setJSONGraphs(model, jsonGraphEnvelopes, promote, errorSelector, comparator) {
	
	    var _root = model._root;
	    var bound = model._path;
	    var cache = _root.cache;
	
	    // If the model is bound, then get that cache position.
	    if (bound.length) {
	        // JSONGraph output cannot ever be bound or else it will
	        // throw an error.
	        return {
	            criticalError: new BoundJSONGraphModelError()
	        };
	    }
	
	    var expired = _root.expired;
	    var version = _root.version++;
	    var initialVersion = cache.ツversion;
	
	    var requestedPath = [];
	    var optimizedPath = [];
	    var requestedPaths = [];
	    var optimizedPaths = [];
	    var jsonGraphEnvelopeIndex = -1;
	    var jsonGraphEnvelopeCount = jsonGraphEnvelopes.length;
	
	    while (++jsonGraphEnvelopeIndex < jsonGraphEnvelopeCount) {
	
	        var jsonGraphEnvelope = jsonGraphEnvelopes[jsonGraphEnvelopeIndex];
	        var paths = jsonGraphEnvelope.paths;
	        var jsonGraph = jsonGraphEnvelope.jsonGraph;
	
	        var pathIndex = -1;
	        var pathCount = paths.length;
	
	        while (++pathIndex < pathCount) {
	
	            var path = paths[pathIndex];
	
	            setGraphPath(path, 0, cache, cache, cache,
	                         jsonGraph, jsonGraph, jsonGraph,
	                         requestedPath, 0, optimizedPath, 0,
	                         requestedPaths, optimizedPaths,
	                         comparator, errorSelector,
	                         version, expired, _root, promote);
	        }
	    }
	
	    var newVersion = cache.ツversion;
	    var rootChangeHandler = _root.onChange;
	
	    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
	        rootChangeHandler(_root.topLevelModel);
	    }
	
	    return [requestedPaths, optimizedPaths];
	}


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setGraphPath;
	
	var setGraphNode = __webpack_require__(271);
	var iterateKeySet = __webpack_require__(282).iterateKeySet;
	
	/* eslint-disable no-constant-condition */
	function setGraphPath(path, depth, root, parent, node,
	                      messageRoot, messageParent, message,
	                      requestedPath, requestedPathDepth,
	                      optimizedPath, optimizedPathDepth,
	                      requestedPaths, optimizedPaths,
	                      comparator, errorSelector,
	                      version, expired, lru, promote) {
	
	    var nextDepth = depth + 1;
	    var branch = nextDepth < path.length;
	    var nextRequestedPathDepth = requestedPathDepth + 1;
	
	    var note;
	    var keyset = path[depth];
	    var key = keyset && typeof keyset === 'object' ?
	        iterateKeySet(keyset, note = {}) : keyset;
	
	    do {
	
	        var results = setGraphNode(key, branch, false, null, root, parent, node,
	                                   messageRoot, messageParent, message,
	                                   requestedPath, requestedPathDepth,
	                                   optimizedPath, optimizedPathDepth,
	                                   comparator, errorSelector,
	                                   version, expired, lru, promote);
	
	        var nextIndex = 0;
	        var nextLength = results.length;
	
	        do {
	            var nextNode = results[nextIndex];
	            var nextParent = results[nextIndex + 1];
	            var nextMessage = results[nextIndex + 2];
	            var nextMessageParent = results[nextIndex + 3];
	            var nextOptimizedPath = results[nextIndex + 4];
	            var nextOptimizedPathDepth = results[nextIndex + 5];
	            nextIndex += 6;
	            if (nextNode) {
	                if (branch) {
	                    setGraphPath(path, nextDepth, root, nextParent, nextNode,
	                                 messageRoot, nextMessageParent, nextMessage,
	                                 requestedPath, nextRequestedPathDepth,
	                                 nextOptimizedPath, nextOptimizedPathDepth,
	                                 requestedPaths, optimizedPaths,
	                                 comparator, errorSelector,
	                                 version, expired, lru, promote);
	                } else {
	                    requestedPaths.push(requestedPath.slice(0, nextRequestedPathDepth));
	                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPathDepth));
	                }
	            }
	        } while (nextIndex < nextLength);
	
	        if (note) {
	            key = iterateKeySet(keyset, note);
	            continue;
	        }
	        break;
	    } while (!note.done);
	}
	/* eslint-enable */
	


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setGraphNode;
	
	var $ref = __webpack_require__(272);
	var isExpired = __webpack_require__(273);
	var expireNode = __webpack_require__(277);
	var setGraphRef = __webpack_require__(279);
	var __innerRefs = __webpack_require__(293);
	var __refTarget = __webpack_require__(280);
	var NullInPathError = __webpack_require__(297);
	var assignCrossedRefs = __webpack_require__(298);
	var mergeJSONGraphNode = __webpack_require__(299);
	
	/* eslint-disable no-constant-condition, no-eq-null */
	function setGraphNode(key, branch, reference,
	                      innerRefs, root, parent, node,
	                      messageRoot, messageParent, message,
	                      requestedPath, requestedPathDepth,
	                      optimizedPath, optimizedPathDepth,
	                      comparator, errorSelector,
	                      version, expired, lru, promote) {
	
	    var results = [];
	    var refsIndex = 0;
	    var refsCount = 0;
	    var resultsIndex = 0;
	    var refs, refPathSet;
	
	    do {
	        if (node) {
	            var type = node.$type;
	            if (type === $ref) {
	                if (isExpired(node)) {
	                    expireNode(node, expired, lru);
	                    results[resultsIndex    ] = undefined;
	                    results[resultsIndex + 1] = root;
	                    results[resultsIndex + 2] = message;
	                    results[resultsIndex + 3] = messageRoot;
	                    results[resultsIndex + 4] = node.value.slice(0);
	                    results[resultsIndex + 5] = node.value.length;
	                    resultsIndex += 6;
	                } else {
	
	                    assignCrossedRefs(node, innerRefs, reference, lru, promote);
	
	                    setGraphRef(refs || (refs = []),
	                                node, node.value, 0, root, root, root,
	                                messageRoot, messageRoot, messageRoot,
	                                node[__innerRefs] || {}, node[__refTarget],
	                                requestedPath, requestedPathDepth, [], 0,
	                                comparator, errorSelector, version, expired, lru, promote);
	
	                    refsCount = refs.length;
	                }
	            } else if (type) {
	                results[resultsIndex    ] = node;
	                results[resultsIndex + 1] = parent;
	                results[resultsIndex + 2] = message;
	                results[resultsIndex + 3] = messageParent;
	                results[resultsIndex + 4] = optimizedPath;
	                results[resultsIndex + 5] = optimizedPathDepth;
	                resultsIndex += 6;
	            } else {
	                if (key == null) {
	                    if (branch) {
	                        throw new NullInPathError();
	                    } else {
	                        key = node.ツkey;
	                    }
	                } else {
	                    if (!reference) {
	                        requestedPath[requestedPathDepth] = key;
	                    }
	                    parent = node;
	                    node = parent[key];
	                    messageParent = message;
	                    message = messageParent && messageParent[key];
	                    optimizedPath[optimizedPathDepth] = key;
	                }
	
	                node = mergeJSONGraphNode(
	                    parent, node, message, key,
	                    requestedPath, requestedPathDepth,
	                    optimizedPath, optimizedPathDepth,
	                    version, expired, lru, promote, comparator, errorSelector
	                );
	
	                results[resultsIndex    ] = node;
	                results[resultsIndex + 1] = parent;
	                results[resultsIndex + 2] = message;
	                results[resultsIndex + 3] = messageParent;
	                results[resultsIndex + 4] = optimizedPath;
	                results[resultsIndex + 5] = optimizedPathDepth + 1;
	                resultsIndex += 6;
	            }
	        }
	
	        if (refsIndex < refsCount) {
	            node = refs[refsIndex];
	            parent = refs[refsIndex + 1];
	            message = refs[refsIndex + 2];
	            messageParent = refs[refsIndex + 3];
	            innerRefs     = refs[refsIndex + 4];
	            optimizedPath = refs[refsIndex + 5];
	            optimizedPathDepth = optimizedPath.length;
	            refsIndex += 6;
	            continue;
	        }
	        break;
	    } while (true);
	
	    return results;
	}
	/* eslint-enable */
	


/***/ },
/* 272 */
/***/ function(module, exports) {

	module.exports = "ref";


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	var now = __webpack_require__(274);
	var $now = __webpack_require__(275);
	var $never = __webpack_require__(276);
	
	module.exports = function isAlreadyExpired(node) {
	    var exp = node.$expires;
	    return (exp != null) && (
	        exp !== $never) && (
	        exp !== $now) && (
	        exp < now());
	};


/***/ },
/* 274 */
/***/ function(module, exports) {

	module.exports = Date.now;


/***/ },
/* 275 */
/***/ function(module, exports) {

	module.exports = 0;


/***/ },
/* 276 */
/***/ function(module, exports) {

	module.exports = 1;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var splice = __webpack_require__(278);
	
	module.exports = function expireNode(node, expired, lru) {
	    if (!node.ツinvalidated) {
	        node.ツinvalidated = true;
	        expired.push(node);
	        splice(lru, node);
	    }
	    return node;
	};


/***/ },
/* 278 */
/***/ function(module, exports) {

	module.exports = function lruSplice(root, object) {
	
	    // Its in the cache.  Splice out.
	    var prev = object.ツprev;
	    var next = object.ツnext;
	    if (next) {
	        next.ツprev = prev;
	    }
	    if (prev) {
	        prev.ツnext = next;
	    }
	    object.ツprev = object.ツnext = undefined;
	
	    if (object === root.ツhead) {
	        root.ツhead = next;
	    }
	    if (object === root.ツtail) {
	        root.ツtail = prev;
	    }
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setGraphRef;
	
	var setGraphNode = __webpack_require__(271);
	var __refTarget = __webpack_require__(280);
	var iterateKeySet = __webpack_require__(282).iterateKeySet;
	var assignRefTargets = __webpack_require__(291);
	
	function setGraphRef(refs, ref, path, depth, root, parent, node,
	                     messageRoot, messageParent, message, innerRefs, refTarget,
	                     requestedPath, requestedPathDepth,
	                     optimizedPath, optimizedPathDepth,
	                     comparator, errorSelector,
	                     version, expired, lru, promote) {
	
	    var nextDepth = depth + 1;
	    var branch = nextDepth < path.length;
	    var nextRequestedPathDepth = requestedPathDepth + 1;
	
	    var note;
	    var keyset = path[depth];
	    var key = keyset && typeof keyset === 'object' ?
	        iterateKeySet(keyset, note = {}) : keyset;
	
	    if (note && typeof refTarget !== 'object') {
	        ref[__refTarget] = refTarget = [];
	    }
	
	    do {
	
	        var results = setGraphNode(key, branch, ref, innerRefs, root, parent, node,
	                                   messageRoot, messageParent, message,
	                                   requestedPath, requestedPathDepth,
	                                   optimizedPath, optimizedPathDepth,
	                                   comparator, errorSelector,
	                                   version, expired, lru, promote);
	
	        var nextIndex = 0;
	        var nextLength = results.length;
	        var nextRefTarget = refTarget;
	
	        if (note && note.isArray && note.loaded) {
	            var nextRefTargetIndex = note.arrayOffset;
	            nextRefTarget = refTarget[nextRefTargetIndex] || (
	                refTarget[nextRefTargetIndex] = []);
	        }
	
	        do {
	            var nextNode = results[nextIndex   ];
	            var nextParent = results[nextIndex + 1];
	            var nextMessage = results[nextIndex + 2];
	            var nextMessageParent = results[nextIndex + 3];
	            var nextOptimizedPath = results[nextIndex + 4];
	            var nextOptimizedPathDepth = results[nextIndex + 5];
	            nextIndex += 6;
	            if (nextNode) {
	                if (branch) {
	                    setGraphRef(refs, ref, path, nextDepth,
	                                root, nextParent, nextNode,
	                                messageRoot, nextMessageParent, nextMessage,
	                                innerRefs, nextRefTarget,
	                                requestedPath, nextRequestedPathDepth,
	                                nextOptimizedPath, nextOptimizedPathDepth,
	                                comparator, errorSelector,
	                                version, expired, lru, promote);
	                } else {
	
	                    // assignRefTargets(nextNode, innerRefs, ref, nextRefTarget);
	
	                    var refsIndex = refs.length;
	                    refs[refsIndex] = nextNode;
	                    refs[refsIndex + 1] = nextParent;
	                    refs[refsIndex + 2] = nextMessage;
	                    refs[refsIndex + 3] = nextMessageParent;
	                    refs[refsIndex + 4] = innerRefs;
	                    refs[refsIndex + 5] = nextOptimizedPath.slice(0, nextOptimizedPathDepth);
	                    refsIndex += 6;
	                }
	            }
	        } while (nextIndex < nextLength);
	
	        if (note) {
	            key = iterateKeySet(keyset, note);
	            continue;
	        }
	        break;
	    } while (!note.done);
	}


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "refTarget";


/***/ },
/* 281 */
/***/ function(module, exports) {

	module.exports = "ツ";
	


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    iterateKeySet: __webpack_require__(283),
	    toTree: __webpack_require__(284),
	    toTreeWithUnion: __webpack_require__(285),
	    pathsComplementFromTree: __webpack_require__(286),
	    pathsComplementFromLengthTree: __webpack_require__(288),
	    hasIntersection: __webpack_require__(287),
	    toPaths: __webpack_require__(289),
	    collapse: __webpack_require__(290)
	};


/***/ },
/* 283 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	
	/**
	 * Takes in a keySet and a note attempts to iterate over it.
	 * If the value is a primitive, the key will be returned and the note will
	 * be marked done
	 * If the value is an object, then each value of the range will be returned
	 * and when finished the note will be marked done.
	 * If the value is an array, each value will be iterated over, if any of the
	 * inner values are ranges, those will be iterated over.  When fully done,
	 * the note will be marked done.
	 *
	 * @param {Object|Array|String|Number} keySet -
	 * @param {Object} note - The non filled note
	 * @returns {String|Number|undefined} - The current iteration value.
	 * If undefined, then the keySet is empty
	 * @public
	 */
	module.exports = function iterateKeySet(keySet, note) {
	    if (note.isArray === undefined) {
	        initializeNote(keySet, note);
	    }
	
	    // Array iteration
	    if (note.isArray) {
	        var nextValue;
	
	        // Cycle through the array and pluck out the next value.
	        do {
	            if (note.loaded && note.rangeOffset > note.to) {
	                ++note.arrayOffset;
	                note.loaded = false;
	            }
	
	            var idx = note.arrayOffset, length = keySet.length;
	            if (idx >= length) {
	                note.done = true;
	                break;
	            }
	
	            var el = keySet[note.arrayOffset];
	            var type = typeof el;
	
	            // Inner range iteration.
	            if (type === 'object') {
	                if (!note.loaded) {
	                    initializeRange(el, note);
	                }
	
	                // Empty to/from
	                if (note.empty) {
	                    continue;
	                }
	
	                nextValue = note.rangeOffset++;
	            }
	
	            // Primitive iteration in array.
	            else {
	                ++note.arrayOffset;
	                nextValue = el;
	            }
	        } while (nextValue === undefined);
	
	        return nextValue;
	    }
	
	    // Range iteration
	    else if (note.isObject) {
	        if (!note.loaded) {
	            initializeRange(keySet, note);
	        }
	        if (note.rangeOffset > note.to) {
	            note.done = true;
	            return undefined;
	        }
	
	        return note.rangeOffset++;
	    }
	
	    // Primitive value
	    else {
	        note.done = true;
	        return keySet;
	    }
	};
	
	function initializeRange(key, memo) {
	    var from = memo.from = key.from || 0;
	    var to = memo.to = key.to ||
	        (typeof key.length === 'number' &&
	        memo.from + key.length - 1 || 0);
	    memo.rangeOffset = memo.from;
	    memo.loaded = true;
	    if (from > to) {
	        memo.empty = true;
	    }
	}
	
	function initializeNote(key, note) {
	    note.done = false;
	    var isObject = note.isObject = !!(key && typeof key === 'object');
	    note.isArray = isObject && isArray(key);
	    note.arrayOffset = 0;
	}


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(283);
	var isArray = Array.isArray;
	
	/**
	 * @param {Array} paths -
	 * @returns {Object} -
	 */
	module.exports = function toTree(paths) {
	    return paths.reduce(function(acc, path) {
	        innerToTree(acc, path, 0);
	        return acc;
	    }, {});
	};
	
	function innerToTree(seed, path, depth) {
	
	    var keySet = path[depth];
	    var iteratorNote = {};
	    var key;
	    var nextDepth = depth + 1;
	
	    key = iterateKeySet(keySet, iteratorNote);
	
	    do {
	
	        var next = seed[key];
	        if (!next) {
	            if (nextDepth === path.length) {
	                seed[key] = null;
	            } else {
	                next = seed[key] = {};
	            }
	        }
	
	        if (nextDepth < path.length) {
	            innerToTree(next, path, nextDepth);
	        }
	
	        if (!iteratorNote.done) {
	            key = iterateKeySet(keySet, iteratorNote);
	        }
	    } while (!iteratorNote.done);
	}
	


/***/ },
/* 285 */
/***/ function(module, exports) {



/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	var hasIntersection = __webpack_require__(287);
	
	/**
	 * Compares the paths passed in with the tree.  Any of the paths that are in
	 * the tree will be stripped from the paths.
	 *
	 * **Does not mutate** the incoming paths object.
	 * **Proper subset** only matching.
	 *
	 * @param {Array} paths - A list of paths (complex or simple) to strip the
	 * intersection
	 * @param {Object} tree -
	 * @public
	 */
	module.exports = function pathsComplementFromTree(paths, tree) {
	    var out = [];
	    var outLength = -1;
	
	    for (var i = 0, len = paths.length; i < len; ++i) {
	        // If this does not intersect then add it to the output.
	        if (!hasIntersection(tree, paths[i], 0)) {
	            out[++outLength] = paths[i];
	        }
	    }
	    return out;
	};
	


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	var iterateKeySet = __webpack_require__(283);
	
	/**
	 * Tests to see if the intersection should be stripped from the
	 * total paths.  The only way this happens currently is if the entirety
	 * of the path is contained in the tree.
	 * @private
	 */
	module.exports = function hasIntersection(tree, path, depth) {
	    var current = tree;
	    var intersects = true;
	
	    // Continue iteratively going down a path until a complex key is
	    // encountered, then recurse.
	    for (;intersects && depth < path.length; ++depth) {
	        var key = path[depth];
	        var keyType = typeof key;
	
	        // We have to iterate key set
	        if (key && keyType === 'object') {
	            var note = {};
	            var innerKey = iterateKeySet(key, note);
	            var nextDepth = depth + 1;
	
	            // Loop through the innerKeys setting the intersects flag
	            // to each result.  Break out on false.
	            do {
	                var next = current[innerKey];
	                intersects = next !== undefined;
	
	                if (intersects) {
	                    intersects = hasIntersection(next, path, nextDepth);
	                }
	                innerKey = iterateKeySet(key, note);
	            } while (intersects && !note.done);
	
	            // Since we recursed, we shall not pass any further!
	            break;
	        }
	
	        // Its a simple key, just move forward with the testing.
	        current = current[key];
	        intersects = current !== undefined;
	    }
	
	    return intersects;
	};


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var hasIntersection = __webpack_require__(287);
	
	/**
	 * Compares the paths passed in with the tree.  Any of the paths that are in
	 * the tree will be stripped from the paths.
	 *
	 * **Does not mutate** the incoming paths object.
	 * **Proper subset** only matching.
	 *
	 * @param {Array} paths - A list of paths (complex or simple) to strip the
	 * intersection
	 * @param {Object} tree -
	 * @public
	 */
	module.exports = function pathsComplementFromLengthTree(paths, tree) {
	    var out = [];
	    var outLength = -1;
	
	    for (var i = 0, len = paths.length; i < len; ++i) {
	        // If this does not intersect then add it to the output.
	        var path = paths[i];
	        if (!hasIntersection(tree[path.length], path, 0)) {
	            out[++outLength] = path;
	        }
	    }
	    return out;
	};
	


/***/ },
/* 289 */
/***/ function(module, exports) {

	var isArray = Array.isArray;
	var typeOfObject = "object";
	
	/* jshint forin: false */
	module.exports = function toPaths(lengths) {
	    var pathmap;
	    var allPaths = [];
	    var allPathsLength = 0;
	    for (var length in lengths) {
	        if (isNumber(length) && isObject(pathmap = lengths[length])) {
	            var paths = collapsePathMap(pathmap, 0, parseInt(length, 10)).sets;
	            var pathsIndex = -1;
	            var pathsCount = paths.length;
	            while (++pathsIndex < pathsCount) {
	                allPaths[allPathsLength++] = collapsePathSetIndexes(paths[pathsIndex]);
	            }
	        }
	    }
	    return allPaths;
	};
	
	function isObject(value) {
	    return value !== null && typeof value === typeOfObject;
	}
	
	function collapsePathMap(pathmap, depth, length) {
	
	    var key;
	    var code = getHashCode(String(depth));
	    var subs = Object.create(null);
	
	    var codes = [];
	    var codesIndex = -1;
	    var codesCount = 0;
	
	    var pathsets = [];
	    var pathsetsCount = 0;
	
	    var subPath, subCode,
	        subKeys, subKeysIndex, subKeysCount,
	        subSets, subSetsIndex, subSetsCount,
	        pathset, pathsetIndex, pathsetCount,
	        firstSubKey, pathsetClone;
	
	    subKeys = [];
	    subKeysIndex = -1;
	
	    if (depth < length - 1) {
	
	        subKeysCount = getSortedKeys(pathmap, subKeys);
	
	        while (++subKeysIndex < subKeysCount) {
	            key = subKeys[subKeysIndex];
	            subPath = collapsePathMap(pathmap[key], depth + 1, length);
	            subCode = subPath.code;
	            if(subs[subCode]) {
	                subPath = subs[subCode];
	            } else {
	                codes[codesCount++] = subCode;
	                subPath = subs[subCode] = {
	                    keys: [],
	                    sets: subPath.sets
	                };
	            }
	            code = getHashCode(code + key + subCode);
	
	            isNumber(key) &&
	                subPath.keys.push(parseInt(key, 10)) ||
	                subPath.keys.push(key);
	        }
	
	        while(++codesIndex < codesCount) {
	
	            key = codes[codesIndex];
	            subPath = subs[key];
	            subKeys = subPath.keys;
	            subKeysCount = subKeys.length;
	
	            if (subKeysCount > 0) {
	
	                subSets = subPath.sets;
	                subSetsIndex = -1;
	                subSetsCount = subSets.length;
	                firstSubKey = subKeys[0];
	
	                while (++subSetsIndex < subSetsCount) {
	
	                    pathset = subSets[subSetsIndex];
	                    pathsetIndex = -1;
	                    pathsetCount = pathset.length;
	                    pathsetClone = new Array(pathsetCount + 1);
	                    pathsetClone[0] = subKeysCount > 1 && subKeys || firstSubKey;
	
	                    while (++pathsetIndex < pathsetCount) {
	                        pathsetClone[pathsetIndex + 1] = pathset[pathsetIndex];
	                    }
	
	                    pathsets[pathsetsCount++] = pathsetClone;
	                }
	            }
	        }
	    } else {
	        subKeysCount = getSortedKeys(pathmap, subKeys);
	        if (subKeysCount > 1) {
	            pathsets[pathsetsCount++] = [subKeys];
	        } else {
	            pathsets[pathsetsCount++] = subKeys;
	        }
	        while (++subKeysIndex < subKeysCount) {
	            code = getHashCode(code + subKeys[subKeysIndex]);
	        }
	    }
	
	    return {
	        code: code,
	        sets: pathsets
	    };
	}
	
	function collapsePathSetIndexes(pathset) {
	
	    var keysetIndex = -1;
	    var keysetCount = pathset.length;
	
	    while (++keysetIndex < keysetCount) {
	        var keyset = pathset[keysetIndex];
	        if (isArray(keyset)) {
	            pathset[keysetIndex] = collapseIndex(keyset);
	        }
	    }
	
	    return pathset;
	}
	
	/**
	 * Collapse range indexers, e.g. when there is a continuous
	 * range in an array, turn it into an object instead:
	 *
	 * [1,2,3,4,5,6] => {"from":1, "to":6}
	 *
	 * @private
	 */
	function collapseIndex(keyset) {
	
	    // Do we need to dedupe an indexer keyset if they're duplicate consecutive integers?
	    // var hash = {};
	    var keyIndex = -1;
	    var keyCount = keyset.length - 1;
	    var isSparseRange = keyCount > 0;
	
	    while (++keyIndex <= keyCount) {
	
	        var key = keyset[keyIndex];
	
	        if (!isNumber(key) /* || hash[key] === true*/ ) {
	            isSparseRange = false;
	            break;
	        }
	        // hash[key] = true;
	        // Cast number indexes to integers.
	        keyset[keyIndex] = parseInt(key, 10);
	    }
	
	    if (isSparseRange === true) {
	
	        keyset.sort(sortListAscending);
	
	        var from = keyset[0];
	        var to = keyset[keyCount];
	
	        // If we re-introduce deduped integer indexers, change this comparson to "===".
	        if (to - from <= keyCount) {
	            return {
	                from: from,
	                to: to
	            };
	        }
	    }
	
	    return keyset;
	}
	
	function sortListAscending(a, b) {
	    return a - b;
	}
	
	/* jshint forin: false */
	function getSortedKeys(map, keys, sort) {
	    var len = 0;
	    for (var key in map) {
	        keys[len++] = key;
	    }
	    if (len > 1) {
	        keys.sort(sort);
	    }
	    return len;
	}
	
	function getHashCode(key) {
	    var code = 5381;
	    var index = -1;
	    var count = key.length;
	    while (++index < count) {
	        code = (code << 5) + code + key.charCodeAt(index);
	    }
	    return String(code);
	}
	
	/**
	 * Return true if argument is a number or can be cast to a number
	 * @private
	 */
	function isNumber(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var toPaths = __webpack_require__(289);
	var toTree = __webpack_require__(284);
	
	module.exports = function collapse(paths) {
	    var collapseMap = paths.
	        reduce(function(acc, path) {
	            var len = path.length;
	            if (!acc[len]) {
	                acc[len] = [];
	            }
	            acc[len].push(path);
	            return acc;
	        }, {});
	
	    Object.
	        keys(collapseMap).
	        forEach(function(collapseKey) {
	            collapseMap[collapseKey] = toTree(collapseMap[collapseKey]);
	        });
	
	    return toPaths(collapseMap);
	};


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var __id = __webpack_require__(292);
	var __innerRefs = __webpack_require__(293);
	var __priorRefs = __webpack_require__(294);
	var createUniqueNodeId = __webpack_require__(295);
	var __priorRefsContainer = __webpack_require__(296);
	
	module.exports = function assignRefTargets(node, nodeKey, innerRefs, ref, refTarget) {
	
	    var refId = ref[__id];
	    var nodeId = node[__id] || (node[__id] = createUniqueNodeId(node));
	    var priorRefs = node[__priorRefs] || (node[__priorRefs] = {});
	
	    refTarget[nodeKey] = nodeId;
	
	    priorRefs[refId] = ref;
	    innerRefs[nodeId] = node;
	    ref[__innerRefs] = innerRefs;
	};


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "id";


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "innerRefs";


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "priorRefs";


/***/ },
/* 295 */
/***/ function(module, exports) {

	var globalCount = 0;
	module.exports = function createUniqueNodeId(node) {
	    return "" + globalCount++;
	};


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "priorRefsContainer";


/***/ },
/* 297 */
/***/ function(module, exports) {

	var NAME = "NullInPathError";
	var MESSAGE = "`null` is not allowed in branch key positions.";
	
	/**
	 * Does not allow null in path
	 */
	function NullInPathError() {
	    var err = Error.call(this, MESSAGE);
	    err.name = NAME;
	    this.stack = err.stack;
	    this.message = err.message;
	    return this;
	}
	
	// instanceof will be an error, but stack will be correct because its defined in the constructor.
	NullInPathError.prototype = Object.create(Error.prototype);
	NullInPathError.prototype.name = NAME;
	NullInPathError.message = MESSAGE;
	
	module.exports = NullInPathError;


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var __id = __webpack_require__(292);
	var __priorRefs = __webpack_require__(294);
	var createUniqueNodeId = __webpack_require__(295);
	
	module.exports = function assignCrossedRefs(crossedRef, innerRefs, fromRef, lru, promote) {
	
	    promote && promote(lru, crossedRef);
	
	    var crossedRefId = crossedRef[__id] || (crossedRef[__id] = createUniqueNodeId(crossedRef));
	
	    if (innerRefs) {
	        innerRefs[crossedRefId] = crossedRef;
	    }
	
	    if (fromRef) {
	        var fromRefId = fromRef[__id];
	        var priorRefs = crossedRef[__priorRefs] || (crossedRef[__priorRefs] = {});
	        priorRefs[fromRefId] = fromRef;
	    }
	};


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var $ref = __webpack_require__(272);
	var $error = __webpack_require__(300);
	var getSize = __webpack_require__(301);
	var getTimestamp = __webpack_require__(302);
	var isObject = __webpack_require__(249);
	var isExpired = __webpack_require__(303);
	var isFunction = __webpack_require__(262);
	
	var wrapNode = __webpack_require__(304);
	var insertNode = __webpack_require__(308);
	var expireNode = __webpack_require__(277);
	var replaceNode = __webpack_require__(309);
	var updateNodeAncestors = __webpack_require__(315);
	var reconstructPath = __webpack_require__(317);
	
	module.exports = function mergeJSONGraphNode(
	    parent, node, message, key,
	    requestedPath, requestedPathDepth,
	    optimizedPath, optimizedPathDepth,
	    version, expired, lru, promote, comparator, errorSelector) {
	
	    var sizeOffset;
	
	    var cType, mType,
	        cIsObject, mIsObject,
	        cTimestamp, mTimestamp;
	
	    // If the cache and message are the same, we can probably return early:
	    // - If they're both nullsy,
	    //   - If null then the node needs to be wrapped in an atom and inserted.
	    //     This happens from whole branch merging when a leaf is just a null value
	    //     instead of being wrapped in an atom.
	    //   - If undefined then return null (previous behavior).
	    // - If they're both branches, return the branch.
	    // - If they're both edges, continue below.
	    if (node === message) {
	
	        // There should not be undefined values.  Those should always be
	        // wrapped in an $atom
	        if (message === null) {
	            node = wrapNode(message, undefined, message);
	            parent = updateNodeAncestors(parent, -node.$size, lru, version);
	            node = insertNode(node, parent, key, undefined, optimizedPath, optimizedPathDepth);
	            if (promote) {
	                promote(lru, node);
	            }
	            return node;
	        }
	
	        // The message and cache are both undefined, therefore return null.
	        else if (message === undefined) {
	            return message;
	        }
	
	        else {
	            cIsObject = isObject(node);
	            if (cIsObject) {
	                // Is the cache node a branch? If so, return the cache branch.
	                cType = node.$type;
	                if (cType == null) {
	                    // Has the branch been introduced to the cache yet? If not,
	                    // give it a parent, key, and absolute path.
	                    if (node.ツparent == null) {
	                        insertNode(node, parent, key, version, optimizedPath, optimizedPathDepth);
	                    }
	                    return node;
	                }
	            }
	        }
	    } else {
	        cIsObject = isObject(node);
	        if (cIsObject) {
	            cType = node.$type;
	        }
	    }
	
	    // If the cache isn't a reference, we might be able to return early.
	    if (cType !== $ref) {
	        mIsObject = isObject(message);
	        if (mIsObject) {
	            mType = message.$type;
	        }
	        if (cIsObject && !cType) {
	            // If the cache is a branch and the message is empty or
	            // also a branch, continue with the cache branch.
	            if (message == null || (mIsObject && !mType)) {
	                return node;
	            }
	        }
	    }
	    // If the cache is a reference, we might not need to replace it.
	    else {
	        // If the cache is a reference, but the message is empty, leave the cache alone...
	        if (message == null) {
	            // ...unless the cache is an expired reference. In that case, expire
	            // the cache node and return undefined.
	            if (isExpired(node)) {
	                expireNode(node, expired, lru);
	                return void 0;
	            }
	            return node;
	        }
	        mIsObject = isObject(message);
	        if (mIsObject) {
	            mType = message.$type;
	            // If the cache and the message are both references,
	            // check if we need to replace the cache reference.
	            if (mType === $ref) {
	                if (node === message) {
	                    // If the cache and message are the same reference,
	                    // we performed a whole-branch merge of one of the
	                    // grandparents. If we've previously graphed this
	                    // reference, break early. Otherwise, continue to
	                    // leaf insertion below.
	                    if (node.ツparent != null) {
	                        return node;
	                    }
	                } else {
	
	                    cTimestamp = node.$timestamp;
	                    mTimestamp = message.$timestamp;
	
	                    // - If either the cache or message reference is expired,
	                    //   replace the cache reference with the message.
	                    // - If neither of the references are expired, compare their
	                    //   timestamps. If either of them don't have a timestamp,
	                    //   or the message's timestamp is newer, replace the cache
	                    //   reference with the message reference.
	                    // - If the message reference is older than the cache
	                    //   reference, short-circuit.
	                    if (!isExpired(node) && !isExpired(message) && mTimestamp < cTimestamp) {
	                        return void 0;
	                    }
	                }
	            }
	        }
	    }
	
	    // If the cache is a leaf but the message is a branch, merge the branch over the leaf.
	    if (cType && mIsObject && !mType) {
	        return replaceNode(node, message, parent, key, undefined, lru, optimizedPath, optimizedPathDepth);
	    }
	    // If the message is a sentinel or primitive, insert it into the cache.
	    else if (mType || !mIsObject) {
	        // If the cache and the message are the same value, we branch-merged one
	        // of the message's ancestors. If this is the first time we've seen this
	        // leaf, give the message a $size and $type, attach its graph pointers,
	        // and update the cache sizes and versions.
	
	        if (mType === $error && isFunction(errorSelector)) {
	            message = errorSelector(requestedPath.slice(0, requestedPathDepth+1), message);
	        }
	
	        if (mType && node === message) {
	            if (node.ツparent == null) {
	                node = wrapNode(node, cType, node.value);
	                parent = updateNodeAncestors(parent, -node.$size, lru, version);
	                node = insertNode(node, parent, key, version, optimizedPath, optimizedPathDepth);
	            }
	        }
	        // If the cache and message are different, or the message is a
	        // primitive, replace the cache with the message value. If the message
	        // is a sentinel, clone and maintain its type. If the message is a
	        // primitive value, wrap it in an atom.
	        else {
	            var isDistinct = true;
	            // If the cache is a branch, but the message is a leaf, replace the
	            // cache branch with the message leaf.
	            if (cType || !cIsObject) {
	                // Compare the current cache value with the new value. If either of
	                // them don't have a timestamp, or the message's timestamp is newer,
	                // replace the cache value with the message value. If a comparator
	                // is specified, the comparator takes precedence over timestamps.
	                //
	                // Comparing either Number or undefined to undefined always results in false.
	                isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;
	                // If at least one of the cache/message are sentinels, compare them.
	                if ((cType || mType) && isFunction(comparator)) {
	                    isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPathDepth));
	                }
	            }
	            if (isDistinct) {
	                message = wrapNode(message, mType, mType ? message.value : message);
	                sizeOffset = getSize(node) - getSize(message);
	                node = replaceNode(node, message, parent, key, version, lru, optimizedPath, optimizedPathDepth);
	                parent = updateNodeAncestors(parent, sizeOffset, lru, version);
	            }
	        }
	
	        // Promote the message edge in the LRU.
	        if (isExpired(node)) {
	            expireNode(node, expired, lru);
	        } else if (promote) {
	            promote(lru, node);
	        }
	    }
	    else if (node == null) {
	        node = insertNode(message, parent, key, undefined, optimizedPath, optimizedPathDepth);
	        if (promote) {
	            promote(lru, node);
	        }
	    }
	
	    return node;
	};


/***/ },
/* 300 */
/***/ function(module, exports) {

	module.exports = "error";


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	module.exports = function getSize(node) {
	    return isObject(node) && node.$size || 0;
	};


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	module.exports = function getTimestamp(node) {
	    return isObject(node) && node.$timestamp || undefined;
	};


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	var now = __webpack_require__(274);
	var $now = __webpack_require__(275);
	var $never = __webpack_require__(276);
	
	module.exports = function isExpired(node) {
	    var exp = node.$expires;
	    return (exp != null) && (
	        exp !== $never ) && (
	        exp === $now || exp < now());
	};


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var now = __webpack_require__(274);
	var expiresNow = __webpack_require__(275);
	
	var atomSize = 50;
	
	var clone = __webpack_require__(305);
	var isArray = Array.isArray;
	var getSize = __webpack_require__(301);
	var getExpires = __webpack_require__(306);
	var atomType = __webpack_require__(307);
	
	module.exports = function wrapNode(nodeArg, typeArg, value) {
	
	    var size = 0;
	    var node = nodeArg;
	    var type = typeArg;
	
	    if (type) {
	        var modelCreated = node.ツmodelCreated;
	        node = clone(node);
	        size = getSize(node);
	        node.$type = type;
	        node.ツprev = undefined;
	        node.ツnext = undefined;
	        node.ツmodelCreated = modelCreated || false;
	    } else {
	        node = {
	            $type: atomType,
	            value: value,
	            ツprev: undefined,
	            ツnext: undefined,
	            ツmodelCreated: true
	        };
	    }
	
	    if (value == null) {
	        size = atomSize + 1;
	    } else if (size == null || size <= 0) {
	        switch (typeof value) {
	            case "object":
	                if (isArray(value)) {
	                    size = atomSize + value.length;
	                } else {
	                    size = atomSize + 1;
	                }
	                break;
	            case "string":
	                size = atomSize + value.length;
	                break;
	            default:
	                size = atomSize + 1;
	                break;
	        }
	    }
	
	    var expires = getExpires(node);
	
	    if (typeof expires === "number" && expires < expiresNow) {
	        node.$expires = now() + (expires * -1);
	    }
	
	    node.$size = size;
	
	    return node;
	};


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var unicodePrefix = __webpack_require__(281);
	var hasOwn = __webpack_require__(248);
	var isArray = Array.isArray;
	var isObject = __webpack_require__(249);
	
	module.exports = function clone(value) {
	    var dest = value;
	    if (isObject(dest)) {
	        dest = isArray(value) ? [] : {};
	        var src = value;
	        for (var key in src) {
	            if (key.charAt(0) === unicodePrefix || !hasOwn(src, key)) {
	                continue;
	            }
	            dest[key] = src[key];
	        }
	    }
	    return dest;
	};


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	module.exports = function getSize(node) {
	    return isObject(node) && node.$expires || undefined;
	};


/***/ },
/* 307 */
/***/ function(module, exports) {

	module.exports = "atom";


/***/ },
/* 308 */
/***/ function(module, exports) {

	module.exports = function insertNode(node, parent, key, version, optimizedPath, optimizedPathDepth) {
	    node.ツkey = key;
	    node.ツparent = parent;
	
	    if (version !== undefined) {
	        node.ツversion = version;
	    }
	    if (!node.ツabsolutePath) {
	        node.ツabsolutePath = optimizedPath.slice(0, optimizedPathDepth + 1);
	    }
	
	    parent[key] = node;
	
	    return node;
	};


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	var insertNode = __webpack_require__(308);
	var transferBackReferences = __webpack_require__(310);
	var removeNodeAndDescendants = __webpack_require__(311);
	
	module.exports = function replaceNode(node, replacement, parent, key,
	                                      version, lru, optimizedPath,
	                                      optimizedPathDepth) {
	    if (node !== replacement && isObject(node)) {
	        transferBackReferences(node, replacement);
	        removeNodeAndDescendants(node, parent, key, lru);
	    }
	    return insertNode(replacement, parent, key, version, optimizedPath, optimizedPathDepth);
	};


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	var hasOwn = __webpack_require__(248);
	var __id = __webpack_require__(292);
	var __innerRefs = __webpack_require__(293);
	var __priorRefs = __webpack_require__(294);
	var __refTarget = __webpack_require__(280);
	var createUniqueNodeId = __webpack_require__(295);
	var __priorRefsContainer = __webpack_require__(296);
	
	module.exports = function transferBackReferences(fromNode, destNode) {
	
	    var fromId = fromNode[__id];
	    var destId = destNode[__id] || (
	        destNode[__id] = createUniqueNodeId(destNode));
	    var fromPriorRefs = fromNode[__priorRefs];
	    var destPriorRefs, fromPriorRefsContainer, destPriorRefsContainer;
	
	    for (refId in fromPriorRefs) {
	
	        if (!hasOwn(fromPriorRefs, refId)) {
	            continue;
	        }
	
	        var ref = fromPriorRefs[refId];
	        var innerRefs = ref[__innerRefs];
	        var refTarget = ref[__refTarget];
	
	        innerRefs[destId] = destNode;
	        innerRefs[fromId] = undefined;
	
	        fromPriorRefs[refId] = undefined;
	        destPriorRefs = destPriorRefs || (
	                destNode[__priorRefs] || (
	                    destNode[__priorRefs] = {}));
	        destPriorRefs[refId] = ref;
	
	        if (!refTarget) {
	            continue;
	        } else if (refTarget === fromId) {
	            ref[__refTarget] = destId;
	        } else if (fromPriorRefsContainer || (
	            fromPriorRefsContainer = fromNode[__priorRefsContainer])) {
	            var refTargetContainer = fromPriorRefsContainer[refId];
	            var index = refTargetContainer.indexOf(fromId);
	            if (~index) {
	                refTargetContainer[index] = destId;
	            }
	            destPriorRefsContainer = destPriorRefsContainer || (
	                             destNode[__priorRefsContainer] || (
	                                destNode[__priorRefsContainer] = {}));
	            destPriorRefsContainer[refId] = refTargetContainer;
	        }
	    }
	
	    fromNode[__priorRefs] = undefined;
	    fromNode[__priorRefsContainer] = undefined;
	
	    return destNode;
	}


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	var hasOwn = __webpack_require__(248);
	var prefix = __webpack_require__(281);
	var removeNode = __webpack_require__(312);
	
	module.exports = function removeNodeAndDescendants(node, parent, key, lru) {
	    if (removeNode(node, parent, key, lru)) {
	        if (node.$type == null) {
	            for (var key2 in node) {
	                if (key2[0] !== prefix && key2[0] !== "$" && hasOwn(node, key2)) {
	                    removeNodeAndDescendants(node[key2], node, key2, lru);
	                }
	            }
	        }
	        return true;
	    }
	    return false;
	};


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	var $ref = __webpack_require__(272);
	var splice = __webpack_require__(278);
	var isObject = __webpack_require__(249);
	var unlinkBackReferences = __webpack_require__(313);
	var unlinkForwardReference = __webpack_require__(314);
	
	module.exports = function removeNode(node, parent, key, lru) {
	    if (isObject(node)) {
	        var type = node.$type;
	        if (Boolean(type)) {
	            if (type === $ref) {
	                unlinkForwardReference(node);
	            }
	            splice(lru, node);
	        }
	        unlinkBackReferences(node);
	        parent[key] = node.ツparent = void 0;
	        return true;
	    }
	    return false;
	};


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var hasOwn = __webpack_require__(248);
	var __id = __webpack_require__(292);
	var __innerRefs = __webpack_require__(293);
	var __priorRefs = __webpack_require__(294);
	var __refTarget = __webpack_require__(280);
	var __priorRefsContainer = __webpack_require__(296);
	
	var isArray = Array.isArray;
	
	module.exports = function unlinkBackReferences(node) {
	
	    var nodeId = node[__id];
	    var priorRefs = node[__priorRefs];
	    var priorRefsContainer;
	
	    for (var refId in priorRefs) {
	
	        if (!hasOwn(priorRefs, refId)) {
	            continue;
	        }
	
	        var ref = priorRefs[refId];
	
	        if (ref) {
	            priorRefs[refId] = undefined;
	
	            var innerRefs = ref[__innerRefs];
	            var refTarget = ref[__refTarget];
	            innerRefs[nodeId] = undefined;
	
	            if (!refTarget) {
	                continue;
	            } else if (refTarget === nodeId) {
	                ref[__refTarget] = undefined;
	            } else if (
	                priorRefsContainer || (
	                priorRefsContainer = node[__priorRefsContainer])) {
	                var refTargetContainer = priorRefsContainer[refId];
	                var index = refTargetContainer.indexOf(nodeId);
	                if (~index) {
	                    refTargetContainer[index] = undefined;
	                }
	            }
	        }
	    }
	    node[__priorRefs] = undefined;
	    node[__priorRefsContainer] = undefined;
	    return node;
	};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	var __id = __webpack_require__(292);
	var __innerRefs = __webpack_require__(293);
	var __priorRefs = __webpack_require__(294);
	var __refTarget = __webpack_require__(280);
	var __priorRefsContainer = __webpack_require__(296);
	
	module.exports = function unlinkForwardReference(reference) {
	
	    var refId = reference[__id];
	    var innerRefs = reference[__innerRefs];
	
	    if (innerRefs) {
	        unlinkRefTarget(refId, reference[__refTarget], innerRefs);
	    }
	
	    reference[__innerRefs] = undefined;
	    reference[__refTarget] = undefined;
	
	    return reference;
	};
	
	function unlinkRefTarget(refId, refTarget, innerRefs) {
	    var targetRef, priorRefs, priorRefsContainer;
	    if (!refTarget) {
	        return;
	    } else if (typeof refTarget === 'string') {
	        if (targetRef = innerRefs[refTarget]) {
	            if (priorRefs = targetRef[__priorRefs]) {
	                priorRefs[refId] = undefined;
	            }
	            if (priorRefsContainer = targetRef[__priorRefsContainer]) {
	                priorRefsContainer[refId] = undefined;
	            }
	        }
	    } else {
	        var refTargetIndex = -1;
	        var refTargetCount = refTarget.length;
	        while (++refTargetIndex < refTargetCount) {
	            unlinkRefTarget(refId, refTarget[refTargetIndex], innerRefs);
	        }
	    }
	}


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var removeNode = __webpack_require__(312);
	var updateBackReferenceVersions = __webpack_require__(316);
	
	module.exports = function updateNodeAncestors(nodeArg, offset, lru, version) {
	    var child = nodeArg;
	    do {
	        var node = child.ツparent;
	        var size = child.$size = (child.$size || 0) - offset;
	        if (size <= 0 && node != null) {
	            removeNode(child, node, child.ツkey, lru);
	        } else if (child.ツversion !== version) {
	            updateBackReferenceVersions(child, version);
	        }
	        child = node;
	    } while (child);
	    return nodeArg;
	};


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var hasOwn = __webpack_require__(248);
	var __priorRefs = __webpack_require__(294);
	
	module.exports = function updateBackReferenceVersions(nodeArg, version) {
	    var stack = [nodeArg];
	    var count = 0;
	    do {
	        var node = stack[count];
	        if (node && node.ツversion !== version) {
	            node.ツversion = version;
	            stack[count++] = node.ツparent;
	            var priorRefs = node[__priorRefs];
	            for (var refId in priorRefs) {
	                if (!hasOwn(priorRefs, refId)) {
	                    continue;
	                }
	                stack[count++] = priorRefs[refId];
	            }
	        }
	    } while (--count > -1);
	    return nodeArg;
	}


/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	 * Reconstructs the path for the current key, from currentPath (requestedPath)
	 * state maintained during set/merge walk operations.
	 *
	 * During the walk, since the requestedPath array is updated after we attempt to
	 * merge/insert nodes during a walk (it reflects the inserted node's parent branch)
	 * we need to reconstitute a path from it.
	 *
	 * @param  {Array} currentPath The current requestedPath state, during the walk
	 * @param  {String} key        The current key value, during the walk
	 * @return {Array} A new array, with the path which represents the node we're about
	 * to insert
	 */
	module.exports = function reconstructPath(currentPath, key) {
	
	    var path = currentPath.slice(0, currentPath.depth);
	    path[path.length] = key;
	
	    return path;
	};


/***/ },
/* 318 */
/***/ function(module, exports) {

	/**
	 * When a bound model attempts to retrieve JSONGraph it should throw an
	 * error.
	 *
	 * @private
	 */
	function BoundJSONGraphModelError() {
	    var err = Error.call(this, BoundJSONGraphModelError.message);
	    err.name = this.name;
	    this.stack = err.stack;
	    this.message = err.message;
	    return this;
	}
	
	// instanceof will be an Error, but stack will be
	// correct because we capture it in the constructor.
	BoundJSONGraphModelError.prototype = Object.create(Error.prototype);
	BoundJSONGraphModelError.prototype.name = "BoundJSONGraphModelError";
	BoundJSONGraphModelError.message =
	    "It is not legal to use the JSON Graph " +
	    "format from a bound Model. JSON Graph format" +
	    " can only be used from a root model.";
	
	module.exports = BoundJSONGraphModelError;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathValues;
	
	var isFunction = __webpack_require__(262);
	var setPathValue = __webpack_require__(320);
	var getCachePosition = __webpack_require__(326);
	var InvalidModelError = __webpack_require__(327);
	
	/**
	 * Sets a list of {@link PathValue}s into a {@link JSONGraph}.
	 * @function
	 * @param {Object} model - the Model for which to insert the {@link PathValue}s.
	 * @param {Array.<PathValue>} pathValues - the list of {@link PathValue}s to set.
	 * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.
	 */
	function setPathValues(model, pathValues, promote, errorSelector, comparator) {
	
	    var _root = model._root;
	    var bound = model._path;
	    var cache = _root.cache;
	    var node = cache;
	
	    var optimizedPath, requestedPath;
	    var optimizedPathDepth = bound.length;
	
	    // If the model is bound, then get that cache position.
	    if (optimizedPathDepth) {
	
	        node = getCachePosition(model, bound);
	
	        // If there was a short, then we 'throw an error' to the outside
	        // calling function which will onError the observer.
	        if (node.$type) {
	            return {
	                criticalError: new InvalidModelError(bound, bound)
	            };
	        }
	        requestedPath = [];
	        optimizedPath = bound.slice(0);
	    } else {
	        requestedPath = [];
	        optimizedPath = [];
	        optimizedPathDepth = 0;
	    }
	
	    var expired = _root.expired;
	    var version = _root.version++;
	    var initialVersion = cache.ツversion;
	
	    var requestedPaths = [];
	    var optimizedPaths = [];
	    var pathValueIndex = -1;
	    var pathValueCount = pathValues.length;
	
	    while (++pathValueIndex < pathValueCount) {
	
	        var pathValue = pathValues[pathValueIndex];
	        var path = pathValue.path;
	        var value = pathValue.value;
	
	        setPathValue(path, 0, cache, node, node, value,
	                     requestedPath, 0,
	                     optimizedPath, optimizedPathDepth,
	                     requestedPaths, optimizedPaths,
	                     comparator, errorSelector,
	                     version, expired, _root, promote);
	    }
	
	    var newVersion = cache.ツversion;
	    var rootChangeHandler = _root.onChange;
	
	    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
	        rootChangeHandler(_root.topLevelModel);
	    }
	
	    return [requestedPaths, optimizedPaths];
	}


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathValue;
	
	var setPathNode = __webpack_require__(321);
	var iterateKeySet = __webpack_require__(282).iterateKeySet;
	
	/* eslint-disable no-constant-condition */
	function setPathValue(path, depth, root, parent, node, value,
	                      requestedPath, requestedPathDepth,
	                      optimizedPath, optimizedPathDepth,
	                      requestedPaths, optimizedPaths,
	                      comparator, errorSelector,
	                      version, expired, lru, promote) {
	
	    var nextDepth = depth + 1;
	    var branch = nextDepth < path.length;
	    var nextRequestedPathDepth = requestedPathDepth + 1;
	
	    var note;
	    var keyset = path[depth];
	    var key = keyset && typeof keyset === 'object' ?
	        iterateKeySet(keyset, note = {}) : keyset;
	
	    do {
	
	        var results = setPathNode(root, parent, node, key, value, branch, false,
	                                  null, requestedPath, requestedPathDepth,
	                                  optimizedPath, optimizedPathDepth,
	                                  comparator, errorSelector,
	                                  version, expired, lru, promote);
	
	        var nextIndex = 0;
	        var nextLength = results.length;
	
	        do {
	            var nextNode = results[nextIndex];
	            var nextParent = results[nextIndex + 1];
	            var nextOptimizedPath = results[nextIndex + 2];
	            var nextOptimizedPathDepth = results[nextIndex + 3];
	            nextIndex += 4;
	            if (nextNode) {
	                if (branch) {
	                    setPathValue(path, nextDepth, root, nextParent, nextNode, value,
	                                 requestedPath, nextRequestedPathDepth,
	                                 nextOptimizedPath, nextOptimizedPathDepth,
	                                 requestedPaths, optimizedPaths,
	                                 comparator, errorSelector,
	                                 version, expired, lru, promote);
	                } else {
	                    requestedPaths.push(requestedPath.slice(0, nextRequestedPathDepth));
	                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPathDepth));
	                }
	            }
	        } while (nextIndex < nextLength);
	
	        if (note) {
	            key = iterateKeySet(keyset, note);
	            continue;
	        }
	        break;
	    } while (!note.done);
	}
	/* eslint-enable */


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathNode;
	
	var $ref = __webpack_require__(272);
	var isExpired = __webpack_require__(273);
	var expireNode = __webpack_require__(277);
	var setPathRefs = __webpack_require__(322);
	var __innerRefs = __webpack_require__(293);
	var __refTarget = __webpack_require__(280);
	var NullInPathError = __webpack_require__(297);
	// var getRefComplement = require('./../support/getRefComplement');
	var assignCrossedRefs = __webpack_require__(298);
	var mergeValueOrInsertBranch = __webpack_require__(323);
	
	/* eslint-disable no-constant-condition, no-eq-null */
	function setPathNode(root, parent, node, key, value, branch, reference,
	                     innerRefs, requestedPath, requestedPathDepth,
	                     optimizedPath, optimizedPathDepth,
	                     comparator, errorSelector,
	                     version, expired, lru, promote) {
	
	    var results = [];
	    var refsIndex = 0;
	    var refsCount = 0;
	    var resultsIndex = 0;
	    var refs, refPathSet;
	
	    do {
	        if (node) {
	            var type = node.$type;
	            if (type === $ref) {
	                if (isExpired(node)) {
	                    expireNode(node, expired, lru);
	                    results[resultsIndex    ] = undefined;
	                    results[resultsIndex + 1] = root;
	                    results[resultsIndex + 2] = node.value.slice(0);
	                    results[resultsIndex + 3] = node.value.length;
	                    resultsIndex += 4;
	                } else {
	
	                    assignCrossedRefs(node, innerRefs, reference, lru);
	
	                    refPathSet = node.value;
	                    // refPathSet = getRefComplement(node, refs || (refs = []));
	
	                    if (refPathSet) {
	                        setPathRefs(refs || (refs = []),
	                                    node, refPathSet, 0,
	                                    root, root, root, value,
	                                    node[__innerRefs] || {}, node[__refTarget],
	                                    requestedPath, requestedPathDepth, [], 0,
	                                    comparator, errorSelector, version, expired, lru, promote);
	                    }
	
	                    refsCount = refs.length;
	                }
	            } else if (type) {
	                results[resultsIndex    ] = node;
	                results[resultsIndex + 1] = parent;
	                results[resultsIndex + 2] = optimizedPath;
	                results[resultsIndex + 3] = optimizedPathDepth;
	                resultsIndex += 4;
	            } else {
	                if (key == null) {
	                    if (branch) {
	                        throw new NullInPathError();
	                    } else {
	                        key = node.ツkey;
	                    }
	                } else {
	                    if (!reference) {
	                        requestedPath[requestedPathDepth] = key;
	                    }
	                    parent = node;
	                    node = parent[key];
	                    optimizedPath[optimizedPathDepth] = key;
	                }
	
	                node = mergeValueOrInsertBranch(
	                    parent, node, key, value, branch, reference,
	                    requestedPath, requestedPathDepth,
	                    optimizedPath, optimizedPathDepth,
	                    version, expired, lru, promote, comparator, errorSelector
	                );
	
	                results[resultsIndex    ] = node;
	                results[resultsIndex + 1] = parent;
	                results[resultsIndex + 2] = optimizedPath;
	                results[resultsIndex + 3] = optimizedPathDepth + 1;
	                resultsIndex += 4;
	            }
	        }
	
	        if (refsIndex < refsCount) {
	            node = refs[refsIndex];
	            parent = refs[refsIndex + 1];
	            innerRefs = refs[refsIndex + 2];
	            optimizedPath = refs[refsIndex + 3];
	            optimizedPathDepth = optimizedPath.length;
	            refsIndex += 4;
	            continue;
	        }
	        break;
	    } while (true);
	
	    return results;
	}
	/* eslint-enable */


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathRefs;
	
	var setPathNode = __webpack_require__(321);
	var __refTarget = __webpack_require__(280);
	var iterateKeySet = __webpack_require__(282).iterateKeySet;
	var assignRefTargets = __webpack_require__(291);
	
	function setPathRefs(refs, ref, path, depth,
	                     root, parent, node, value, innerRefs, refTarget,
	                     requestedPath, requestedPathDepth,
	                     optimizedPath, optimizedPathDepth,
	                     comparator, errorSelector,
	                     version, expired, lru, promote) {
	
	    var nextDepth = depth + 1;
	    var branch = nextDepth < path.length;
	
	    var note;
	    var keyset = path[depth];
	    var key = keyset && typeof keyset === 'object' ?
	        iterateKeySet(keyset, note = {}) : keyset;
	
	    if (note && typeof refTarget !== 'object') {
	        ref[__refTarget] = refTarget = [];
	    }
	
	    do {
	
	        var results = setPathNode(root, parent, node, key, value, branch, ref,
	                                  innerRefs, requestedPath, requestedPathDepth,
	                                  optimizedPath, optimizedPathDepth,
	                                  comparator, errorSelector,
	                                  version, expired, lru, promote);
	
	        var nextIndex = 0;
	        var nextLength = results.length;
	        var nextRefTarget = refTarget;
	
	        if (note && note.isArray && note.loaded) {
	            var nextRefTargetIndex = note.arrayOffset;
	            nextRefTarget = refTarget[nextRefTargetIndex] || (
	                refTarget[nextRefTargetIndex] = []);
	        }
	
	        do {
	            var nextNode = results[nextIndex];
	            var nextParent = results[nextIndex + 1];
	            var nextOptimizedPath = results[nextIndex + 2];
	            var nextOptimizedPathDepth = results[nextIndex + 3];
	            nextIndex += 4;
	            if (nextNode) {
	                if (branch) {
	                    setPathRefs(refs, ref, path, nextDepth,
	                                root, nextParent, nextNode, value,
	                                innerRefs, nextRefTarget,
	                                requestedPath, requestedPathDepth,
	                                nextOptimizedPath, nextOptimizedPathDepth,
	                                comparator, errorSelector, version, expired, lru, promote);
	                } else {
	
	                    // assignRefTargets(nextNode, innerRefs, ref, nextRefTarget);
	
	                    var refsIndex = refs.length;
	                    refs[refsIndex] = nextNode;
	                    refs[refsIndex + 1] = nextParent;
	                    refs[refsIndex + 2] = innerRefs;
	                    refs[refsIndex + 3] = nextOptimizedPath.slice(0, nextOptimizedPathDepth);
	                    refsIndex += 4;
	                }
	            }
	        } while (nextIndex < nextLength);
	
	        if (note) {
	            key = iterateKeySet(keyset, note);
	            continue;
	        }
	        break;
	    } while (!note.done);
	}


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	var $ref = __webpack_require__(272);
	var $error = __webpack_require__(300);
	var getType = __webpack_require__(324);
	var getSize = __webpack_require__(301);
	var getTimestamp = __webpack_require__(302);
	
	var isExpired = __webpack_require__(303);
	var isPrimitive = __webpack_require__(325);
	var isFunction = __webpack_require__(262);
	
	var wrapNode = __webpack_require__(304);
	var expireNode = __webpack_require__(277);
	var insertNode = __webpack_require__(308);
	var replaceNode = __webpack_require__(309);
	var updateNodeAncestors = __webpack_require__(315);
	var updateBackReferenceVersions = __webpack_require__(316);
	var reconstructPath = __webpack_require__(317);
	
	module.exports = function mergeValueOrInsertBranch(
	    parent, node, key, value, branch, reference,
	    requestedPath, requestedPathDepth,
	    optimizedPath, optimizedPathDepth,
	    version, expired, lru, promote, comparator, errorSelector) {
	
	    var type = getType(node/*, reference*/);
	
	    if (branch || reference) {
	        if (type && isExpired(node)) {
	            type = "expired";
	            expireNode(node, expired, lru);
	        }
	        if ((type && type !== $ref) || isPrimitive(node)) {
	            node = replaceNode(node, {}, parent, key, version,
	                               lru, optimizedPath, optimizedPathDepth);
	            node = updateBackReferenceVersions(node, version);
	        }
	    } else {
	        var message = value;
	        var mType = getType(message);
	        // Compare the current cache value with the new value. If either of
	        // them don't have a timestamp, or the message's timestamp is newer,
	        // replace the cache value with the message value. If a comparator
	        // is specified, the comparator takes precedence over timestamps.
	        //
	        // Comparing either Number or undefined to undefined always results in false.
	        var isDistinct = (getTimestamp(message) < getTimestamp(node)) === false;
	        // If at least one of the cache/message are sentinels, compare them.
	        if ((type || mType) && isFunction(comparator)) {
	            isDistinct = !comparator(node, message, optimizedPath.slice(0, optimizedPathDepth));
	        }
	        if (isDistinct) {
	
	            if (mType === $error && isFunction(errorSelector)) {
	                message = errorSelector(requestedPath.slice(0, requestedPathDepth+1), message);
	            }
	
	            message = wrapNode(message, mType, mType ? message.value : message);
	
	            var sizeOffset = getSize(node) - getSize(message);
	
	            node = replaceNode(node, message, parent, key, version,
	                               lru, optimizedPath, optimizedPathDepth);
	            parent = updateNodeAncestors(parent, sizeOffset, lru, version);
	        }
	
	        if (promote) {
	            promote(lru, node);
	        }
	    }
	
	    return node;
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	
	module.exports = function getType(node, anyType) {
	    var type = isObject(node) && node.$type || void 0;
	    if (anyType && type) {
	        return "branch";
	    }
	    return type;
	};


/***/ },
/* 325 */
/***/ function(module, exports) {

	var objTypeof = "object";
	module.exports = function isPrimitive(value) {
	    return value == null || typeof value !== objTypeof;
	};


/***/ },
/* 326 */
/***/ function(module, exports) {

	/**
	 * getCachePosition makes a fast walk to the bound value since all bound
	 * paths are the most possible optimized path.
	 *
	 * @param {Model} model -
	 * @param {Array} path -
	 * @returns {Mixed} - undefined if there is nothing in this position.
	 * @private
	 */
	module.exports = function getCachePosition(model, path) {
	    var currentCachePosition = model._root.cache;
	    var depth = -1;
	    var maxDepth = path.length;
	
	    // The loop is simple now, we follow the current cache position until
	    //
	    while (++depth < maxDepth &&
	           currentCachePosition && !currentCachePosition.$type) {
	
	        currentCachePosition = currentCachePosition[path[depth]];
	    }
	
	    return currentCachePosition;
	};


/***/ },
/* 327 */
/***/ function(module, exports) {

	var NAME = "InvalidModelError";
	var MESSAGE = "The boundPath of the model is not valid since a value or error was found before the path end.";
	/**
	 * An InvalidModelError can only happen when a user binds, whether sync
	 * or async to shorted value.  See the unit tests for examples.
	 *
	 * @param {String} message
	 * @private
	 */
	function InvalidModelError(boundPath, shortedPath) {
	    var err = Error.call(this, MESSAGE);
	    err.name = NAME;
	    this.stack = err.stack;
	    this.message = err.message;
	    this.boundPath = boundPath;
	    this.shortedPath = shortedPath;
	    return this;
	}
	
	// instanceof will be an error, but stack will be correct because its defined in the constructor.
	InvalidModelError.prototype = Object.create(Error.prototype);
	InvalidModelError.prototype.name = NAME;
	InvalidModelError.message = MESSAGE;
	
	module.exports = InvalidModelError;


/***/ },
/* 328 */
/***/ function(module, exports) {

	var NAME = "InvalidSourceError";
	var MESSAGE = "An exception was thrown when making a request.";
	
	/**
	 * InvalidSourceError happens when a dataSource syncronously throws
	 * an exception during a get/set/call operation.
	 *
	 * @param {Error} error - The error that was thrown.
	 * @private
	 */
	function InvalidSourceError(error) {
	    var err = Error.call(this, MESSAGE);
	    err.name = NAME;
	    this.stack = err.stack;
	    this.message = err.message;
	    this.innerError = error;
	    return this;
	}
	
	// instanceof will be an error, but stack will be correct because its defined
	// in the constructor.
	InvalidSourceError.prototype = Object.create(Error.prototype);
	InvalidSourceError.prototype.name = NAME;
	InvalidSourceError.is = function(e) {
	    return e && e.name === NAME;
	};
	
	module.exports = InvalidSourceError;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	var complement = __webpack_require__(330);
	var flushGetRequest = __webpack_require__(332);
	var REQUEST_ID = 0;
	var GetRequestType = __webpack_require__(266).GetRequest;
	var setJSONGraphs = __webpack_require__(269);
	var setPathValues = __webpack_require__(319);
	var $error = __webpack_require__(300);
	var emptyArray = [];
	var InvalidSourceError = __webpack_require__(328);
	
	/**
	 * Creates a new GetRequest.  This GetRequest takes a scheduler and
	 * the request queue.  Once the scheduler fires, all batched requests
	 * will be sent to the server.  Upon request completion, the data is
	 * merged back into the cache and all callbacks are notified.
	 *
	 * @param {Scheduler} scheduler -
	 * @param {RequestQueueV2} requestQueue -
	 */
	var GetRequestV2 = function(scheduler, requestQueue) {
	    this.sent = false;
	    this.scheduled = false;
	    this.requestQueue = requestQueue;
	    this.id = ++REQUEST_ID;
	    this.type = GetRequestType;
	
	    this._scheduler = scheduler;
	    this._pathMap = {};
	    this._optimizedPaths = [];
	    this._requestedPaths = [];
	    this._callbacks = [];
	    this._count = 0;
	    this._disposable = null;
	    this._collapsed = null;
	    this._disposed = false;
	};
	
	GetRequestV2.prototype = {
	    /**
	     * batches the paths that are passed in.  Once the request is complete,
	     * all callbacks will be called and the request will be removed from
	     * parent queue.
	     * @param {Array} requestedPaths -
	     * @param {Array} optimizedPaths -
	     * @param {Function} callback -
	     */
	    batch: function(requestedPaths, optimizedPaths, callback) {
	        var self = this;
	        var oPaths = self._optimizedPaths;
	        var rPaths = self._requestedPaths;
	        var callbacks = self._callbacks;
	        var idx = oPaths.length;
	
	        // If its not sent, simply add it to the requested paths
	        // and callbacks.
	        oPaths[idx] = optimizedPaths;
	        rPaths[idx] = requestedPaths;
	        callbacks[idx] = callback;
	        ++self._count;
	
	        // If it has not been scheduled, then schedule the action
	        if (!self.scheduled) {
	            self.scheduled = true;
	
	            var flushedDisposable;
	            var scheduleDisposable = self._scheduler.schedule(function() {
	                flushedDisposable =
	                    flushGetRequest(self, oPaths, function(err, data) {
	                        var i, fn, len;
	                        self.requestQueue.removeRequest(self);
	                        self._disposed = true;
	
	                        if (err instanceof InvalidSourceError) {
	                            for (i = 0, len = callbacks.length; i < len; ++i) {
	                                fn = callbacks[i];
	                                if (fn) {
	                                    fn(err);
	                                }
	                            }
	                            return;
	                        }
	
	                        // If there is at least one callback remaining, then
	                        // callback the callbacks.
	                        if (self._count) {
	                            self._merge(rPaths, err, data);
	
	                            // Call the callbacks.  The first one inserts all
	                            // the data so that the rest do not have consider
	                            // if their data is present or not.
	                            for (i = 0, len = callbacks.length; i < len; ++i) {
	                                fn = callbacks[i];
	                                if (fn) {
	                                    fn(err, data);
	                                }
	                            }
	                        }
	                    });
	            });
	
	            // There is a race condition here. If the scheduler is sync then it
	            // exposes a condition where the flush request cannot be disposed.
	            // To correct this issue, if there is no flushedDisposable, then the
	            // scheduler is async and should use scheduler disposable, else use
	            // the flushedDisposable.
	            self._disposable = flushedDisposable || scheduleDisposable;
	        }
	
	        // Disposes this batched request.  This does not mean that the
	        // entire request has been disposed, but just the local one, if all
	        // requests are disposed, then the outer disposable will be removed.
	        return createDisposable(self, idx);
	    },
	
	    /**
	     * Attempts to add paths to the outgoing request.  If there are added
	     * paths then the request callback will be added to the callback list.
	     *
	     * @returns {Array} - the remaining paths in the request.
	     */
	    add: function(requested, optimized, callback) {
	        // uses the length tree complement calculator.
	        var self = this;
	        var complementTuple = complement(requested, optimized, self._pathMap);
	        var optimizedComplement;
	        var requestedComplement;
	
	        if (complementTuple) {
	            requestedComplement = complementTuple[2];
	            optimizedComplement = complementTuple[1];
	        } else {
	            requestedComplement = requested;
	            optimizedComplement = optimized;
	        }
	
	        var inserted = false;
	        var disposable = false;
	
	        // If the out paths is less than the passed in paths, then there
	        // has been an intersection and the complement has been returned.
	        // Therefore, this can be deduped across requests.
	        if (optimizedComplement.length < optimized.length) {
	            inserted = true;
	            var idx = self._callbacks.length;
	            self._callbacks[idx] = callback;
	            self._requestedPaths[idx] = complementTuple[0];
	            self._optimizedPaths[idx] = [];
	            ++self._count;
	
	            disposable = createDisposable(self, idx);
	        }
	
	        return [inserted, requestedComplement, optimizedComplement, disposable];
	    },
	
	    /**
	     * merges the response into the model"s cache.
	     */
	    _merge: function(requested, err, data) {
	        var self = this;
	        var model = self.requestQueue.model;
	        var modelRoot = model._root;
	        var errorSelector = modelRoot.errorSelector;
	        var comparator = modelRoot.comparator;
	        var boundPath = model._path;
	
	        model._path = emptyArray;
	
	        // flatten all the requested paths, adds them to the
	        var nextPaths = flattenRequestedPaths(requested);
	
	        // Insert errors in every requested position.
	        if (err) {
	            var error = err;
	
	            // Converts errors to objects, a more friendly storage
	            // of errors.
	            if (error instanceof Error) {
	                error = {
	                    message: error.message
	                };
	            }
	
	            // Not all errors are value $types.
	            if (!error.$type) {
	                error = {
	                    $type: $error,
	                    value: error
	                };
	            }
	
	            var pathValues = nextPaths.map(function(x) {
	                return {
	                    path: x,
	                    value: error
	                };
	            });
	            setPathValues(model, pathValues, null, errorSelector, comparator);
	        }
	
	        // Insert the jsonGraph from the dataSource.
	        else {
	            setJSONGraphs(model, [{
	                paths: nextPaths,
	                jsonGraph: data.jsonGraph
	            }], null, errorSelector, comparator);
	        }
	
	        // return the model"s boundPath
	        model._path = boundPath;
	    }
	};
	
	// Creates a more efficient closure of the things that are
	// needed.  So the request and the idx.  Also prevents code
	// duplication.
	function createDisposable(request, idx) {
	    var disposed = false;
	    return function() {
	        if (disposed || request._disposed) {
	            return;
	        }
	
	        disposed = true;
	        request._callbacks[idx] = null;
	        request._optimizedPaths[idx] = [];
	        request._requestedPaths[idx] = [];
	
	        // If there are no more requests, then dispose all of the request.
	        var count = --request._count;
	        if (count === 0) {
	            request._disposable.dispose();
	            request.requestQueue.removeRequest(request);
	        }
	    };
	}
	
	function flattenRequestedPaths(requested) {
	    var out = [];
	    var outLen = -1;
	    for (var i = 0, len = requested.length; i < len; ++i) {
	        var paths = requested[i];
	        for (var j = 0, innerLen = paths.length; j < innerLen; ++j) {
	            out[++outLen] = paths[j];
	        }
	    }
	    return out;
	}
	
	module.exports = GetRequestV2;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	var hasIntersection = __webpack_require__(282).hasIntersection;
	var arraySlice = __webpack_require__(331);
	
	/**
	 * creates the complement of the requested and optimized paths
	 * based on the provided tree.
	 *
	 * If there is no complement then this is just a glorified
	 * array copy.
	 */
	module.exports = function complement(requested, optimized, tree) {
	    var optimizedComplement = [];
	    var requestedComplement = [];
	    var requestedIntersection = [];
	    var intersectionLength = -1, complementLength = -1;
	    var intersectionFound = false;
	
	    for (var i = 0, len = optimized.length; i < len; ++i) {
	        // If this does not intersect then add it to the output.
	        var path = optimized[i];
	        var subTree = tree[path.length];
	
	        // If there is no subtree to look into or there is no intersection.
	        if (!subTree || !hasIntersection(subTree, path, 0)) {
	
	            if (intersectionFound) {
	                optimizedComplement[++complementLength] = path;
	                requestedComplement[complementLength] = requested[i];
	            }
	        } else {
	            // If there has been no intersection yet and
	            // i is bigger than 0 (meaning we have had only complements)
	            // then we need to update our complements to match the current
	            // reality.
	            if (!intersectionFound && i > 0) {
	                requestedComplement = arraySlice(requested, 0, i);
	                optimizedComplement = arraySlice(optimized, 0, i);
	            }
	
	            requestedIntersection[++intersectionLength] = requested[i];
	            intersectionFound = true;
	        }
	    }
	
	    if (!intersectionFound) {
	        return null;
	    }
	
	    return [requestedIntersection, optimizedComplement, requestedComplement ];
	};


/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = function arraySlice(array, indexArg, endArg) {
	    var index = indexArg || 0;
	    var i = -1;
	    var n = array.length - index;
	
	    if (n < 0) {
	        n = 0;
	    }
	
	    if (endArg > 0 && n > endArg) {
	        n = endArg;
	    }
	
	    var array2 = new Array(n);
	    while (++i < n) {
	        array2[i] = array[i + index];
	    }
	    return array2;
	};


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var pathUtils = __webpack_require__(282);
	var toTree = pathUtils.toTree;
	var toPaths = pathUtils.toPaths;
	var InvalidSourceError = __webpack_require__(328);
	
	/**
	 * Flushes the current set of requests.  This will send the paths to the
	 * dataSource.  * The results of the dataSource will be sent to callback which
	 * should perform the zip of all callbacks.
	 * @param {GetRequest} request -
	 * @param {Array} listOfPaths -
	 * @param {Function} callback -
	 * @private
	 */
	module.exports = function flushGetRequest(request, listOfPaths, callback) {
	    if (request._count === 0) {
	        request.requestQueue.removeRequest(request);
	        return null;
	    }
	
	    request.sent = true;
	    request.scheduled = false;
	
	    // TODO: Move this to the collapse algorithm,
	    // TODO: we should have a collapse that returns the paths and
	    // TODO: the trees.
	
	    // Take all the paths and add them to the pathMap by length.
	    // Since its a list of paths
	    var pathMap = request._pathMap;
	    var listKeys = Object.keys(listOfPaths);
	    var listIdx = 0, listLen = listKeys.length;
	    for (; listIdx < listLen; ++listIdx) {
	        var paths = listOfPaths[listIdx];
	        for (var j = 0, pathLen = paths.length; j < pathLen; ++j) {
	            var pathSet = paths[j];
	            var len = pathSet.length;
	
	            if (!pathMap[len]) {
	                pathMap[len] = [pathSet];
	            } else {
	                var pathSetsByLength = pathMap[len];
	                pathSetsByLength[pathSetsByLength.length] = pathSet;
	            }
	        }
	    }
	
	    // now that we have them all by length, convert each to a tree.
	    var pathMapKeys = Object.keys(pathMap);
	    var pathMapIdx = 0, pathMapLen = pathMapKeys.length;
	    for (; pathMapIdx < pathMapLen; ++pathMapIdx) {
	        var pathMapKey = pathMapKeys[pathMapIdx];
	        pathMap[pathMapKey] = toTree(pathMap[pathMapKey]);
	    }
	
	    // Take the pathMapTree and create the collapsed paths and send those
	    // off to the server.
	    var collapsedPaths = request._collasped = toPaths(pathMap);
	    var jsonGraphData;
	
	    // Make the request.
	    // You are probably wondering why this is not cancellable.  If a request
	    // goes out, and all the requests are removed, the request should not be
	    // cancelled.  The reasoning is that another request could come in, after
	    // all callbacks have been removed and be deduped.  Might as well keep this
	    // around until it comes back.  If at that point there are no requests then
	    // we cancel at the callback above.
	    var getRequest;
	    try {
	        getRequest = request.
	            requestQueue.
	            model._source.
	            get(collapsedPaths);
	    } catch (e) {
	        callback(new InvalidSourceError());
	        return null;
	    }
	
	    // Ensures that the disposable is available for the outside to cancel.
	    var disposable = getRequest.
	        subscribe(function(data) {
	            jsonGraphData = data;
	        }, function(err) {
	            callback(err, jsonGraphData);
	        }, function() {
	            callback(null, jsonGraphData);
	        });
	
	    return disposable;
	};
	


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	var falcor = __webpack_require__(247);
	var noop = __webpack_require__(334);
	var Symbol = __webpack_require__(335);
	var toEsObservable = __webpack_require__(336);
	
	/**
	 * A ModelResponse is a container for the results of a get, set, or call operation performed on a Model. The ModelResponse provides methods which can be used to specify the output format of the data retrieved from a Model, as well as how that data is delivered.
	 * @constructor ModelResponse
	 * @augments Observable
	*/
	function ModelResponse(subscribe) {
	    this._subscribe = subscribe;
	}
	
	ModelResponse.prototype[Symbol.observable] = function SymbolObservable() {
	    return toEsObservable(this);
	};
	
	ModelResponse.prototype._toJSONG = function toJSONG() {
	    return this;
	};
	
	/**
	 * The progressively method breaks the response up into two parts: the data immediately available in the Model cache, and the data in the Model cache after the missing data has been retrieved from the DataSource.
	 * The progressively method creates a ModelResponse that immediately returns the requested data that is available in the Model cache. If any requested paths are not available in the cache, the ModelResponse will send another JSON message with all of the requested data after it has been retrieved from the DataSource.
	 * @name progressively
	 * @memberof ModelResponse.prototype
	 * @function
	 * @return {ModelResponse.<JSONEnvelope>} the values found at the requested paths.
	 * @example
	var dataSource = (new falcor.Model({
	  cache: {
	    user: {
	      name: "Steve",
	      surname: "McGuire",
	      age: 31
	    }
	  }
	})).asDataSource();
	
	var model = new falcor.Model({
	  source: dataSource,
	  cache: {
	    user: {
	      name: "Steve",
	      surname: "McGuire"
	    }
	  }
	});
	
	model.
	  get(["user",["name", "surname", "age"]]).
	  progressively().
	  // this callback will be invoked twice, once with the data in the
	  // Model cache, and again with the additional data retrieved from the DataSource.
	  subscribe(function(json){
	    console.log(JSON.stringify(json,null,4));
	  });
	
	// prints...
	// {
	//     "json": {
	//         "user": {
	//             "name": "Steve",
	//             "surname": "McGuire"
	//         }
	//     }
	// }
	// ...and then prints...
	// {
	//     "json": {
	//         "user": {
	//             "name": "Steve",
	//             "surname": "McGuire",
	//             "age": 31
	//         }
	//     }
	// }
	*/
	ModelResponse.prototype.progressively = function progressively() {
	    return this;
	};
	
	ModelResponse.prototype.subscribe =
	ModelResponse.prototype.forEach = function subscribe(a, b, c) {
	    var observer = a;
	    if (!observer || typeof observer !== "object") {
	        observer = {
	            onNext: a || noop,
	            onError: b || noop,
	            onCompleted: c || noop
	        };
	    }
	    var subscription = this._subscribe(observer);
	    switch (typeof subscription) {
	        case "function":
	            return { dispose: subscription };
	        case "object":
	            return subscription || { dispose: noop };
	        default:
	            return { dispose: noop };
	    }
	};
	
	ModelResponse.prototype.then = function then(onNext, onError) {
	    var self = this;
	    if (!self._promise) {
	        self._promise = new falcor.Promise(function(resolve, reject) {
	            var rejected = false;
	            var values = [];
	            self.subscribe(
	                function(value) {
	                    values[values.length] = value;
	                },
	                function(errors) {
	                    rejected = true;
	                    reject(errors);
	                },
	                function() {
	                    var value = values;
	                    if (values.length <= 1) {
	                        value = values[0];
	                    }
	
	                    if (rejected === false) {
	                        resolve(value);
	                    }
	                }
	            );
	        });
	    }
	    return self._promise.then(onNext, onError);
	};
	
	module.exports = ModelResponse;


/***/ },
/* 334 */
/***/ function(module, exports) {

	module.exports = function noop() {};


/***/ },
/* 335 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var objectTypes = {
	    "boolean": false,
	    "function": true,
	    "object": true,
	    "number": false,
	    "string": false,
	    "undefined": false
	};
	
	/*eslint-disable */
	var _root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
	var freeGlobal = objectTypes[typeof global] && global;
	
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    _root = freeGlobal;
	}
	/*eslint-enable */
	
	var _id = 0;
	
	function ensureSymbol(root) {
	    if (!root.Symbol) {
	        root.Symbol = function symbolFuncPolyfill(description) {
	            return "@@Symbol(" + description + "):" + (_id++) + "}";
	        };
	    }
	    return root.Symbol;
	}
	
	function ensureObservable(Symbol) {
	    if (!Symbol.observable) {
	        if (typeof Symbol.for === "function") {
	            Symbol.observable = Symbol.for("observable");
	        } else {
	            Symbol.observable = "@@observable";
	        }
	    }
	}
	
	function symbolForPolyfill(key) {
	    return "@@" + key;
	}
	
	function ensureFor(Symbol) {
	    if (!Symbol.for) {
	        Symbol.for = symbolForPolyfill;
	    }
	}
	
	
	function polyfillSymbol(root) {
	    var Symbol = ensureSymbol(root);
	    ensureObservable(Symbol);
	    ensureFor(Symbol);
	    return Symbol;
	}
	
	module.exports = polyfillSymbol(_root);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 336 */
/***/ function(module, exports) {

	/**
	 * FromEsObserverAdapter is an adpater from an ES Observer to an Rx 2 Observer
	 * @constructor FromEsObserverAdapter
	*/
	function FromEsObserverAdapter(esObserver) {
	    this.esObserver = esObserver;
	}
	
	FromEsObserverAdapter.prototype = {
	    onNext: function onNext(value) {
	        if (typeof this.esObserver.next === "function") {
	            return this.esObserver.next(value);
	        }
	    },
	    onError: function onError(error) {
	        if (typeof this.esObserver.error === "function") {
	            return this.esObserver.error(error);
	        }
	    },
	    onCompleted: function onCompleted() {
	        if (typeof this.esObserver.complete === "function") {
	            return this.esObserver.complete();
	        }
	    }
	};
	
	/**
	 * ToEsSubscriptionAdapter is an adpater from the Rx 2 subscription to the ES subscription
	 * @constructor ToEsSubscriptionAdapter
	*/
	function ToEsSubscriptionAdapter(subscription) {
	    this.subscription = subscription;
	}
	
	ToEsSubscriptionAdapter.prototype.unsubscribe = function unsubscribe() {
	    this.subscription.dispose();
	};
	
	
	function toEsObservable(_self) {
	    return {
	        subscribe: function subscribe(observer) {
	            return new ToEsSubscriptionAdapter(_self.subscribe(new FromEsObserverAdapter(observer)));
	        }
	    };
	}
	
	module.exports = toEsObservable;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	var SetResponse = __webpack_require__(338);
	var ModelResponse = __webpack_require__(333);
	var InvalidSourceError = __webpack_require__(328);
	
	var pathSyntax = __webpack_require__(149);
	var __version = __webpack_require__(374);
	
	/**
	 * @private
	 * @augments ModelResponse
	 */
	function CallResponse(model, callPath, args, suffix, paths) {
	    this.callPath = pathSyntax.fromPath(callPath);
	    this.args = args;
	
	    if (paths) {
	        this.paths = paths.map(pathSyntax.fromPath);
	    }
	    if (suffix) {
	        this.suffix = suffix.map(pathSyntax.fromPath);
	    }
	    this.model = model;
	
	    var currentVersion = model._root.cache[__version];
	
	    if (typeof currentVersion === "number") {
	        this.initialCacheVersion = currentVersion;
	    } else {
	        this.initialCacheVersion =
	            model._root.cache[__version] = model._root.version;
	    }
	}
	
	CallResponse.prototype = Object.create(ModelResponse.prototype);
	CallResponse.prototype._subscribe = function _subscribe(observer) {
	    var callPath = this.callPath;
	    var callArgs = this.args;
	    var suffixes = this.suffix;
	    var extraPaths = this.paths;
	    var model = this.model;
	    var rootModel = model._clone({
	        _path: []
	    });
	    var boundPath = model._path;
	    var boundCallPath = boundPath.concat(callPath);
	    var initialCacheVersion = this.initialCacheVersion;
	
	    /*eslint-disable consistent-return*/
	    // Precisely the same error as the router when a call function does not
	    // exist.
	    if (!model._source) {
	        observer.onError(new Error("function does not exist"));
	        return;
	    }
	
	
	    var response, obs;
	    try {
	        obs = model._source.
	            call(boundCallPath, callArgs, suffixes, extraPaths);
	    } catch (e) {
	        observer.onError(new InvalidSourceError(e));
	        return;
	    }
	
	    return obs.
	        subscribe(function(res) {
	            response = res;
	        }, function(err) {
	            observer.onError(err);
	        }, function() {
	
	            // Run the invalidations first then the follow up JSONGraph set.
	            var invalidations = response.invalidated;
	            if (invalidations && invalidations.length) {
	                // Increment `syncRefCount` here to block calling the _root's
	                // onChangesCompleted handler.
	                ++model._root.syncRefCount;
	                rootModel.invalidate.apply(rootModel, invalidations);
	                --model._root.syncRefCount;
	            }
	
	            // Use the SetResponse directly so we can specify the
	            // initialCacheVersion from before the call operation was invoked.
	            return new SetResponse(rootModel.withoutDataSource(), [response],
	                false, false, initialCacheVersion).subscribe(function(x) {
	                    observer.onNext(x);
	                }, function(err) {
	                    observer.onError(err);
	                }, function() {
	                    observer.onCompleted();
	                });
	        });
	    /*eslint-enable consistent-return*/
	};
	
	module.exports = CallResponse;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	var ModelResponse = __webpack_require__(333);
	var pathSyntax = __webpack_require__(149);
	var isArray = Array.isArray;
	var isPathValue = __webpack_require__(339);
	var isJSONGraphEnvelope = __webpack_require__(340);
	var isJSONEnvelope = __webpack_require__(341);
	var setRequestCycle = __webpack_require__(342);
	var __version = __webpack_require__(250).version;
	
	/**
	 *  The set response is responsible for doing the request loop for the set
	 * operation and subscribing to the follow up get.
	 *
	 * The constructors job is to parse out the arguments and put them in their
	 * groups.  The following subscribe will do the actual cache set and dataSource
	 * operation remoting.
	 *
	 * @param {Model} model -
	 * @param {Array} args - The array of arguments that can be JSONGraph, JSON, or
	 * pathValues.
	 * @param {Boolean} isJSONGraph - if the request is a jsonGraph output format.
	 * @param {Boolean} isProgressive - progressive output.
	 * @augments ModelResponse
	 * @private
	 */
	var SetResponse = module.exports = function SetResponse(model, args,
	                                                        isJSONGraph,
	                                                        isProgressive,
	                                                        initialCacheVersion) {
	
	    // The response properties.
	    this._model = model;
	    this._isJSONGraph = isJSONGraph || false;
	    this._isProgressive = isProgressive || false;
	    this._initialArgs = args;
	    this._value = [{}];
	
	    var currentVersion = model._root.cache[__version];
	
	    if (typeof initialCacheVersion === "number") {
	        this.initialCacheVersion = initialCacheVersion;
	    } else if (typeof currentVersion === "number") {
	        this.initialCacheVersion = currentVersion;
	    } else {
	        this.initialCacheVersion =
	            model._root.cache[__version] = model._root.version;
	    }
	
	    var groups = [];
	    var group, groupType;
	    var argIndex = -1;
	    var argCount = args.length;
	
	    // Validation of arguments have been moved out of this function.
	    while (++argIndex < argCount) {
	        var arg = args[argIndex];
	        var argType;
	        if (isArray(arg) || typeof arg === "string") {
	            arg = pathSyntax.fromPath(arg);
	            argType = "PathValues";
	        } else if (isPathValue(arg)) {
	            arg.path = pathSyntax.fromPath(arg.path);
	            argType = "PathValues";
	        } else if (isJSONGraphEnvelope(arg)) {
	            argType = "JSONGs";
	        } else if (isJSONEnvelope(arg)) {
	            argType = "PathMaps";
	        }
	
	        if (groupType !== argType) {
	            groupType = argType;
	            group = {
	                inputType: argType,
	                arguments: []
	            };
	            groups.push(group);
	        }
	
	        group.arguments.push(arg);
	    }
	
	    this._groups = groups;
	};
	
	SetResponse.prototype = Object.create(ModelResponse.prototype);
	
	/**
	 * The subscribe function will setup the remoting of the operation and cache
	 * setting.
	 *
	 * @private
	 */
	SetResponse.prototype._subscribe = function _subscribe(observer) {
	    var groups = this._groups;
	    var model = this._model;
	    var isJSONGraph = this._isJSONGraph;
	    var isProgressive = this._isProgressive;
	
	    // Starts the async request cycle.
	    return setRequestCycle(
	        model, observer, groups,
	        isJSONGraph, isProgressive,
	        0, this.initialCacheVersion);
	};
	
	/**
	 * Makes the output of a get response JSONGraph instead of json.
	 * @private
	 */
	SetResponse.prototype._toJSONG = function _toJSONGraph() {
	    return new SetResponse(this._model, this._initialArgs,
	                           true, this._isProgressive, this.initialCacheVersion);
	};
	
	/**
	 * Progressively responding to data in the cache instead of once the whole
	 * operation is complete.
	 * @public
	 */
	SetResponse.prototype.progressively = function progressively() {
	    return new SetResponse(this._model, this._initialArgs,
	                           this._isJSONGraph, true, this.initialCacheVersion);
	};


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var isObject = __webpack_require__(249);
	
	module.exports = function isPathValue(pathValue) {
	    return isObject(pathValue) && (
	        isArray(pathValue.path) || (
	            typeof pathValue.path === "string"
	        ));
	};


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var isObject = __webpack_require__(249);
	
	module.exports = function isJSONGraphEnvelope(envelope) {
	    return isObject(envelope) && isArray(envelope.paths) && (
	        isObject(envelope.jsonGraph) ||
	        isObject(envelope.jsong) ||
	        isObject(envelope.json) ||
	        isObject(envelope.values) ||
	        isObject(envelope.value)
	    );
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(249);
	
	module.exports = function isJSONEnvelope(envelope) {
	    return isObject(envelope) && ("json" in envelope);
	};


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	var emptyArray = [];
	var AssignableDisposable = __webpack_require__(343);
	var GetResponse = __webpack_require__(344);
	var setGroupsIntoCache = __webpack_require__(375);
	var getWithPathsAsPathMap = __webpack_require__(346).getWithPathsAsPathMap;
	var InvalidSourceError = __webpack_require__(328);
	var MaxRetryExceededError = __webpack_require__(371);
	
	/**
	 * The request cycle for set.  This is responsible for requesting to dataSource
	 * and allowing disposing inflight requests.
	 */
	module.exports = function setRequestCycle(model, observer, groups,
	                                          isJSONGraph, isProgressive, count,
	                                          initialCacheVersion) {
	    // we have exceeded the maximum retry limit.
	    if (count === 10) {
	        throw new MaxRetryExceededError();
	    }
	
	    var requestedAndOptimizedPaths = setGroupsIntoCache(model, groups);
	    var optimizedPaths = requestedAndOptimizedPaths.optimizedPaths;
	    var requestedPaths = requestedAndOptimizedPaths.requestedPaths;
	    var isMaster = model._source === undefined;
	
	    // Local set only.  We perform a follow up get.  If performance is ever
	    // a requirement simply requiring in checkCacheAndReport and use get request
	    // internals.  Figured this is more "pure".
	    if (isMaster) {
	        return subscribeToFollowupGet(model, observer, requestedPaths,
	                              isJSONGraph, isProgressive, initialCacheVersion);
	    }
	
	
	    // Progressively output the data from the first set.
	    if (isProgressive) {
	        var json = {};
	        getWithPathsAsPathMap(model, requestedPaths, [json]);
	        observer.onNext(json);
	    }
	
	    var currentJSONGraph = getJSONGraph(model, optimizedPaths);
	    var disposable = new AssignableDisposable();
	
	    // Sends out the setRequest.  The Queue will call the callback with the
	    // JSONGraph envelope / error.
	    var requestDisposable = model._request.
	        // TODO: There is error handling that has not been addressed yet.
	
	        // If disposed before this point then the sendSetRequest will not
	        // further any callbacks.  Therefore, if we are at this spot, we are
	        // not disposed yet.
	        set(currentJSONGraph, function(error, jsonGraphEnv) {
	            if (typeof error === InvalidSourceError) {
	                return observer.onError(error);
	            }
	
	            // TODO: This seems like there are errors with this approach, but
	            // for sanity sake I am going to keep this logic in here until a
	            // rethink can be done.
	            var isCompleted = false;
	            if (error || optimizedPaths.length === jsonGraphEnv.paths.length) {
	                isCompleted = true;
	            }
	
	            // Happy case.  One request to the dataSource will fulfill the
	            // required paths.
	            if (isCompleted) {
	                disposable.currentDisposable =
	                    subscribeToFollowupGet(model, observer, requestedPaths,
	                                          isJSONGraph, isProgressive, initialCacheVersion);
	            }
	
	            // TODO: The unhappy case.  I am unsure how this can even be
	            // achieved.
	            else {
	                // We need to restart the setRequestCycle.
	                setRequestCycle(model, observer, groups, isJSONGraph,
	                                isProgressive, count + 1, initialCacheVersion);
	            }
	        });
	
	    // Sets the current disposable as the requestDisposable.
	    disposable.currentDisposable = requestDisposable;
	
	    return disposable;
	};
	
	function getJSONGraph(model, optimizedPaths) {
	    var boundPath = model._path;
	    var envelope = {};
	    model._path = emptyArray;
	    model._getPathValuesAsJSONG(model._materialize().withoutDataSource(), optimizedPaths, [envelope]);
	    model._path = boundPath;
	
	    return envelope;
	}
	
	function subscribeToFollowupGet(model, observer, requestedPaths, isJSONGraph,
	                               isProgressive, initialCacheVersion) {
	
	    // Creates a new response and subscribes to it with the original observer.
	    // Also sets forceCollect to true, incase the operation is synchronous and
	    // exceeds the cache limit size
	    var response = new GetResponse(model, requestedPaths, isJSONGraph,
	                                   isProgressive, true, initialCacheVersion);
	    return response.subscribe(observer);
	}


/***/ },
/* 343 */
/***/ function(module, exports) {

	/**
	 * Will allow for state tracking of the current disposable.  Also fulfills the
	 * disposable interface.
	 * @private
	 */
	var AssignableDisposable = function AssignableDisposable(disosableCallback) {
	    this.disposed = false;
	    this.currentDisposable = disosableCallback;
	};
	
	
	AssignableDisposable.prototype = {
	
	    /**
	     * Disposes of the current disposable.  This would be the getRequestCycle
	     * disposable.
	     */
	    dispose: function dispose() {
	        if (this.disposed || !this.currentDisposable) {
	            return;
	        }
	        this.disposed = true;
	
	        // If the current disposable fulfills the disposable interface or just
	        // a disposable function.
	        var currentDisposable = this.currentDisposable;
	        if (currentDisposable.dispose) {
	            currentDisposable.dispose();
	        }
	
	        else {
	            currentDisposable();
	        }
	    }
	};
	
	
	module.exports = AssignableDisposable;


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var ModelResponse = __webpack_require__(333);
	var checkCacheAndReport = __webpack_require__(345);
	var getRequestCycle = __webpack_require__(370);
	var empty = {dispose: function() {}};
	var collectLru = __webpack_require__(373);
	var getSize = __webpack_require__(301);
	var __version = __webpack_require__(374);
	var isFunction = __webpack_require__(262);
	
	/**
	 * The get response.  It takes in a model and paths and starts
	 * the request cycle.  It has been optimized for cache first requests
	 * and closures.
	 * @param {Model} model -
	 * @param {Array} paths -
	 * @augments ModelResponse
	 * @private
	 */
	var GetResponse = module.exports = function GetResponse(model, paths,
	                                                        isJSONGraph,
	                                                        isProgressive,
	                                                        forceCollect,
	                                                        initialCacheVersion) {
	    this.model = model;
	    this.currentRemainingPaths = paths;
	    this.isJSONGraph = isJSONGraph || false;
	    this.isProgressive = isProgressive || false;
	    this.forceCollect = forceCollect || false;
	
	    var currentVersion = model._root.cache[__version];
	
	    if (typeof initialCacheVersion === "number") {
	        this.initialCacheVersion = initialCacheVersion;
	    } else if (typeof currentVersion === "number") {
	        this.initialCacheVersion = currentVersion;
	    } else {
	        this.initialCacheVersion =
	            model._root.cache[__version] = model._root.version;
	    }
	};
	
	GetResponse.prototype = Object.create(ModelResponse.prototype);
	
	/**
	 * Makes the output of a get response JSONGraph instead of json.
	 * @private
	 */
	GetResponse.prototype._toJSONG = function _toJSONGraph() {
	    return new GetResponse(this.model, this.currentRemainingPaths,
	                           true, this.isProgressive, this.forceCollect,
	                           this.initialCacheVersion);
	};
	
	/**
	 * Progressively responding to data in the cache instead of once the whole
	 * operation is complete.
	 * @public
	 */
	GetResponse.prototype.progressively = function progressively() {
	    return new GetResponse(this.model, this.currentRemainingPaths,
	                           this.isJSONGraph, true, this.forceCollect,
	                           this.initialCacheVersion);
	};
	
	/**
	 * purely for the purposes of closure creation other than the initial
	 * prototype created closure.
	 *
	 * @private
	 */
	GetResponse.prototype._subscribe = function _subscribe(observer) {
	    var seed = [{}, false];
	    var errors = [];
	    var model = this.model;
	    var isJSONG = observer.isJSONG = this.isJSONGraph;
	    var isProgressive = this.isProgressive;
	    var results = checkCacheAndReport(model, this.currentRemainingPaths,
	                                      observer, isProgressive, isJSONG, seed,
	                                      errors);
	
	    // If there are no results, finish.
	    if (!results) {
	
	        var modelRoot = model._root;
	        var modelCache = modelRoot.cache;
	        var currentVersion = modelCache[__version];
	
	        if (this.forceCollect) {
	            collectLru(modelRoot, modelRoot.expired, getSize(modelCache),
	                    model._maxSize, model._collectRatio, currentVersion);
	        }
	
	        var initialCacheVersion = this.initialCacheVersion;
	        var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;
	
	        if (initialCacheVersion !== currentVersion && (
	            modelRoot.syncRefCount <= 0) &&
	            isFunction(rootOnChangesCompletedHandler)) {
	            rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);
	        }
	
	        return empty;
	    }
	
	    // Starts the async request cycle.
	    return getRequestCycle(this, model, results,
	                           observer, seed, errors, 1,
	                           this.initialCacheVersion);
	};


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var gets = __webpack_require__(346);
	var getWithPathsAsJSONGraph = gets.getWithPathsAsJSONGraph;
	var getWithPathsAsPathMap = gets.getWithPathsAsPathMap;
	
	/**
	 * Checks cache for the paths and reports if in progressive mode.  If
	 * there are missing paths then return the cache hit results.
	 *
	 * @param {Model} model - The model that the request was made with.
	 * @param {Array} requestedMissingPaths -
	 * @param {Boolean} progressive -
	 * @param {Boolean} isJSONG -
	 * @param {Function} onNext -
	 * @param {Function} onError -
	 * @param {Function} onCompleted -
	 * @param {Object} seed - The state of the output
	 * @private
	 */
	module.exports = function checkCacheAndReport(model, requestedPaths, observer,
	                                              progressive, isJSONG, seed,
	                                              errors) {
	
	    // checks the cache for the data.
	    var results;
	    if (isJSONG) {
	        results = getWithPathsAsJSONGraph(model, requestedPaths, seed);
	    } else {
	        results = getWithPathsAsPathMap(model, requestedPaths, seed);
	    }
	
	    // We must communicate critical errors from get that are critical
	    // errors such as bound path is broken or this is a JSONGraph request
	    // with a bound path.
	    if (results.criticalError) {
	        observer.onError(results.criticalError);
	        return null;
	    }
	
	    // We are done when there are no missing paths or the model does not
	    // have a dataSource to continue on fetching from.
	    var hasValues = results.hasValue;
	    var completed = !results.requestedMissingPaths ||
	                    !results.requestedMissingPaths.length ||
	                    !model._source;
	    var hasValueOverall = seed[1] || (seed[1] = hasValues);
	
	    // Copy the errors into the total errors array.
	    if (results.errors) {
	        var errs = results.errors;
	        var errorsLength = errors.length;
	        for (var i = 0, len = errs.length; i < len; ++i, ++errorsLength) {
	            errors[errorsLength] = errs[i];
	        }
	    }
	
	    // If there are values to report, then report.
	    // Which are under two conditions:
	    // 1.  This request for data yielded at least one value (hasValue) and  the
	    // request is progressive
	    //
	    // 2.  The request if finished and at least one pass of checkCacheAndReport
	    // populated this seed with at least one value.
	    if (hasValues && progressive || hasValueOverall && completed) {
	        try {
	            observer.onNext(seed[0]);
	        } catch(e) {
	            throw e;
	        }
	    }
	
	    // if there are missing paths, then lets return them.
	    if (completed) {
	        if (errors.length) {
	            observer.onError(errors);
	        } else {
	            observer.onCompleted();
	        }
	
	        return null;
	    }
	
	    // Return the results object.
	    return results;
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	    getValueSync: __webpack_require__(347),
	    getBoundValue: __webpack_require__(355),
	    getWithPathsAsPathMap: __webpack_require__(356),
	    getWithPathsAsJSONGraph: __webpack_require__(365)
	};


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var followReference = __webpack_require__(348);
	var clone = __webpack_require__(353);
	var isExpired = __webpack_require__(354);
	var promote = __webpack_require__(352);
	var $ref = __webpack_require__(272);
	var $atom = __webpack_require__(307);
	var $error = __webpack_require__(300);
	
	module.exports = function getValueSync(model, simplePath, noClone) {
	    var root = model._root.cache;
	    var len = simplePath.length;
	    var optimizedPath = [];
	    var shorted = false, shouldShort = false;
	    var depth = 0;
	    var key, i, next = root, curr = root, out = root, type, ref, refNode;
	    var found = true;
	    var expired = false;
	
	    while (next && depth < len) {
	        key = simplePath[depth++];
	        if (key !== null) {
	            next = curr[key];
	            optimizedPath[optimizedPath.length] = key;
	        }
	
	        if (!next) {
	            out = undefined;
	            shorted = true;
	            found = false;
	            break;
	        }
	
	        type = next.$type;
	
	        // A materialized item.  There is nothing to deref to.
	        if (type === $atom && next.value === undefined) {
	            out = undefined;
	            found = false;
	            shorted = depth < len;
	            break;
	        }
	
	        // Up to the last key we follow references, ensure that they are not
	        // expired either.
	        if (depth < len) {
	            if (type === $ref) {
	
	                // If the reference is expired then we need to set expired to
	                // true.
	                if (isExpired(next)) {
	                    expired = true;
	                    out = undefined;
	                    break;
	                }
	
	                ref = followReference(model, root, root, next, next.value);
	                refNode = ref[0];
	
	                // The next node is also set to undefined because nothing
	                // could be found, this reference points to nothing, so
	                // nothing must be returned.
	                if (!refNode) {
	                    out = void 0;
	                    next = void 0;
	                    found = false;
	                    break;
	                }
	                type = refNode.$type;
	                next = refNode;
	                optimizedPath = ref[1].slice(0);
	            }
	
	            if (type) {
	                break;
	            }
	        }
	        // If there is a value, then we have great success, else, report an undefined.
	        else {
	            out = next;
	        }
	        curr = next;
	    }
	
	    if (depth < len && !expired) {
	        // Unfortunately, if all that follows are nulls, then we have not shorted.
	        for (i = depth; i < len; ++i) {
	            if (simplePath[depth] !== null) {
	                shouldShort = true;
	                break;
	            }
	        }
	        // if we should short or report value.  Values are reported on nulls.
	        if (shouldShort) {
	            shorted = true;
	            out = void 0;
	        } else {
	            out = next;
	        }
	
	        for (i = depth; i < len; ++i) {
	            if (simplePath[i] !== null) {
	                optimizedPath[optimizedPath.length] = simplePath[i];
	            }
	        }
	    }
	
	    // promotes if not expired
	    if (out && type) {
	        if (isExpired(out)) {
	            out = void 0;
	        } else {
	            promote(model._root, out);
	        }
	    }
	
	    // if (out && out.$type === $error && !model._treatErrorsAsValues) {
	    if (out && type === $error && !model._treatErrorsAsValues) {
	        throw {
	            path: depth === len ? simplePath : simplePath.slice(0, depth),
	            value: out.value
	        };
	    } else if (out && model._boxed) {
	        out = Boolean(type) && !noClone ? clone(out) : out;
	    } else if (!out && model._materialized) {
	        out = {$type: $atom};
	    } else if (out) {
	        out = out.value;
	    }
	
	    return {
	        value: out,
	        shorted: shorted,
	        optimizedPath: optimizedPath,
	        found: found
	    };
	};


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var createHardlink = __webpack_require__(349);
	var onValue = __webpack_require__(351);
	var isExpired = __webpack_require__(354);
	var $ref = __webpack_require__(272);
	var promote = __webpack_require__(352);
	
	/* eslint-disable no-constant-condition */
	function followReference(model, root, nodeArg, referenceContainerArg,
	                         referenceArg, seed, isJSONG) {
	
	    var node = nodeArg;
	    var reference = referenceArg;
	    var referenceContainer = referenceContainerArg;
	    var depth = 0;
	    var k, next;
	
	    while (true) {
	        if (depth === 0 && referenceContainer.ツcontext) {
	            depth = reference.length;
	            next = referenceContainer.ツcontext;
	        } else {
	            k = reference[depth++];
	            next = node[k];
	        }
	        if (next) {
	            var type = next.$type;
	            var value = type && next.value || next;
	
	            if (depth < reference.length) {
	                if (type) {
	                    node = next;
	                    break;
	                }
	
	                node = next;
	                continue;
	            }
	
	            // We need to report a value or follow another reference.
	            else {
	
	                node = next;
	
	                if (type && isExpired(next)) {
	                    break;
	                }
	
	                if (!referenceContainer.ツcontext) {
	                    createHardlink(referenceContainer, next);
	                }
	
	                // Restart the reference follower.
	                if (type === $ref) {
	
	                    // Nulls out the depth, outerResults,
	                    if (isJSONG) {
	                        onValue(model, next, seed, null, null, null, null,
	                                reference, reference.length, isJSONG);
	                    } else {
	                        promote(model._root, next);
	                    }
	
	                    depth = 0;
	                    reference = value;
	                    referenceContainer = next;
	                    node = root;
	                    continue;
	                }
	
	                break;
	            }
	        } else {
	            node = void 0;
	        }
	        break;
	    }
	
	
	    if (depth < reference.length && node !== void 0) {
	        var ref = [];
	        for (var i = 0; i < depth; i++) {
	            ref[i] = reference[i];
	        }
	        reference = ref;
	    }
	
	    return [node, reference, referenceContainer];
	}
	/* eslint-enable */
	
	module.exports = followReference;


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var __ref = __webpack_require__(350);
	
	module.exports = function createHardlink(from, to) {
	
	    // create a back reference
	    var backRefs = to.ツrefsLength || 0;
	    to[__ref + backRefs] = from;
	    to.ツrefsLength = backRefs + 1;
	
	    // create a hard reference
	    from.ツrefIndex = backRefs;
	    from.ツcontext = to;
	};


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "ref";


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var promote = __webpack_require__(352);
	var clone = __webpack_require__(353);
	var $ref = __webpack_require__(272);
	var $atom = __webpack_require__(307);
	var $error = __webpack_require__(300);
	
	module.exports = function onValue(model, node, seed, depth, outerResults,
	                                  branchInfo, requestedPath, optimizedPath,
	                                  optimizedLength, isJSONG) {
	    // Promote first.  Even if no output is produced we should still promote.
	    if (node) {
	        promote(model._root, node);
	    }
	
	    // Preload
	    if (!seed) {
	        return;
	    }
	
	    var i, len, k, key, curr, prev = null, prevK;
	    var materialized = false, valueNode;
	
	    if (!node || node.value === undefined) {
	        materialized = model._materialized;
	    }
	
	    // materialized
	    if (materialized) {
	        valueNode = {$type: $atom};
	    }
	
	    // Boxed Mode will clone the node.
	    else if (model._boxed) {
	        valueNode = clone(node);
	    }
	
	    // JSONG always clones the node.
	    else if (node.$type === $ref || node.$type === $error) {
	        if (isJSONG) {
	            valueNode = clone(node);
	        } else {
	            valueNode = node.value;
	        }
	    }
	
	    else if (isJSONG) {
	        var isObject = node.value && typeof node.value === "object";
	        var isUserCreatedNode = !node.ツmodelCreated;
	        if (isObject || isUserCreatedNode) {
	            valueNode = clone(node);
	        } else {
	            valueNode = node.value;
	        }
	    }
	
	    else {
	        valueNode = node.value;
	    }
	
	    if (outerResults) {
	        outerResults.hasValue = true;
	    }
	
	    if (isJSONG) {
	        curr = seed.jsonGraph;
	        if (!curr) {
	            curr = seed.jsonGraph = {};
	            seed.paths = [];
	        }
	        for (i = 0, len = optimizedLength - 1; i < len; i++) {
	            key = optimizedPath[i];
	
	            if (!curr[key]) {
	                curr[key] = {};
	            }
	            curr = curr[key];
	        }
	
	        // assign the last
	        key = optimizedPath[i];
	
	        // TODO: Special case? do string comparisons make big difference?
	        curr[key] = materialized ? {$type: $atom} : valueNode;
	        if (requestedPath) {
	            seed.paths.push(requestedPath.slice(0, depth));
	        }
	    }
	
	    // The output is pathMap and the depth is 0.  It is just a
	    // value report it as the found JSON
	    else if (depth === 0) {
	        seed.json = valueNode;
	    }
	
	    // The output is pathMap but we need to build the pathMap before
	    // reporting the value.
	    else {
	        curr = seed.json;
	        if (!curr) {
	            curr = seed.json = {};
	        }
	        for (i = 0; i < depth - 1; i++) {
	            k = requestedPath[i];
	
	            // The branch info is already generated output from the walk algo
	            // with the required __path information on it.
	            if (!curr[k]) {
	                curr[k] = branchInfo[i];
	            }
	
	            prev = curr;
	            prevK = k;
	            curr = curr[k];
	        }
	        k = requestedPath[i];
	        if (k !== null) {
	            curr[k] = valueNode;
	        } else {
	            prev[prevK] = valueNode;
	        }
	    }
	};


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var EXPIRES_NEVER = __webpack_require__(276);
	
	// [H] -> Next -> ... -> [T]
	// [T] -> Prev -> ... -> [H]
	module.exports = function lruPromote(root, object) {
	    // Never promote node.$expires === 1.  They cannot expire.
	    if (object.$expires === EXPIRES_NEVER) {
	        return;
	    }
	
	    var head = root.ツhead;
	
	    // Nothing is in the cache.
	    if (!head) {
	        root.ツhead = root.ツtail = object;
	        return;
	    }
	
	    if (head === object) {
	        return;
	    }
	
	    // The item always exist in the cache since to get anything in the
	    // cache it first must go through set.
	    var prev = object.ツprev;
	    var next = object.ツnext;
	    if (next) {
	        next.ツprev = prev;
	    }
	    if (prev) {
	        prev.ツnext = next;
	    }
	    object.ツprev = undefined;
	
	    // Insert into head position
	    root.ツhead = object;
	    object.ツnext = head;
	    head.ツprev = object;
	
	    // If the item we promoted was the tail, then set prev to tail.
	    if (object === root.ツtail) {
	        root.ツtail = prev;
	    }
	};


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	// Copies the node
	var unicodePrefix = __webpack_require__(281);
	
	module.exports = function clone(node) {
	    var outValue, i, len;
	    var keys = Object.keys(node);
	    outValue = {};
	    for (i = 0, len = keys.length; i < len; i++) {
	        var k = keys[i];
	        var k0 = k.charAt(0);
	        if (k0 === unicodePrefix) {
	            continue;
	        }
	        outValue[k] = node[k];
	    }
	    return outValue;
	};
	


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var now = __webpack_require__(274);
	module.exports = function isExpired(node) {
	    var $expires = node.$expires === void 0 && -1 || node.$expires;
	    return $expires !== -1 && $expires !== 1 && ($expires === 0 || $expires < now());
	};


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	var getValueSync = __webpack_require__(347);
	var InvalidModelError = __webpack_require__(327);
	
	module.exports = function getBoundValue(model, pathArg, materialized) {
	
	    var path = pathArg;
	    var boundPath = pathArg;
	    var boxed, treatErrorsAsValues,
	        value, shorted, found;
	
	    boxed = model._boxed;
	    materialized = model._materialized;
	    treatErrorsAsValues = model._treatErrorsAsValues;
	
	    model._boxed = true;
	    model._materialized = materialized === undefined || materialized;
	    model._treatErrorsAsValues = true;
	
	    value = getValueSync(model, path.concat(null), true);
	
	    model._boxed = boxed;
	    model._materialized = materialized;
	    model._treatErrorsAsValues = treatErrorsAsValues;
	
	    path = value.optimizedPath;
	    shorted = value.shorted;
	    found = value.found;
	    value = value.value;
	
	    while (path.length && path[path.length - 1] === null) {
	        path.pop();
	    }
	
	    if (found && shorted) {
	        throw new InvalidModelError(boundPath, path);
	    }
	
	    return {
	        path: path,
	        value: value,
	        shorted: shorted,
	        found: found
	    };
	};


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var getPathAsJSON = __webpack_require__(357);
	var getCachePosition = __webpack_require__(326);
	var InvalidModelError = __webpack_require__(327);
	
	module.exports = function getWithPathsAsPathMap(model, paths, seed) {
	
	    var ref = false;
	    var bound = model._path;
	    var cache = model._root.cache;
	    var optimizedPath, requestedPath;
	    var optimizedPathDepth = bound.length;
	
	    var node = cache;
	
	    // If the model is bound, then get that cache position.
	    if (optimizedPathDepth) {
	
	        node = getCachePosition(model, bound);
	
	        // If there was a short, then we 'throw an error' to the outside
	        // calling function which will onError the observer.
	        if (node.$type) {
	            return {
	                criticalError: new InvalidModelError(bound, bound)
	            };
	        }
	        requestedPath = [];
	        optimizedPath = bound.slice(0);
	        ref = model._referenceContainer;
	    } else {
	        requestedPath = [];
	        optimizedPath = [];
	        optimizedPathDepth = 0;
	    }
	
	    var json = seed[0];
	    var pathIndex = -1;
	    var pathCount = paths.length;
	    var outerResults = { values: seed };
	
	    while (++pathIndex < pathCount) {
	
	        var path = paths[pathIndex];
	
	        getPathAsJSON(path, 0, 'json',
	                      cache, node, json, json, ref, ref,
	                      requestedPath, 0, optimizedPath, optimizedPathDepth,
	                      model, outerResults);
	    }
	
	    return outerResults;
	}


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = getPathAsJSON;
	
	var isArray = Array.isArray;
	
	var $ref = __webpack_require__(272);
	var $nodeset = __webpack_require__(358);
	var __innerRefs = __webpack_require__(293);
	
	var promote = __webpack_require__(352);
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var onValueType = __webpack_require__(360);
	var getRefTarget = __webpack_require__(364);
	var NullInPathError = __webpack_require__(297);
	var assignCrossedRefs = __webpack_require__(298);
	
	function getPathAsJSON(// path being evaluated, the index of where we are in the
	                       // path, and the outer key we should use to write into the
	                       // JSON
	                       path, depth, outerKey,
	                       // root of the cache, the current node we're evaluating
	                       // path against, the seed of the json result, the current
	                       // json node we're writing into, a flag indicating
	                       // whether we've just crossed a reference, and the most
	                       // recent reference we've crossed
	                       root, node, seed, json, fromRef, ref,
	                       // the requested and optimized paths and their related
	                       // indicies as we evaluate the pathset
	                       requestedPath, requestedPathDepth,
	                       optimizedPath, optimizedPathDepth,
	                       // the model which defines how we create JSON results and
	                       // the outer results Object on which we report the results
	                       model, outerResults) {
	
	    // ============ Check for base cases ================
	
	    var type;
	    var height = path.length;
	    var isLeaf = depth === height;
	    var key, keys, next, keyIndex, keyCount,
	        hasMissingValue, isRange, rangeIndex, rangeCount,
	        nextDepth, nextRequestedDepth, nextOptimizedDepth;
	
	    // if nothing found in cache, add paths to set of abs and rel missing paths
	    if (node === undefined ||
	        // if atom or error JSON Graph primitive found, short curcuit
	        ((type = node.$type) && type !== $ref && type !== $nodeset) || isLeaf) {
	        return onValueType(path, depth, node, outerKey, type, seed, json,
	                           model, outerResults, fromRef,
	                           requestedPath, optimizedPath, optimizedPathDepth);
	    }
	
	    // If `ref` JSON Graph primitive found, in-line the target of the reference
	    // and continue evaluating path.
	    if (type === $ref) {
	        var refPath, refTarget;
	        // If the reference is expired, invalidate and report as a missing path.
	        if (isExpired(node)) {
	            refTarget = undefined;
	            expireNode(node, model._root.expired, model._root);
	        } else {
	            refPath = node.value;
	            assignCrossedRefs(node, null, null, model._root, promote);
	            refTarget = getRefTarget(refPath, 0, root, root,
	                                     path, depth, [], 0, model, outerResults,
	                                     node[__innerRefs] || (node[__innerRefs] = {}));
	        }
	        return refTarget === undefined ?
	            // if refTarget is undefined, build a relative missing path and short-circuit
	            onValueType(path, depth, refTarget, outerKey, undefined, seed, json,
	                        model, outerResults, true, requestedPath) :
	            // otherwise continue following the path from where the reference points to
	            getPathAsJSON(path, depth, outerKey,
	                          root, refTarget, seed, json, true, node,
	                          requestedPath, requestedPathDepth,
	                          refPath.slice(0), refPath.length,
	                          model, outerResults);
	    }
	    // node will only be an Array if getRefTarget encountered a pathSet in
	    // a ref or a refset and consequently returned a nodeset. For example
	    // getRefTarget($ref(["lists",[52,99]])) produces
	    // [ cache["lists"][52], cache["lists"][99] ]. When getPathAsJSOn
	    // is called on this output, it has to replace each ref target in the
	    // array with the result of evaluating the rest of path on the target.
	    else if (type === $nodeset) {
	
	        // If a nodeset contains a single missing value, the rest of the
	        // relative path is considered missing. The getRefTarget method
	        // has already added the absolute paths of the missing nodes to
	        // missingAbsPaths array by this point. The only thing that
	        // getPathAsJSON has to do is ensure that relativePath only gets added
	        // to missingRelPaths once - not once for every node in the
	        // nodeset. To that end, we set the missingRelPaths to undefined
	        // if any of the reftargets in the nodeset are undefined. This
	        // will prevent any of the getPathAsJSON calls performed on the ref
	        // targets from adding the relativePath to the missingRelPaths
	        // array. After call getPathAsJSON on each refTarget we add the
	        // relative missing path _once_, at the bottom of the loop.
	
	        keys = node.$keys;
	        nextDepth = depth;
	        hasMissingValue = node.$hasMissingValue;
	        nextRequestedDepth = requestedPathDepth;
	        nextOptimizedDepth = optimizedPathDepth;
	        optimizedPathDepth -= 1;
	
	        // If a JSON seed exists, build or use the JSON branch that corresponds
	        // to this keyset.
	        if (json) {
	            json = json[outerKey] || (json[outerKey] = {});
	            json.$keys = keys;
	            json.$type = $nodeset;
	            node.$path && (json.$path = node.$path);
	            node.$version && (json.$version = node.$version);
	            if (depth > 0 && ref && model._allowFromWhenceYouCame) {
	                json.$refPath = ref.value;
	                json.$toReference = ref.ツabsolutePath;
	            }
	        }
	
	        if (isArray(keys)) {
	            keyIndex = 0;
	            keyCount = keys.length;
	            // return undefined if there is an empty keyset in the path.
	            // An example of an empty keyset is: ['lolomo', [], 'summary'].
	            // This should short circuit without building missing paths.
	            if (keyCount === 0) {
	                return undefined;
	            }
	            do {
	                key = keys[keyIndex];
	                // If the key is null, throw an error.
	                // null isn't allowed in keysets.
	                if (key == null) {
	                    throw new NullInPathError();
	                }
	                // If key is a primitive, evaluate against node and bump the depth
	                else if (typeof key !== "object") {
	                    next = node[key];
	                    if (next !== undefined) {
	                        optimizedPath[optimizedPathDepth] = key;
	                        getPathAsJSON(path, nextDepth, key,
	                                      root, next, seed, json, false, ref,
	                                      requestedPath, nextRequestedDepth,
	                                      optimizedPath, nextOptimizedDepth,
	                                      model, outerResults);
	                    } else {
	                        hasMissingValue = true;
	                    }
	                }
	                // if range found in keyset, recursively call getPathAsJSON over
	                // each index in range
	                else {
	                    rangeIndex = (key.from || 0) - 1;
	                    if (typeof (rangeCount = key.to) !== "number") {
	                        rangeCount = rangeIndex + (key.length || 0);
	                    }
	                    while (++rangeIndex <= rangeCount) {
	                        next = node[rangeIndex];
	                        if (next !== undefined) {
	                            optimizedPath[optimizedPathDepth] = rangeIndex;
	                            getPathAsJSON(path, nextDepth, rangeIndex,
	                                          root, next, seed, json, false, ref,
	                                          requestedPath, nextRequestedDepth,
	                                          optimizedPath, nextOptimizedDepth,
	                                          model, outerResults);
	                        } else {
	                            hasMissingValue = true;
	                        }
	                    }
	                }
	            } while (++keyIndex < keyCount);
	        }
	        // If keys is not a keyset it must be a range
	        else {
	            key = keys;
	            rangeIndex = (key.from || 0) - 1;
	            if (typeof (rangeCount = key.to) !== "number") {
	                rangeCount = rangeIndex + (key.length || 0);
	            }
	            while (++rangeIndex <= rangeCount) {
	                next = node[rangeIndex];
	                if (next !== undefined) {
	                    optimizedPath[optimizedPathDepth] = rangeIndex;
	                    getPathAsJSON(path, nextDepth, rangeIndex,
	                                  root, next, seed, json, false, ref,
	                                  requestedPath, nextRequestedDepth,
	                                  optimizedPath, nextOptimizedDepth,
	                                  model, outerResults);
	                } else {
	                    hasMissingValue = true;
	                }
	            }
	        }
	
	        // If the nodeset contains at least one missing value, add the requested
	        // path to the requestedMissingPaths once.
	        if (hasMissingValue) {
	            onMissing(model, path, depth, outerResults, requestedPath);
	        }
	
	        return json;
	    }
	
	    // ======= Is Path Key null, a Key Set, a Range, or a primitive key? =======
	    keys = path[depth];
	    nextDepth = depth + 1;
	    nextRequestedDepth = requestedPathDepth + 1;
	    nextOptimizedDepth = optimizedPathDepth + 1;
	
	    if (json) {
	        json = json[outerKey] || (json[outerKey] = {});
	        if (depth > 0) {
	            json.$path = node.ツabsolutePath;
	            json.$version = node.ツversion;
	            if (ref && model._allowFromWhenceYouCame) {
	                json.$refPath = ref.value;
	                json.$toReference = ref.ツabsolutePath;
	            }
	        }
	    }
	
	    // A null key can only appear at the end of a path. It's only useful for
	    // indicating that the target of ref should be returned rather than the
	    // ref itself. Inserting null at the end of path lengthens the path and
	    // ensures we follow the ref before hitting the end condition above
	    // (exit when pathIndex === pathSetLength).
	    if (keys == null) {
	        if (nextDepth === height) {
	            return getPathAsJSON(path, nextDepth, outerKey,
	                                 root, node, seed, json, false, ref,
	                                 requestedPath, requestedPathDepth,
	                                 optimizedPath, optimizedPathDepth,
	                                 model, outerResults);
	        }
	        throw new NullInPathError();
	    }
	    // If the key is just a primitive, add the key to the end of the abs and rel
	    // paths, and return an Object that contains the result of recursively
	    // evaluating the rest of the path.
	    else if (typeof keys !== "object") {
	        key = keys;
	        requestedPath[requestedPathDepth] = key;
	        optimizedPath[optimizedPathDepth] = key;
	        getPathAsJSON(path, nextDepth, key,
	                      root, node[key], seed, json, false, ref,
	                      requestedPath, nextRequestedDepth,
	                      optimizedPath, nextOptimizedDepth,
	                      model, outerResults);
	    }
	    // If key is a Key Set, recursively call getPathAsJSON over each key inside
	    // the key set
	    else {
	        json.$keys = keys;
	        if (isArray(keys)) {
	            keyIndex = 0;
	            keyCount = keys.length;
	            // return undefined if there is an empty keyset in the path.
	            // An example of an empty keyset is: ['lolomo', [], 'summary'].
	            // This should short circuit without building missing paths.
	            if (keyCount === 0) {
	                return undefined;
	            }
	            do {
	                key = keys[keyIndex];
	                // If the key is null, throw an error.
	                // null isn't allowed in keysets.
	                if (key == null) {
	                    throw new NullInPathError();
	                }
	                // If key is a primitive, evaluate against node and bump the depth
	                else if (typeof key !== "object") {
	                    next = node[key];
	                    requestedPath[requestedPathDepth] = key;
	                    optimizedPath[optimizedPathDepth] = key;
	                    getPathAsJSON(path, nextDepth, key,
	                                  root, next, seed, json, false, ref,
	                                  requestedPath, nextRequestedDepth,
	                                  optimizedPath, nextOptimizedDepth,
	                                  model, outerResults);
	                }
	                // if range found in keyset, recursively call getPathAsJSON over
	                // each index in range
	                else {
	                    rangeIndex = (key.from || 0) - 1;
	                    if (typeof (rangeCount = key.to) !== "number") {
	                        rangeCount = rangeIndex + (key.length || 0);
	                    }
	                    while (++rangeIndex <= rangeCount) {
	                        next = node[rangeIndex];
	                        requestedPath[requestedPathDepth] = rangeIndex;
	                        optimizedPath[optimizedPathDepth] = rangeIndex;
	                        getPathAsJSON(path, nextDepth, rangeIndex,
	                                      root, next, seed, json, false, ref,
	                                      requestedPath, nextRequestedDepth,
	                                      optimizedPath, nextOptimizedDepth,
	                                      model, outerResults);
	                    }
	                }
	            } while (++keyIndex < keyCount);
	        }
	        // if range, recursively call getPathAsJSON over each index in range
	        else {
	            key = keys;
	            rangeIndex = (key.from || 0) - 1;
	            if (typeof (rangeCount = key.to) !== "number") {
	                rangeCount = rangeIndex + (key.length || 0);
	            }
	            while (++rangeIndex <= rangeCount) {
	                next = node[rangeIndex];
	                requestedPath[requestedPathDepth] = rangeIndex;
	                optimizedPath[optimizedPathDepth] = rangeIndex;
	                getPathAsJSON(path, nextDepth, rangeIndex,
	                              root, next, seed, json, false, ref,
	                              requestedPath, nextRequestedDepth,
	                              optimizedPath, nextOptimizedDepth,
	                              model, outerResults);
	            }
	        }
	    }
	
	    return json;
	}


/***/ },
/* 358 */
/***/ function(module, exports) {

	module.exports = "nodeset";


/***/ },
/* 359 */
/***/ function(module, exports) {

	module.exports = function onMissing(model, path, depth,
	                                    outerResults, requestedPath,
	                                    optimizedPath, optimizedLength) {
	
	    var pathKey;
	    var pathCount = path.length;
	    var restPathIndex = -1;
	    var restPathCount = pathCount - depth;
	    var restPath = restPathCount && new Array(restPathCount) || undefined;
	
	    while (++restPathIndex < restPathCount) {
	        if (isEmptyKeySet(pathKey = path[restPathIndex + depth])) {
	            return;
	        }
	        restPath[restPathIndex] = pathKey;
	    }
	
	    if (requestedPath) {
	
	        var rPathCount = pathCount;
	        var rPath = new Array(rPathCount);
	        var rIndex = -1;
	        var rCount = depth;
	        while (++rIndex < rCount) {
	            rPath[rIndex] = requestedPath[rIndex];
	        }
	
	        rIndex -= 1;
	        restPathIndex = -1;
	        rCount = rPathCount;
	        while (++rIndex < rCount) {
	            rPath[rIndex] = restPath[++restPathIndex];
	        }
	
	        var rPaths = outerResults.requestedMissingPaths;
	        if (!rPaths) {
	            outerResults.requestedMissingPaths = [rPath];
	        } else {
	            rPaths.push(rPath);
	        }
	    }
	
	    if (optimizedPath) {
	
	        var oPathCount = optimizedLength + (pathCount - depth);
	        var oPath = new Array(oPathCount);
	        var oIndex = -1;
	        var oCount = optimizedLength;
	        while (++oIndex < oCount) {
	            oPath[oIndex] = optimizedPath[oIndex];
	        }
	
	        oIndex -= 1;
	        restPathIndex = -1;
	        oCount = oPathCount;
	        while (++oIndex < oCount) {
	            oPath[oIndex] = restPath[++restPathIndex];
	        }
	
	        var oPaths = outerResults.optimizedMissingPaths;
	        if (!oPaths) {
	            outerResults.optimizedMissingPaths = [oPath];
	        } else {
	            oPaths.push(oPath);
	        }
	    }
	};
	
	function isEmptyKeySet(atom) {
	    var type = typeof atom;
	    if (type !== "object") {
	        return false;
	    }
	
	    var isArray = Array.isArray(atom);
	    if (isArray && atom.length) {
	        return false;
	    }
	
	    // Empty array
	    else if (isArray) {
	        return true;
	    }
	
	    var from = atom.from;
	    var to = atom.to;
	    if (from === undefined || from <= to) {
	        return false;
	    }
	
	    return true;
	}


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = onValueType;
	
	var $atom = __webpack_require__(307);
	
	var onValue = __webpack_require__(361);
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var isMaterialized = __webpack_require__(363);
	
	function onValueType(path, depth, node, key, type, seed, json,
	                     model, outer, fromRef,
	                     requestedPath, optimizedPath, optimizedPathDepth) {
	
	    if (!node || !type) {
	        if (isMaterialized(model)) {
	            outer.hasValue = true;
	            return json && (json[key] = {$type:$atom}) || undefined;
	        } else {
	            return onMissing(model, path, depth, outer,
	                             requestedPath, optimizedPath, optimizedPathDepth);
	        }
	    } else if (isExpired(node)) {
	        if (!node.ツinvalidated) {
	            expireNode(node, model._root.expired, model._root);
	        }
	        return onMissing(model, path, depth, outer,
	                         requestedPath, optimizedPath, optimizedPathDepth);
	    } else if (seed) {
	        if (fromRef) {
	            requestedPath[depth] = null;
	        }
	        return onValue(path, depth, node, key, type, seed, json,
	                       model, outer, requestedPath);
	    }
	}


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = onValue;
	
	var $atom = __webpack_require__(307);
	var $error = __webpack_require__(300);
	
	var clone = __webpack_require__(353);
	var promote = __webpack_require__(352);
	var onError = __webpack_require__(362);
	
	function onValue(path, depth, node, key, type, seed, json,
	                 model, outer, requestedPath) {
	
	    promote(model._root, node);
	
	    if (!seed) {
	        return;
	    }
	
	    if (type === $error && !model._treatErrorsAsValues) {
	        return onError(model, node, depth, requestedPath, outer);
	    } else {
	        var value = node && node.value;
	        var requiresMaterializedToReport = type && value === undefined;
	        if (requiresMaterializedToReport) {
	            if (model._materialized) {
	                outer.hasValue = true;
	                return json[key] = {$type:$atom};
	            }
	        } else if (model._boxed) {
	            outer.hasValue = true;
	            return json[key] = clone(node);
	        } else {
	            outer.hasValue = true;
	            return json[key] = value;
	        }
	    }
	}


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var promote = __webpack_require__(352);
	var clone = __webpack_require__(353);
	
	module.exports = function onError(model, node, depth,
	                                  requestedPath, outerResults) {
	    var value = node.value;
	    if (!outerResults.errors) {
	        outerResults.errors = [];
	    }
	
	    if (model._boxed) {
	        value = clone(node);
	    }
	    outerResults.errors.push({
	        path: requestedPath.slice(0, depth + 1),
	        value: value
	    });
	    promote(model._root, node);
	};


/***/ },
/* 363 */
/***/ function(module, exports) {

	module.exports = function isMaterialized(model) {
	    return model._materialized && !model._source;
	};


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = getRefTarget;
	
	var isArray = Array.isArray;
	
	var $ref = __webpack_require__(272);
	var $nodeset = __webpack_require__(358);
	var __innerRefs = __webpack_require__(293);
	
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var NullInPathError = __webpack_require__(297);
	var assignCrossedRefs = __webpack_require__(298);
	
	/* eslint-disable no-constant-condition */
	function getRefTarget(path, depth, root, node,
	                      outerPath, outerPathDepth,
	                      optimizedPath, optimizedPathDepth,
	                      model, outerResults, innerRefs) {
	
	    var type;
	    var height = path.length;
	
	    var key, keys, next, json,
	        hasMissingValue, nextDepth, nextOptimizedDepth,
	        keyIndex, keyCount, isRange, rangeIndex, rangeCount;
	
	    do {
	        var isLeaf = depth === height;
	
	        // ============ Check for base cases ================
	
	        // if nothing found in cache, add paths to set of abs and rel missing paths
	        if (node === undefined) {
	            return onMissing(model, outerPath, outerPathDepth, outerResults,
	                             undefined, optimizedPath, optimizedPathDepth);
	        }
	        // if atom or error JSON Graph primitive found, short curcuit
	        else if (((type = node.$type) && type !== $ref && type !== $nodeset) || isLeaf) {
	            return node;
	        }
	        // if ref JSON Graph primitive found, grab target of the reference
	        // and continue evaluating rest of ref path against it.
	        else if (type === $ref) {
	            var refPath, refTarget;
	            if (isExpired(node)) {
	                refTarget = undefined;
	                expireNode(node, model._root.expired, model._root);
	            } else {
	                refPath = node.value;
	                assignCrossedRefs(node, innerRefs, null, model._root, promote);
	                refTarget = getRefTarget(refPath, 0, root, root, outerPath,
	                                         outerPathDepth, [], 0, model, outerResults,
	                                         node[__innerRefs] || (node[__innerRefs] = {}));
	            }
	            // if refTarget comes back undefined short-circuit
	            return refTarget === undefined ?
	                undefined : getRefTarget(path, depth, root, refTarget,
	                                         outerPath, outerPathDepth,
	                                         refPath.slice(0), refPath.length,
	                                         model, outerResults, innerRefs);
	        }
	        // node will only be an Array if getRefTarget encountered a pathSet in
	        // a ref or a refset and consequently returned a nodeset. For example
	        // getRefTarget($ref(["lists",[52,99]])) produces
	        // [ cache["lists"][52], cache["lists"][99] ]. When getRefTarget
	        // is called on this output, it has to replace each ref target in the
	        // array with the result of evaluating the rest of path on the target.
	        else if (type === $nodeset) {
	            json = node;
	            keys = node.$keys;
	            nextDepth = depth;
	            hasMissingValue = false;
	            nextOptimizedDepth = optimizedPathDepth + 1;
	
	            if (isArray(keys)) {
	                keyIndex = 0;
	                keyCount = keys.length;
	                // return undefined if there is an empty keyset in the path.
	                // An example of an empty keyset is: ['lolomo', [], 'summary'].
	                // This should short circuit without building missing paths.
	                if (keyCount === 0) {
	                    return undefined;
	                }
	                do {
	                    key = keys[keyIndex];
	                    // If the key is null, throw an error.
	                    // null isn't allowed in keysets.
	                    if (key == null) {
	                        throw new NullInPathError();
	                    }
	                    // If key is a primitive, evaluate against node and bump the depth
	                    else if (typeof key !== "object") {
	                        next = node[key];
	                        optimizedPath[optimizedPathDepth] = key;
	                        if (next !== undefined) {
	                            next = getRefTarget(path, nextDepth, root, next,
	                                                outerPath, outerPathDepth, optimizedPath,
	                                                nextOptimizedDepth, model, outerResults, innerRefs);
	                            if (next !== undefined) {
	                                json[key] = next;
	                            }
	                        }
	                    }
	                    // if range found in keyset, recursively call getRefTarget
	                    // over each index in range
	                    else {
	                        rangeIndex = (key.from || 0) - 1;
	                        if (typeof (rangeCount = key.to) !== "number") {
	                            rangeCount = rangeIndex + (key.length || 0);
	                        }
	                        while (++rangeIndex <= rangeCount) {
	                            next = node[rangeIndex];
	                            optimizedPath[optimizedPathDepth] = rangeIndex;
	                            if (next !== undefined) {
	                                next = getRefTarget(path, nextDepth, root, next,
	                                                    outerPath, outerPathDepth, optimizedPath,
	                                                    nextOptimizedDepth, model, outerResults, innerRefs);
	                                if (next !== undefined) {
	                                    json[rangeIndex] = next;
	                                }
	                            }
	                        }
	                    }
	                } while (++keyIndex < keyCount);
	            }
	            // If keys is not a keyset it must be a range
	            else {
	                key = keys;
	                rangeIndex = (key.from || 0) - 1;
	                if (typeof (rangeCount = key.to) !== "number") {
	                    rangeCount = rangeIndex + (key.length || 0);
	                }
	                while (++rangeIndex <= rangeCount) {
	                    next = node[rangeIndex];
	                    optimizedPath[optimizedPathDepth] = rangeIndex;
	                    if (next !== undefined) {
	                        next = getRefTarget(path, nextDepth, root, next,
	                                            outerPath, outerPathDepth, optimizedPath,
	                                            nextOptimizedDepth, model, outerResults, innerRefs);
	                        if (next !== undefined) {
	                            json[rangeIndex] = next;
	                        }
	                    }
	                }
	            }
	            return json;
	        }
	
	        // ===== Is Path Key null, a Key Set, a Range, or a primitive key? =====
	
	        keys = path[depth];
	        nextDepth = depth + 1;
	        hasMissingValue = false;
	        nextOptimizedDepth = optimizedPathDepth + 1;
	
	        // If the keyset is null, throw an error.
	        // nulls aren't allowed in references.
	        if (keys == null) {
	            // if (nextDepth === height) {
	            //     depth = nextDepth;
	            //     continue;
	            // }
	            throw new NullInPathError();
	        }
	        // If key is a primitive, evaluate against node and bump the depth
	        else if (typeof keys !== "object") {
	            // simulate tail recursion
	            key = keys;
	            node = node[key];
	            depth = nextDepth;
	            optimizedPath[optimizedPathDepth] = key;
	            optimizedPathDepth = nextOptimizedDepth;
	            continue;
	        }
	
	        // node will only be an Array if getRefTarget encountered a pathSet in
	        // a ref or a refset. For example getRefTarget($ref(["lists",[52,99]]))
	        // produces [ cache["lists"][52], cache["lists"][99] ]. When
	        // getPathAsJSON is called on this output, it has to replace each ref
	        // target in the array with the result of evaluating the rest of path on
	        // the target.
	
	        json = { $type: $nodeset, $keys: keys };
	
	        if (depth > 0) {
	            json.$path = node.ツabsolutePath;
	            json.$version = node.ツversion;
	        }
	
	        if (isArray(keys)) {
	            keyIndex = 0;
	            keyCount = keys.length;
	            // return undefined if there is an empty keyset in the path.
	            // An example of an empty keyset is: ['lolomo', [], 'summary'].
	            // This should short circuit without building missing paths.
	            if (keyCount === 0) {
	                return undefined;
	            }
	            do {
	                key = keys[keyIndex];
	                // If the key is null, throw an error.
	                // null isn't allowed in keysets.
	                if (key == null) {
	                    throw new NullInPathError();
	                }
	                // If key is a primitive, evaluate against node and bump the depth
	                else if (typeof key !== "object") {
	                    next = node[key];
	                    optimizedPath[optimizedPathDepth] = key;
	                    next = getRefTarget(path, nextDepth, root, next,
	                                        outerPath, outerPathDepth, optimizedPath,
	                                        nextOptimizedDepth, model, outerResults, innerRefs);
	                    if (next !== undefined) {
	                        json[key] = next;
	                    } else {
	                        hasMissingValue = true;
	                    }
	                }
	                // if range found in keyset, recursively call getRefTarget
	                // over each index in range
	                else {
	                    rangeIndex = (key.from || 0) - 1;
	                    if (typeof (rangeCount = key.to) !== "number") {
	                        rangeCount = rangeIndex + (key.length || 0);
	                    }
	                    while (++rangeIndex <= rangeCount) {
	                        next = node[rangeIndex];
	                        optimizedPath[optimizedPathDepth] = rangeIndex;
	                        next = getRefTarget(path, nextDepth, root, next,
	                                            outerPath, outerPathDepth, optimizedPath,
	                                            nextOptimizedDepth, model, outerResults, innerRefs);
	                        if (next !== undefined) {
	                            json[rangeIndex] = next;
	                        } else {
	                            hasMissingValue = true;
	                        }
	                    }
	                }
	            } while (++keyIndex < keyCount);
	        }
	        // If keys is not a keyset it must be a range
	        else {
	            key = keys;
	            rangeIndex = (key.from || 0) - 1;
	            if (typeof (rangeCount = key.to) !== "number") {
	                rangeCount = rangeIndex + (key.length || 0);
	            }
	            while (++rangeIndex <= rangeCount) {
	                next = node[rangeIndex];
	                optimizedPath[optimizedPathDepth] = rangeIndex;
	                next = getRefTarget(path, nextDepth, root, next,
	                                    outerPath, outerPathDepth, optimizedPath,
	                                    nextOptimizedDepth, model, outerResults, innerRefs);
	                if (next !== undefined) {
	                    json[rangeIndex] = next;
	                } else {
	                    hasMissingValue = true;
	                }
	            }
	        }
	
	        if (hasMissingValue) {
	            json.$hasMissingValue = true;
	        }
	
	        return json;
	    } while (true);
	}
	/* eslint-enable */


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var getPathAsJSONGraph = __webpack_require__(366);
	var BoundJSONGraphModelError = __webpack_require__(318);
	
	module.exports = function getWithPathsAsJSONGraph(model, paths, seed) {
	
	    var bound = model._path;
	    var cache = model._root.cache;
	
	    // If the model is bound, then get that cache position.
	    if (bound.length) {
	        // JSONGraph output cannot ever be bound or else it will
	        // throw an error.
	        return {
	            criticalError: new BoundJSONGraphModelError()
	        };
	    }
	
	    var json = seed[0];
	    var requestedPath = [];
	    var optimizedPath = [];
	
	    var pathIndex = -1;
	    var pathCount = paths.length;
	    var outerResults = { values: seed };
	
	    while (++pathIndex < pathCount) {
	
	        var path = paths[pathIndex];
	
	        getPathAsJSONGraph(path, 0, 'jsonGraph',
	                           cache, cache, json, false, false,
	                           requestedPath, 0, optimizedPath, 0,
	                           model, outerResults);
	    }
	
	    return outerResults;
	}


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = getPathAsJSONGraph;
	
	var isArray = Array.isArray;
	
	var $ref = __webpack_require__(272);
	var $nodeset = __webpack_require__(358);
	var __innerRefs = __webpack_require__(293);
	
	var promote = __webpack_require__(352);
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var onValue = __webpack_require__(367);
	var onValueType = __webpack_require__(368);
	var getRefTarget = __webpack_require__(369);
	var NullInPathError = __webpack_require__(297);
	var assignCrossedRefs = __webpack_require__(298);
	
	function getPathAsJSONGraph(// path being evaluated, the index of where we are in the
	                            // path, and the outer key we should use to write into the
	                            // JSON
	                            path, depth, outerKey,
	                            // root of the cache, the current node we're
	                            // evaluating the path against, the seed of the json
	                            // result, a flag indicating whether we've just
	                            // crossed a reference, and the most recent
	                            // reference we've crossed
	                            root, node, seed, fromRef, ref,
	                            // the requested and optimized paths and their related
	                            // indicies as we evaluate the pathset
	                            requestedPath, requestedPathDepth,
	                            optimizedPath, optimizedPathDepth,
	                            // the model which defines how we create JSON results and
	                            // the outer results Object on which we report the results
	                            model, outerResults) {
	
	    // ============ Check for base cases ================
	
	    var type;
	    var height = path.length;
	    var isLeaf = depth === height;
	    var key, keys, next, keyIndex, keyCount,
	        hasMissingValue, isRange, rangeIndex, rangeCount,
	        nextDepth, nextRequestedDepth, nextOptimizedDepth;
	
	    // if nothing found in cache, add paths to set of abs and rel missing paths
	    if (node === undefined ||
	        // if atom or error JSON Graph primitive found, short curcuit
	        ((type = node.$type) && type !== $ref && type !== $nodeset) || isLeaf) {
	        return onValueType(path, depth, node, type, seed, model, outerResults,
	                           fromRef, requestedPath, optimizedPath, optimizedPathDepth);
	    }
	
	    // If `ref` JSON Graph primitive found, in-line the target of the reference
	    // and continue evaluating path.
	    if (type === $ref) {
	        var refPath, refTarget;
	        // If the reference is expired, invalidate and report as a missing path.
	        if (isExpired(node)) {
	            refTarget = undefined;
	            expireNode(node, model._root.expired, model._root);
	        } else {
	            refPath = node.value;
	            assignCrossedRefs(node, null, null, model._root, promote);
	            onValue(path, depth, node, type, seed,
	                    model, outerResults, optimizedPath, optimizedPathDepth);
	            refTarget = getRefTarget(refPath, 0, root, root,
	                                     path, depth, [], 0, model, outerResults,
	                                     node[__innerRefs] || (node[__innerRefs] = {}), seed);
	        }
	        return refTarget === undefined ?
	            // if refTarget is undefined, build a relative missing path and short-circuit
	            onValueType(path, depth, refTarget, undefined, seed,
	                        model, outerResults, true, requestedPath) :
	            // otherwise continue following the path from where the reference points to
	            getPathAsJSONGraph(path, depth, outerKey,
	                               root, refTarget, seed, true, node,
	                               requestedPath, requestedPathDepth,
	                               refPath.slice(0), refPath.length,
	                               model, outerResults);
	    }
	    // node will only be an Array if getRefTarget encountered a pathSet in
	    // a ref or a refset and consequently returned a nodeset. For example
	    // getRefTarget($ref(["lists",[52,99]])) produces
	    // [ cache["lists"][52], cache["lists"][99] ]. When getPath
	    // is called on this output, it has to replace each ref target in the
	    // array with the result of evaluating the rest of path on the target.
	    else if (type === $nodeset) {
	
	        // If a nodeset contains a single missing value, the rest of the
	        // relative path is considered missing. The getRefTarget method
	        // has already added the absolute paths of the missing nodes to
	        // missingAbsPaths array by this point. The only thing that
	        // getPathAsJSONGraph has to do is ensure that relativePath only gets added
	        // to missingRelPaths once - not once for every node in the
	        // nodeset. To that end, we set the missingRelPaths to undefined
	        // if any of the reftargets in the nodeset are undefined. This
	        // will prevent any of the getPathAsJSONGraph calls performed on the ref
	        // targets from adding the relativePath to the missingRelPaths
	        // array. After call getPathAsJSONGraph on each refTarget we add the
	        // relative missing path _once_, at the bottom of the loop.
	
	        keys = node.$keys;
	        nextDepth = depth;
	        hasMissingValue = node.$hasMissingValue;
	        nextRequestedDepth = requestedPathDepth;
	        nextOptimizedDepth = optimizedPathDepth;
	        optimizedPathDepth -= 1;
	
	        if (isArray(keys)) {
	            keyIndex = 0;
	            keyCount = keys.length;
	            // return undefined if there is an empty keyset in the path.
	            // An example of an empty keyset is: ['lolomo', [], 'summary'].
	            // This should short circuit without building missing paths.
	            if (keyCount === 0) {
	                return undefined;
	            }
	            do {
	                key = keys[keyIndex];
	                // If the key is null, throw an error.
	                // null isn't allowed in keysets.
	                if (key == null) {
	                    throw new NullInPathError();
	                }
	                // If key is a primitive, evaluate against node and bump the depth
	                else if (typeof key !== "object") {
	                    next = node[key];
	                    if (next !== undefined) {
	                        optimizedPath[optimizedPathDepth] = key;
	                        getPathAsJSONGraph(path, nextDepth, key,
	                                           root, next, seed, false, ref,
	                                           requestedPath, nextRequestedDepth,
	                                           optimizedPath, nextOptimizedDepth,
	                                           model, outerResults);
	                    } else {
	                        hasMissingValue = true;
	                    }
	                }
	                // if range found in keyset, recursively call getPathAsJSONGraph over
	                // each index in range
	                else {
	                    rangeIndex = (key.from || 0) - 1;
	                    if (typeof (rangeCount = key.to) !== "number") {
	                        rangeCount = rangeIndex + (key.length || 0);
	                    }
	                    while (++rangeIndex <= rangeCount) {
	                        next = node[rangeIndex];
	                        if (next !== undefined) {
	                            optimizedPath[optimizedPathDepth] = rangeIndex;
	                            getPathAsJSONGraph(path, nextDepth, rangeIndex,
	                                               root, next, seed, false, ref,
	                                               requestedPath, nextRequestedDepth,
	                                               optimizedPath, nextOptimizedDepth,
	                                               model, outerResults);
	                        } else {
	                            hasMissingValue = true;
	                        }
	                    }
	                }
	            } while (++keyIndex < keyCount);
	        }
	        // If keys is not a keyset it must be a range
	        else {
	            key = keys;
	            rangeIndex = (key.from || 0) - 1;
	            if (typeof (rangeCount = key.to) !== "number") {
	                rangeCount = rangeIndex + (key.length || 0);
	            }
	            while (++rangeIndex <= rangeCount) {
	                next = node[rangeIndex];
	                if (next !== undefined) {
	                    optimizedPath[optimizedPathDepth] = rangeIndex;
	                    getPathAsJSONGraph(path, nextDepth, rangeIndex,
	                                       root, next, seed, false, ref,
	                                       requestedPath, nextRequestedDepth,
	                                       optimizedPath, nextOptimizedDepth,
	                                       model, outerResults);
	                } else {
	                    hasMissingValue = true;
	                }
	            }
	        }
	
	        // If the nodeset contains at least one missing value, add the requested
	        // path to the requestedMissingPaths once.
	        if (hasMissingValue) {
	            onMissing(model, path, depth, outerResults, requestedPath);
	        }
	
	        return node;
	    }
	
	    // ======= Is Path Key null, a Key Set, a Range, or a primitive key? =======
	    keys = path[depth];
	    nextDepth = depth + 1;
	    nextRequestedDepth = requestedPathDepth + 1;
	    nextOptimizedDepth = optimizedPathDepth + 1;
	
	    // A null key can only appear at the end of a path. It's only useful for
	    // indicating that the target of ref should be returned rather than the
	    // ref itself. Inserting null at the end of path lengthens the path and
	    // ensures we follow the ref before hitting the end condition above
	    // (exit when pathIndex === pathSetLength).
	    if (keys == null) {
	        if (nextDepth === height) {
	            return getPathAsJSONGraph(path, nextDepth, outerKey,
	                                      root, node, seed, false, ref,
	                                      requestedPath, requestedPathDepth,
	                                      optimizedPath, optimizedPathDepth,
	                                      model, outerResults);
	        }
	        throw new NullInPathError();
	    }
	    // If the key is just a primitive, add the key to the end of the abs and rel
	    // paths, and return an Object that contains the result of recursively
	    // evaluating the rest of the path.
	    else if (typeof keys !== "object") {
	        key = keys;
	        requestedPath[requestedPathDepth] = key;
	        optimizedPath[optimizedPathDepth] = key;
	        getPathAsJSONGraph(path, nextDepth, key,
	                           root, node[key], seed, false, ref,
	                           requestedPath, nextRequestedDepth,
	                           optimizedPath, nextOptimizedDepth,
	                           model, outerResults);
	    }
	    // If key is a Key Set, recursively call getPathAsJSONGraph over each key inside
	    // the key set
	    else if (isArray(keys)) {
	        keyIndex = 0;
	        keyCount = keys.length;
	        // return undefined if there is an empty keyset in the path.
	        // An example of an empty keyset is: ['lolomo', [], 'summary'].
	        // This should short circuit without building missing paths.
	        if (keyCount === 0) {
	            return undefined;
	        }
	        do {
	            key = keys[keyIndex];
	            // If the key is null, throw an error.
	            // null isn't allowed in keysets.
	            if (key == null) {
	                throw new NullInPathError();
	            }
	            // If key is a primitive, evaluate against node and bump the depth
	            else if (typeof key !== "object") {
	                next = node[key];
	                requestedPath[requestedPathDepth] = key;
	                optimizedPath[optimizedPathDepth] = key;
	                getPathAsJSONGraph(path, nextDepth, key,
	                                   root, next, seed, false, ref,
	                                   requestedPath, nextRequestedDepth,
	                                   optimizedPath, nextOptimizedDepth,
	                                   model, outerResults);
	            }
	            // if range found in keyset, recursively call getPathAsJSONGraph over
	            // each index in range
	            else {
	                rangeIndex = (key.from || 0) - 1;
	                if (typeof (rangeCount = key.to) !== "number") {
	                    rangeCount = rangeIndex + (key.length || 0);
	                }
	                while (++rangeIndex <= rangeCount) {
	                    next = node[rangeIndex];
	                    requestedPath[requestedPathDepth] = rangeIndex;
	                    optimizedPath[optimizedPathDepth] = rangeIndex;
	                    getPathAsJSONGraph(path, nextDepth, rangeIndex,
	                                       root, next, seed, false, ref,
	                                       requestedPath, nextRequestedDepth,
	                                       optimizedPath, nextOptimizedDepth,
	                                       model, outerResults);
	                }
	            }
	        } while (++keyIndex < keyCount);
	    }
	    // if range, recursively call getPathAsJSONGraph over each index in range
	    else {
	        key = keys;
	        rangeIndex = (key.from || 0) - 1;
	        if (typeof (rangeCount = key.to) !== "number") {
	            rangeCount = rangeIndex + (key.length || 0);
	        }
	        while (++rangeIndex <= rangeCount) {
	            next = node[rangeIndex];
	            requestedPath[requestedPathDepth] = rangeIndex;
	            optimizedPath[optimizedPathDepth] = rangeIndex;
	            getPathAsJSONGraph(path, nextDepth, rangeIndex,
	                               root, next, seed, false, ref,
	                               requestedPath, nextRequestedDepth,
	                               optimizedPath, nextOptimizedDepth,
	                               model, outerResults);
	        }
	    }
	
	    return node;
	}


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = onValue;
	
	var isArray = Array.isArray;
	var $atom = __webpack_require__(307);
	var clone = __webpack_require__(353);
	var promote = __webpack_require__(352);
	
	function onValue(path, depth, node, type, seed,
	                 model, outer, optimizedPath, optimizedPathDepth) {
	
	    promote(model._root, node);
	
	    if (!seed) {
	        return;
	    }
	
	    outer.hasValue = true;
	
	    var value = node.value;
	    var materialized = value === undefined ? model._materialized : false;
	
	    if (type !== $atom ||
	        model._boxed   || !(
	        node.ツmodelCreated) || (
	        value && typeof value === "object")) {
	        value = clone(node);
	    } else {
	        value = materialized ? {$type:$atom} : value;
	    }
	
	    var key = 'jsonGraph',
	        json = seed, index = -1;
	
	    while (++index < optimizedPathDepth) {
	        json = json[key] || (json[key] = {});
	        key = optimizedPath[index];
	    }
	
	    json[key] = value;
	
	    return value;
	}


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = onValueType;
	
	var $atom = __webpack_require__(307);
	
	var onValue = __webpack_require__(367);
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var isMaterialized = __webpack_require__(363);
	
	function onValueType(path, depth, node, type, seed,
	                     model, outer, fromRef,
	                     requestedPath, optimizedPath, optimizedPathDepth) {
	
	    if (!node || !type) {
	        if (isMaterialized(model)) {
	            outer.hasValue = true;
	            return onValue(path, depth, {$type:$atom}, type, seed,
	                           model, outer, optimizedPath, optimizedPathDepth);
	        } else {
	            return onMissing(model, path, depth, outer,
	                             requestedPath, optimizedPath, optimizedPathDepth);
	        }
	    } else if (isExpired(node)) {
	        if (!node.ツinvalidated) {
	            expireNode(node, model._root.expired, model._root);
	        }
	        return onMissing(model, path, depth, outer,
	                         requestedPath, optimizedPath, optimizedPathDepth);
	    } else if (seed) {
	        if (fromRef) {
	            requestedPath[depth] = null;
	        }
	        var paths = seed.paths;
	        if (!paths) {
	            seed.paths = [requestedPath.slice(0, depth)];
	        } else {
	            paths.push(requestedPath.slice(0, depth));
	        }
	        return onValue(path, depth, node, type, seed,
	                       model, outer, optimizedPath, optimizedPathDepth);
	    }
	}


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = getRefTarget;
	
	var isArray = Array.isArray;
	
	var $ref = __webpack_require__(272);
	var $nodeset = __webpack_require__(358);
	var __innerRefs = __webpack_require__(293);
	
	var onValue = __webpack_require__(367);
	var onMissing = __webpack_require__(359);
	var isExpired = __webpack_require__(354);
	var expireNode = __webpack_require__(277);
	var NullInPathError = __webpack_require__(297);
	var assignCrossedRefs = __webpack_require__(298);
	
	/* eslint-disable no-constant-condition */
	function getRefTarget(path, depth, root, node,
	                      outerPath, outerPathDepth,
	                      optimizedPath, optimizedPathDepth,
	                      model, outerResults, innerRefs, seed) {
	
	    var type;
	    var height = path.length;
	
	    var key, keys, next, json,
	        hasMissingValue, nextDepth, nextOptimizedDepth,
	        keyIndex, keyCount, isRange, rangeIndex, rangeCount;
	
	    do {
	        var isLeaf = depth === height;
	
	        // ============ Check for base cases ================
	
	        // if nothing found in cache, add paths to set of abs and rel missing paths
	        if (node === undefined) {
	            return onMissing(model, outerPath, outerPathDepth, outerResults,
	                             undefined, optimizedPath, optimizedPathDepth);
	        }
	        // if atom or error JSON Graph primitive found, short curcuit
	        else if (((type = node.$type) && type !== $ref && type !== $nodeset) || isLeaf) {
	            return node;
	        }
	        // if ref JSON Graph primitive found, grab target of the reference
	        // and continue evaluating rest of ref path against it.
	        else if (type === $ref) {
	            var refPath, refTarget;
	            if (isExpired(node)) {
	                refTarget = undefined;
	                expireNode(node, model._root.expired, model._root);
	            } else {
	                refPath = node.value;
	                assignCrossedRefs(node, innerRefs, null, model._root, promote);
	                onValue(path, depth, node, type, seed,
	                        model, outerResults, optimizedPath, optimizedPathDepth);
	                refTarget = getRefTarget(refPath, 0, root, root, outerPath,
	                                         outerPathDepth, [], 0, model, outerResults,
	                                         node[__innerRefs] || (node[__innerRefs] = {}));
	            }
	            // if refTarget comes back undefined short-circuit
	            return refTarget === undefined ?
	                undefined : getRefTarget(path, depth, root, refTarget,
	                                         outerPath, outerPathDepth,
	                                         refPath.slice(0), refPath.length,
	                                         model, outerResults, innerRefs, seed);
	        }
	        // node will only be an Array if getRefTarget encountered a pathSet in
	        // a ref or a refset and consequently returned a nodeset. For example
	        // getRefTarget($ref(["lists",[52,99]])) produces
	        // [ cache["lists"][52], cache["lists"][99] ]. When getRefTarget
	        // is called on this output, it has to replace each ref target in the
	        // array with the result of evaluating the rest of path on the target.
	        else if (type === $nodeset) {
	            json = node;
	            keys = node.$keys;
	            nextDepth = depth;
	            hasMissingValue = false;
	            nextOptimizedDepth = optimizedPathDepth + 1;
	
	            if (isArray(keys)) {
	                keyIndex = 0;
	                keyCount = keys.length;
	                // return undefined if there is an empty keyset in the path.
	                // An example of an empty keyset is: ['lolomo', [], 'summary'].
	                // This should short circuit without building missing paths.
	                if (keyCount === 0) {
	                    return undefined;
	                }
	                do {
	                    key = keys[keyIndex];
	                    // If the key is null, throw an error.
	                    // null isn't allowed in keysets.
	                    if (key == null) {
	                        throw new NullInPathError();
	                    }
	                    // If key is a primitive, evaluate against node and bump the depth
	                    else if (typeof key !== "object") {
	                        next = node[key];
	                        optimizedPath[optimizedPathDepth] = key;
	                        if (next !== undefined) {
	                            next = getRefTarget(path, nextDepth, root, next,
	                                                outerPath, outerPathDepth, optimizedPath,
	                                                nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                            if (next !== undefined) {
	                                json[key] = next;
	                            }
	                        }
	                    }
	                    // if range found in keyset, recursively call getRefTarget
	                    // over each index in range
	                    else {
	                        rangeIndex = (key.from || 0) - 1;
	                        if (typeof (rangeCount = key.to) !== "number") {
	                            rangeCount = rangeIndex + (key.length || 0);
	                        }
	                        while (++rangeIndex <= rangeCount) {
	                            next = node[rangeIndex];
	                            optimizedPath[optimizedPathDepth] = rangeIndex;
	                            if (next !== undefined) {
	                                next = getRefTarget(path, nextDepth, root, next,
	                                                    outerPath, outerPathDepth, optimizedPath,
	                                                    nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                                if (next !== undefined) {
	                                    json[rangeIndex] = next;
	                                }
	                            }
	                        }
	                    }
	                } while (++keyIndex < keyCount);
	            }
	            // If keys is not a keyset it must be a range
	            else {
	                key = keys;
	                rangeIndex = (key.from || 0) - 1;
	                if (typeof (rangeCount = key.to) !== "number") {
	                    rangeCount = rangeIndex + (key.length || 0);
	                }
	                while (++rangeIndex <= rangeCount) {
	                    next = node[rangeIndex];
	                    optimizedPath[optimizedPathDepth] = rangeIndex;
	                    if (next !== undefined) {
	                        next = getRefTarget(path, nextDepth, root, next,
	                                            outerPath, outerPathDepth, optimizedPath,
	                                            nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                        if (next !== undefined) {
	                            json[rangeIndex] = next;
	                        }
	                    }
	                }
	            }
	            return json;
	        }
	
	        // ===== Is Path Key null, a Key Set, a Range, or a primitive key? =====
	
	        keys = path[depth];
	        nextDepth = depth + 1;
	        hasMissingValue = false;
	        nextOptimizedDepth = optimizedPathDepth + 1;
	
	        // If the keyset is null, throw an error.
	        // nulls aren't allowed in references.
	        if (keys == null) {
	            // if (nextDepth === height) {
	            //     depth = nextDepth;
	            //     continue;
	            // }
	            throw new NullInPathError();
	        }
	        // If key is a primitive, evaluate against node and bump the depth
	        else if (typeof keys !== "object") {
	            // simulate tail recursion
	            key = keys;
	            node = node[key];
	            depth = nextDepth;
	            optimizedPath[optimizedPathDepth] = key;
	            optimizedPathDepth = nextOptimizedDepth;
	            continue;
	        }
	
	        // node will only be an Array if getRefTarget encountered a pathSet in
	        // a ref or a refset. For example getRefTarget($ref(["lists",[52,99]]))
	        // produces [ cache["lists"][52], cache["lists"][99] ]. When
	        // getPathAsJSON is called on this output, it has to replace each ref
	        // target in the array with the result of evaluating the rest of path on
	        // the target.
	
	        json = { $type: $nodeset, $keys: keys };
	
	        if (depth > 0) {
	            json.$path = node.ツabsolutePath;
	            json.$version = node.ツversion;
	        }
	
	        if (isArray(keys)) {
	            keyIndex = 0;
	            keyCount = keys.length;
	            // return undefined if there is an empty keyset in the path.
	            // An example of an empty keyset is: ['lolomo', [], 'summary'].
	            // This should short circuit without building missing paths.
	            if (keyCount === 0) {
	                return undefined;
	            }
	            do {
	                key = keys[keyIndex];
	                // If the key is null, throw an error.
	                // null isn't allowed in keysets.
	                if (key == null) {
	                    throw new NullInPathError();
	                }
	                // If key is a primitive, evaluate against node and bump the depth
	                else if (typeof key !== "object") {
	                    next = node[key];
	                    optimizedPath[optimizedPathDepth] = key;
	                    next = getRefTarget(path, nextDepth, root, next,
	                                        outerPath, outerPathDepth, optimizedPath,
	                                        nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                    if (next !== undefined) {
	                        json[key] = next;
	                    } else {
	                        hasMissingValue = true;
	                    }
	                }
	                // if range found in keyset, recursively call getRefTarget
	                // over each index in range
	                else {
	                    rangeIndex = (key.from || 0) - 1;
	                    if (typeof (rangeCount = key.to) !== "number") {
	                        rangeCount = rangeIndex + (key.length || 0);
	                    }
	                    while (++rangeIndex <= rangeCount) {
	                        next = node[rangeIndex];
	                        optimizedPath[optimizedPathDepth] = rangeIndex;
	                        next = getRefTarget(path, nextDepth, root, next,
	                                            outerPath, outerPathDepth, optimizedPath,
	                                            nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                        if (next !== undefined) {
	                            json[rangeIndex] = next;
	                        } else {
	                            hasMissingValue = true;
	                        }
	                    }
	                }
	            } while (++keyIndex < keyCount);
	        }
	        // If keys is not a keyset it must be a range
	        else {
	            key = keys;
	            rangeIndex = (key.from || 0) - 1;
	            if (typeof (rangeCount = key.to) !== "number") {
	                rangeCount = rangeIndex + (key.length || 0);
	            }
	            while (++rangeIndex <= rangeCount) {
	                next = node[rangeIndex];
	                optimizedPath[optimizedPathDepth] = rangeIndex;
	                next = getRefTarget(path, nextDepth, root, next,
	                                    outerPath, outerPathDepth, optimizedPath,
	                                    nextOptimizedDepth, model, outerResults, innerRefs, seed);
	                if (next !== undefined) {
	                    json[rangeIndex] = next;
	                } else {
	                    hasMissingValue = true;
	                }
	            }
	        }
	
	        if (hasMissingValue) {
	            json.$hasMissingValue = true;
	        }
	
	        return json;
	    } while (true);
	}
	/* eslint-enable */


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var checkCacheAndReport = __webpack_require__(345);
	var MaxRetryExceededError = __webpack_require__(371);
	var fastCat = __webpack_require__(372).fastCat;
	var collectLru = __webpack_require__(373);
	var getSize = __webpack_require__(301);
	var AssignableDisposable = __webpack_require__(343);
	var InvalidSourceError = __webpack_require__(328);
	var isFunction = __webpack_require__(262);
	
	/**
	 * The get request cycle for checking the cache and reporting
	 * values.  If there are missing paths then the async request cycle to
	 * the data source is performed until all paths are resolved or max
	 * requests are made.
	 * @param {GetResponse} getResponse -
	 * @param {Model} model - The model that the request was made with.
	 * @param {Object} results -
	 * @param {Function} onNext -
	 * @param {Function} onError -
	 * @param {Function} onCompleted -
	 * @param {Object} seedArg - The state of the output
	 * @private
	 */
	module.exports = function getRequestCycle(getResponse, model, results, observer,
	                                          seed, errors, count, initialCacheVersion) {
	    // we have exceeded the maximum retry limit.
	    if (count === 10) {
	        throw new MaxRetryExceededError();
	    }
	
	    var requestQueue = model._request;
	    var requestedMissingPaths = results.requestedMissingPaths;
	    var optimizedMissingPaths = results.optimizedMissingPaths;
	    var disposable = new AssignableDisposable();
	
	    // We need to prepend the bound path to all requested missing paths and
	    // pass those into the requestQueue.
	    var boundRequestedMissingPaths = [];
	    var boundPath = model._path;
	    if (boundPath.length) {
	        for (var i = 0, len = requestedMissingPaths.length; i < len; ++i) {
	            boundRequestedMissingPaths[i] =
	                fastCat(boundPath, requestedMissingPaths[i]);
	        }
	    }
	
	    // No bound path, no array copy and concat.
	    else {
	        boundRequestedMissingPaths = requestedMissingPaths;
	    }
	
	    var currentRequestDisposable = requestQueue.
	        get(boundRequestedMissingPaths, optimizedMissingPaths, function(err) {
	
	            if (err instanceof InvalidSourceError) {
	                observer.onError(err);
	                return;
	            }
	
	            // Once the request queue finishes, check the cache and bail if
	            // we can.
	            var nextResults = checkCacheAndReport(model, requestedMissingPaths,
	                                                  observer,
	                                                  getResponse.isProgressive,
	                                                  getResponse.isJSONGraph,
	                                                  seed, errors);
	
	            // If there are missing paths coming back form checkCacheAndReport
	            // the its reported from the core cache check method.
	            if (nextResults) {
	
	                // update the which disposable to use.
	                disposable.currentDisposable =
	                    getRequestCycle(getResponse, model, nextResults, observer,
	                                    seed, errors, count + 1, initialCacheVersion);
	            }
	
	            // We have finished.  Since we went to the dataSource, we must
	            // collect on the cache.
	            else {
	
	                var modelRoot = model._root;
	                var modelCache = modelRoot.cache;
	                var currentVersion = modelCache.ツversion;
	
	                collectLru(modelRoot, modelRoot.expired, getSize(modelCache),
	                        model._maxSize, model._collectRatio, currentVersion);
	
	                var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;
	
	                if (initialCacheVersion !== currentVersion && (
	                    modelRoot.syncRefCount <= 0) &&
	                    isFunction(rootOnChangesCompletedHandler)) {
	                    rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);
	                }
	            }
	
	        });
	    disposable.currentDisposable = currentRequestDisposable;
	    return disposable;
	};


/***/ },
/* 371 */
/***/ function(module, exports) {

	var NAME = "MaxRetryExceededError";
	var MESSAGE = "The allowed number of retries have been exceeded.";
	
	/**
	 * A request can only be retried up to a specified limit.  Once that
	 * limit is exceeded, then an error will be thrown.
	 *
	 * @private
	 */
	function MaxRetryExceededError() {
	    var err = Error.call(this, MESSAGE);
	    err.name = NAME;
	    this.stack = err.stack;
	    this.message = err.message;
	    return this;
	}
	
	// instanceof will be an error, but stack will be correct because its defined
	// in the constructor.
	MaxRetryExceededError.prototype = Object.create(Error.prototype);
	MaxRetryExceededError.prototype.name = NAME;
	MaxRetryExceededError.is = function(e) {
	    return e && e.name === NAME;
	};
	
	module.exports = MaxRetryExceededError;


/***/ },
/* 372 */
/***/ function(module, exports) {

	function fastCopy(arr, iArg) {
	    var a = [], len, j, i;
	    for (j = 0, i = iArg || 0, len = arr.length; i < len; j++, i++) {
	        a[j] = arr[i];
	    }
	    return a;
	}
	
	
	function fastCat(arr1, arr2) {
	    var a = [], i, len, j;
	    for (i = 0, len = arr1.length; i < len; i++) {
	        a[i] = arr1[i];
	    }
	    for (j = 0, len = arr2.length; j < len; j++) {
	        a[i++] = arr2[j];
	    }
	    return a;
	}
	
	
	
	module.exports = {
	    fastCat: fastCat,
	    fastCopy: fastCopy
	};


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var removeNode = __webpack_require__(312);
	var updateNodeAncestors = __webpack_require__(315);
	
	module.exports = function collect(lru, expired, totalArg, max, ratioArg, version) {
	
	    var total = totalArg;
	    var ratio = ratioArg;
	
	    if (typeof ratio !== "number") {
	        ratio = 0.75;
	    }
	
	    var shouldUpdate = typeof version === "number";
	    var targetSize = max * ratio;
	    var parent, node, size;
	
	    node = expired.pop();
	
	    while (node) {
	        size = node.$size || 0;
	        total -= size;
	        if (shouldUpdate === true) {
	            updateNodeAncestors(node, size, lru, version);
	        } else if (parent = node.ツparent) {
	            removeNode(node, parent, node.ツkey, lru);
	        }
	        node = expired.pop();
	    }
	
	    if (total >= max) {
	        var prev = lru.ツtail;
	        node = prev;
	        while ((total >= targetSize) && node) {
	            prev = prev.ツprev;
	            size = node.$size || 0;
	            total -= size;
	            if (shouldUpdate === true) {
	                updateNodeAncestors(node, size, lru, version);
	            }
	            node = prev;
	        }
	
	        lru.ツtail = lru.ツprev = node;
	        if (node == null) {
	            lru.ツhead = lru.ツnext = undefined;
	        } else {
	            node.ツnext = undefined;
	        }
	    }
	};


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281) + "version";


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var arrayFlatMap = __webpack_require__(376);
	
	/**
	 * Takes the groups that are created in the SetResponse constructor and sets
	 * them into the cache.
	 */
	module.exports = function setGroupsIntoCache(model, groups) {
	    var modelRoot = model._root;
	    var errorSelector = modelRoot.errorSelector;
	    var groupIndex = -1;
	    var groupCount = groups.length;
	    var requestedPaths = [];
	    var optimizedPaths = [];
	    var returnValue = {
	        requestedPaths: requestedPaths,
	        optimizedPaths: optimizedPaths
	    };
	
	    // Takes each of the groups and normalizes their input into
	    // requested paths and optimized paths.
	    while (++groupIndex < groupCount) {
	
	        var group = groups[groupIndex];
	        var inputType = group.inputType;
	        var methodArgs = group.arguments;
	
	        if (methodArgs.length > 0) {
	            var operationName = "_set" + inputType;
	            var operationFunc = model[operationName];
	            var successfulPaths = operationFunc(model, methodArgs, null, errorSelector);
	
	            optimizedPaths.push.apply(optimizedPaths, successfulPaths[1]);
	
	            if (inputType === "PathValues") {
	                requestedPaths.push.apply(requestedPaths, methodArgs.map(pluckPath));
	            } else if (inputType === "JSONGs") {
	                requestedPaths.push.apply(requestedPaths, arrayFlatMap(methodArgs, pluckEnvelopePaths));
	            } else {
	                requestedPaths.push.apply(requestedPaths, successfulPaths[0]);
	            }
	        }
	    }
	
	    return returnValue;
	};
	
	function pluckPath(pathValue) {
	    return pathValue.path;
	}
	
	function pluckEnvelopePaths(jsonGraphEnvelope) {
	    return jsonGraphEnvelope.paths;
	}


/***/ },
/* 376 */
/***/ function(module, exports) {

	module.exports = function arrayFlatMap(array, selector) {
	    var index = -1;
	    var i = -1;
	    var n = array.length;
	    var array2 = [];
	    while (++i < n) {
	        var array3 = selector(array[i], i, array);
	        var j = -1;
	        var k = array3.length;
	        while (++j < k) {
	            array2[++index] = array3[j];
	        }
	    }
	    return array2;
	};


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var ModelResponse = __webpack_require__(333);
	var isPathValue = __webpack_require__(339);
	var isJSONEnvelope = __webpack_require__(341);
	var empty = {dispose: function() {}};
	var __version = __webpack_require__(374);
	var isFunction = __webpack_require__(262);
	
	function InvalidateResponse(model, args, initialCacheVersion) {
	    // TODO: This should be removed.  There should only be 1 type of arguments
	    // coming in, but we have strayed from documentation.
	    this._model = model;
	
	    var groups = [];
	    var group, groupType;
	    var argIndex = -1;
	    var argCount = args.length;
	
	    var currentVersion = model._root.cache[__version];
	
	    if (typeof initialCacheVersion === "number") {
	        this.initialCacheVersion = initialCacheVersion;
	    } else if (typeof currentVersion === "number") {
	        this.initialCacheVersion = currentVersion;
	    } else {
	        this.initialCacheVersion =
	            model._root.cache[__version] = model._root.version;
	    }
	
	    // Validation of arguments have been moved out of this function.
	    while (++argIndex < argCount) {
	        var arg = args[argIndex];
	        var argType;
	        if (isArray(arg)) {
	            argType = "PathValues";
	        } else if (isPathValue(arg)) {
	            argType = "PathValues";
	        } else if (isJSONEnvelope(arg)) {
	            argType = "PathMaps";
	        } else {
	            throw new Error("Invalid Input");
	        }
	
	        if (groupType !== argType) {
	            groupType = argType;
	            group = {
	                inputType: argType,
	                arguments: []
	            };
	            groups.push(group);
	        }
	
	        group.arguments.push(arg);
	    }
	
	    this._groups = groups;
	}
	
	InvalidateResponse.prototype = Object.create(ModelResponse.prototype);
	InvalidateResponse.prototype.progressively = function progressively() {
	    return this;
	};
	InvalidateResponse.prototype._toJSONG = function _toJSONG() {
	    return this;
	};
	
	InvalidateResponse.prototype._subscribe = function _subscribe(observer) {
	
	    var model = this._model;
	    this._groups.forEach(function(group) {
	        var inputType = group.inputType;
	        var methodArgs = group.arguments;
	        var operationName = "_invalidate" + inputType;
	        var operationFunc = model[operationName];
	        operationFunc(model, methodArgs);
	    });
	    observer.onCompleted();
	
	    var modelRoot = model._root;
	    var modelCache = modelRoot.cache;
	    var currentVersion = modelCache[__version];
	    var initialCacheVersion = this.initialCacheVersion;
	    var rootOnChangesCompletedHandler = modelRoot.onChangesCompleted;
	
	    if (initialCacheVersion !== currentVersion && (
	        modelRoot.syncRefCount <= 0) &&
	        isFunction(rootOnChangesCompletedHandler)) {
	        rootOnChangesCompletedHandler.call(modelRoot.topLevelModel);
	    }
	
	    return empty;
	};
	
	module.exports = InvalidateResponse;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	var asap = __webpack_require__(259);
	var empty = {dispose: function() {}};
	
	function ASAPScheduler() {}
	
	ASAPScheduler.prototype.schedule = function schedule(action) {
	    asap(action);
	    return empty;
	};
	
	ASAPScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
	    var self = this;
	    asap(function() {
	        action(self, state);
	    });
	    return empty;
	};
	
	module.exports = ASAPScheduler;


/***/ },
/* 379 */
/***/ function(module, exports) {

	function TimeoutScheduler(delay) {
	    this.delay = delay;
	}
	
	var TimerDisposable = function TimerDisposable(id) {
	    this.id = id;
	    this.disposed = false;
	};
	
	TimeoutScheduler.prototype.schedule = function schedule(action) {
	    var id = setTimeout(action, this.delay);
	    return new TimerDisposable(id);
	};
	
	TimeoutScheduler.prototype.scheduleWithState = function scheduleWithState(state, action) {
	    var self = this;
	    var id = setTimeout(function() {
	        action(self, state);
	    }, this.delay);
	    return new TimerDisposable(id);
	};
	
	TimerDisposable.prototype.dispose = function() {
	    if (this.disposed) {
	        return;
	    }
	
	    clearTimeout(this.id);
	    this.disposed = true;
	};
	
	module.exports = TimeoutScheduler;


/***/ },
/* 380 */
/***/ function(module, exports) {

	module.exports = function arrayClone(array) {
	    if (!array) {
	        return array;
	    }
	    var i = -1;
	    var n = array.length;
	    var array2 = [];
	    while (++i < n) {
	        array2[i] = array[i];
	    }
	    return array2;
	};


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathMaps;
	
	var setPathMap = __webpack_require__(382);
	var isFunction = __webpack_require__(262);
	var getCachePosition = __webpack_require__(326);
	var InvalidModelError = __webpack_require__(327);
	
	/**
	 * Sets a list of {@link PathMapEnvelope}s into a {@link JSONGraph}.
	 * @function
	 * @param {Object} model - the Model for which to insert the PathMaps.
	 * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of {@link PathMapEnvelope}s to set.
	 * @return {Array.<Array.<Path>>} - an Array of Arrays where each inner Array is a list of requested and optimized paths (respectively) for the successfully set values.
	 */
	
	function setPathMaps(model, pathMapEnvelopes, promote, errorSelector, comparator) {
	
	    var ref = false;
	    var _root = model._root;
	    var bound = model._path;
	    var cache = _root.cache;
	    var node = cache;
	
	    var optimizedPath, requestedPath;
	    var optimizedPathDepth = bound.length;
	
	    // If the model is bound, then get that cache position.
	    if (optimizedPathDepth) {
	
	        node = getCachePosition(model, bound);
	
	        // If there was a short, then we 'throw an error' to the outside
	        // calling function which will onError the observer.
	        if (node.$type) {
	            return {
	                criticalError: new InvalidModelError(bound, bound)
	            };
	        }
	        requestedPath = [];
	        optimizedPath = bound.slice(0);
	        ref = model._referenceContainer;
	    } else {
	        requestedPath = [];
	        optimizedPath = [];
	        optimizedPathDepth = 0;
	    }
	
	    var expired = _root.expired;
	    var version = _root.version++;
	    var initialVersion = cache.ツversion;
	
	    var requestedPaths = [];
	    var optimizedPaths = [];
	    var pathMapIndex = -1;
	    var pathMapCount = pathMapEnvelopes.length;
	
	    while (++pathMapIndex < pathMapCount) {
	
	        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];
	
	        setPathMap(pathMapEnvelope.json, 0, cache, node, node,
	                   requestedPath, 0,
	                   optimizedPath, optimizedPathDepth,
	                   requestedPaths, optimizedPaths,
	                   comparator, errorSelector,
	                   version, expired, _root, promote);
	    }
	
	    var newVersion = cache.ツversion;
	    var rootChangeHandler = _root.onChange;
	
	    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
	        rootChangeHandler(_root.topLevelModel);
	    }
	
	    return [requestedPaths, optimizedPaths];
	}


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = setPathMap;
	
	var isArray = Array.isArray;
	var hasOwn = __webpack_require__(248);
	var isObject = __webpack_require__(249);
	var setPathNode = __webpack_require__(321);
	var __prefix = __webpack_require__(281);
	
	/* eslint-disable no-constant-condition */
	function setPathMap(pathMap, depth, root, parent, node,
	                    requestedPath, requestedPathDepth,
	                    optimizedPath, optimizedPathDepth,
	                    requestedPaths, optimizedPaths,
	                    comparator, errorSelector,
	                    version, expired, lru, promote) {
	
	    var keys = getKeys(pathMap);
	
	    if (!keys || !keys.length) {
	        return;
	    }
	
	    var keyIndex = 0;
	    var keyCount = keys.length;
	    var nextDepth = depth + 1;
	    var nextRequestedPathDepth = requestedPathDepth + 1;
	
	
	    do {
	        var key = keys[keyIndex];
	        var child = pathMap[key];
	        var branch = isObject(child) && !child.$type;
	
	        var results = setPathNode(root, parent, node, key, child, branch, false,
	                                  null, requestedPath, requestedPathDepth,
	                                  optimizedPath, optimizedPathDepth,
	                                  comparator, errorSelector,
	                                  version, expired, lru, promote);
	
	        var nextIndex = 0;
	        var nextLength = results.length;
	
	        do {
	            var nextNode = results[nextIndex];
	            var nextParent = results[nextIndex + 1];
	            var nextOptimizedPath = results[nextIndex + 2];
	            var nextOptimizedPathDepth = results[nextIndex + 3];
	            nextIndex += 4;
	            if (nextNode) {
	                if (branch) {
	                    setPathMap(child, nextDepth, root, nextParent, nextNode,
	                               requestedPath, nextRequestedPathDepth,
	                               nextOptimizedPath, nextOptimizedPathDepth,
	                               requestedPaths, optimizedPaths,
	                               comparator, errorSelector,
	                               version, expired, lru, promote);
	                } else {
	                    requestedPaths.push(requestedPath.slice(0, nextRequestedPathDepth));
	                    optimizedPaths.push(nextOptimizedPath.slice(0, nextOptimizedPathDepth));
	                }
	            }
	        } while (nextIndex < nextLength);
	
	    } while (++keyIndex < keyCount);
	}
	/* eslint-enable */
	
	function getKeys(pathMap) {
	
	    if (isObject(pathMap) && !pathMap.$type) {
	        var keys = [];
	        var itr = 0;
	        if (isArray(pathMap)) {
	            keys[itr++] = "length";
	        }
	        for (var key in pathMap) {
	            if (key[0] === __prefix || key[0] === "$" || !hasOwn(pathMap, key)) {
	                continue;
	            }
	            keys[itr++] = key;
	        }
	        return keys;
	    }
	
	    return void 0;
	}


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(149);
	
	function sentinel(type, value, props) {
	    var copy = Object.create(null);
	    if (props != null) {
	        for(var key in props) {
	            copy[key] = props[key];
	        }
	        
	        copy["$type"] = type;
	        copy.value = value;
	        return copy;
	    }
	    else {
	        return { $type: type, value: value };
	    }    
	}
	
	module.exports = {
	    ref: function ref(path, props) {
	        return sentinel("ref", pathSyntax.fromPath(path), props);
	    },
	    atom: function atom(value, props) {
	        return sentinel("atom", value, props);        
	    },
	    undefined: function() {
	        return sentinel("atom");
	    },    
	    error: function error(errorValue, props) {
	        return sentinel("error", errorValue, props);        
	    },
	    pathValue: function pathValue(path, value) {
	        return { path: pathSyntax.fromPath(path), value: value };
	    },
	    pathInvalidation: function pathInvalidation(path) {
	        return { path: pathSyntax.fromPath(path), invalidated: true };
	    }    
	};


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var isPathValue = __webpack_require__(339);
	var isPathMap = __webpack_require__(385);
	var isJSONGraphEnvelope = __webpack_require__(340);
	var isJSONEnvelope = __webpack_require__(341);
	var pathSyntax = __webpack_require__(149);
	
	/**
	 *
	 * @param {Object} allowedInput - allowedInput is a map of input styles
	 * that are allowed
	 * @private
	 */
	module.exports = function validateInput(args, allowedInput, method) {
	    for (var i = 0, len = args.length; i < len; ++i) {
	        var arg = args[i];
	        var valid = false;
	
	        // Path
	        if (isArray(arg) && allowedInput.path) {
	            valid = true;
	        }
	
	        // Path Syntax
	        else if (typeof arg === "string" && allowedInput.pathSyntax) {
	            valid = true;
	        }
	
	        // Path Value
	        else if (isPathValue(arg) && allowedInput.pathValue) {
	            arg.path = pathSyntax.fromPath(arg.path);
	            valid = true;
	        }
	        else if (isPathMap(arg) && allowedInput.pathMap)  {
	            valid = true;
	        }
	        // jsonGraph {jsonGraph: { ... }, paths: [ ... ]}
	        else if (isJSONGraphEnvelope(arg) && allowedInput.jsonGraph) {
	            valid = true;
	        }
	
	        // json env {json: {...}}
	        else if (isJSONEnvelope(arg) && allowedInput.json) {
	            valid = true;
	        }
	
	        // selector functions
	        else if (typeof arg === "function" &&
	                 i + 1 === len &&
	                 allowedInput.selector) {
	            valid = true;
	        }
	
	        if (!valid) {
	            return new Error("Unrecognized argument " + (typeof arg) + " [" + String(arg) + "] " + "to Model#" + method + "");
	        }
	    }
	    return true;
	};


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var isArray = Array.isArray;
	var isObject = __webpack_require__(249);
	
	module.exports = function isPathMap(pathMap) {
	    return isObject(pathMap) && isArray(pathMap.$keys);
	};


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var isInternalKey = __webpack_require__(387);
	
	/**
	 * decends and copies the cache.
	 */
	module.exports = function getCache(cache) {
	    var out = {};
	    _copyCache(cache, out);
	
	    return out;
	};
	
	function cloneBoxedValue(boxedValue) {
	    var clonedValue = {};
	
	    var keys = Object.keys(boxedValue);
	    var key;
	    var i;
	    var l;
	
	    for (i = 0, l = keys.length; i < l; i++) {
	        key = keys[i];
	
	        if (!isInternalKey(key)) {
	            clonedValue[key] = boxedValue[key];
	        }
	    }
	
	    return clonedValue;
	}
	
	function _copyCache(node, out, fromKey) {
	    // copy and return
	
	    Object.
	        keys(node).
	        filter(function(k) {
	            // Its not an internal key and the node has a value.  In the cache
	            // there are 3 possibilities for values.
	            // 1: A branch node.
	            // 2: A $type-value node.
	            // 3: undefined
	            // We will strip out 3
	            return !isInternalKey(k) && node[k] !== undefined;
	        }).
	        forEach(function(key) {
	            var cacheNext = node[key];
	            var outNext = out[key];
	
	            if (!outNext) {
	                outNext = out[key] = {};
	            }
	
	            // Paste the node into the out cache.
	            if (cacheNext.$type) {
	                var isObject = cacheNext.value && typeof cacheNext.value === "object";
	                var isUserCreatedcacheNext = !cacheNext.ツmodelCreated;
	                var value;
	                if (isObject || isUserCreatedcacheNext) {
	                    value = cloneBoxedValue(cacheNext);
	                } else {
	                    value = cacheNext.value;
	                }
	
	                out[key] = value;
	                return;
	            }
	
	            _copyCache(cacheNext, outNext, key);
	        });
	}


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var unicodePrefix = __webpack_require__(281);
	
	/**
	 * Determined if the key passed in is an internal key.
	 *
	 * @param {String} x The key
	 * @private
	 * @returns {Boolean}
	 */
	module.exports = function isInternalKey(x) {
	    return x === "$size" ||
	        x === "$modelCreated" ||
	        x.charAt(0) === unicodePrefix;
	};


/***/ },
/* 388 */
/***/ function(module, exports) {

	module.exports = {
	    path: true,
	    pathSyntax: true,
	    pathMap: true
	};


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(149);
	var ModelResponse = __webpack_require__(333);
	var GET_VALID_INPUT = __webpack_require__(388);
	var validateInput = __webpack_require__(384);
	var GetResponse = __webpack_require__(344);
	
	/**
	 * Performs a get on the cache and if there are missing paths
	 * then the request will be forwarded to the get request cycle.
	 * @private
	 */
	module.exports = function get() {
	    // Validates the input.  If the input is not pathSets or strings then we
	    // will onError.
	    var out = validateInput(arguments, GET_VALID_INPUT, "get");
	    if (out !== true) {
	        return new ModelResponse(function(o) {
	            o.onError(out);
	        });
	    }
	
	    var paths = pathSyntax.fromPathsOrPathValues(arguments);
	    return new GetResponse(this, paths);
	};


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var GetResponse = __webpack_require__(344);
	
	/**
	 * Performs a get on the cache and if there are missing paths
	 * then the request will be forwarded to the get request cycle.
	 * @private
	 */
	module.exports = function getWithPaths(paths) {
	    return new GetResponse(this, paths);
	};


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	var setValidInput = __webpack_require__(392);
	var validateInput = __webpack_require__(384);
	var SetResponse = __webpack_require__(338);
	var ModelResponse = __webpack_require__(333);
	
	module.exports = function set() {
	    var out = validateInput(arguments, setValidInput, "set");
	    if (out !== true) {
	        return new ModelResponse(function(o) {
	            o.onError(out);
	        });
	    }
	
	    var argsIdx = -1;
	    var argsLen = arguments.length;
	    var args = [];
	    while (++argsIdx < argsLen) {
	        args[argsIdx] = arguments[argsIdx];
	    }
	    return new SetResponse(this, args);
	};


/***/ },
/* 392 */
/***/ function(module, exports) {

	module.exports = {
	    pathValue: true,
	    pathSyntax: true,
	    json: true,
	    jsonGraph: true
	};
	


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var InvalidDerefInputError = __webpack_require__(394);
	var getCachePosition = __webpack_require__(326);
	var CONTAINER_DOES_NOT_EXIST = "e";
	var $ref = __webpack_require__(272);
	
	module.exports = function deref(boundJSONArg) {
	
	    var absolutePath = boundJSONArg && boundJSONArg.$path;
	    var refPath = boundJSONArg && boundJSONArg.$refPath;
	    var toReference = boundJSONArg && boundJSONArg.$toReference;
	    var referenceContainer;
	
	    // We deref and then ensure that the reference container is attached to
	    // the model.
	    if (absolutePath) {
	        var validContainer = CONTAINER_DOES_NOT_EXIST;
	
	        if (toReference) {
	            validContainer = false;
	            referenceContainer = getCachePosition(this, toReference);
	
	            // If the reference container is still a sentinel value then compare
	            // the reference value with refPath.  If they are the same, then the
	            // model is still valid.
	            if (refPath && referenceContainer &&
	                referenceContainer.$type === $ref) {
	
	                var containerPath = referenceContainer.value;
	                var i = 0;
	                var len = refPath.length;
	
	                validContainer = true;
	                for (; validContainer && i < len; ++i) {
	                    if (containerPath[i] !== refPath[i]) {
	                        validContainer = false;
	                    }
	                }
	            }
	        }
	
	        // Signal to the deref'd model that it has been disconnected from the
	        // graph or there is no _fromWhenceYouCame
	        if (!validContainer) {
	            referenceContainer = false;
	        }
	
	        // The container did not exist, therefore there is no reference
	        // container and fromWhenceYouCame should always return true.
	        else if (validContainer === CONTAINER_DOES_NOT_EXIST) {
	            referenceContainer = true;
	        }
	
	        return this._clone({
	            _path: absolutePath,
	            _referenceContainer: referenceContainer
	        });
	    }
	
	    throw new InvalidDerefInputError();
	};


/***/ },
/* 394 */
/***/ function(module, exports) {

	var NAME = "InvalidDerefInputError";
	var MESSAGE = "Deref can only be used with a non-primitive object from get, set, or call.";
	/**
	 * An invalid deref input is when deref is used with input that is not generated
	 * from a get, set, or a call.
	 *
	 * @param {String} message
	 * @private
	 */
	function InvalidDerefInputError() {
	    var err = Error.call(this, MESSAGE);
	    err.name = NAME;
	    this.stack = err.stack;
	    this.message = err.message;
	    return this;
	}
	
	// instanceof will be an Error, but stack will be
	// correct because we capture it in the constructor.
	InvalidDerefInputError.prototype = Object.create(Error.prototype);
	InvalidDerefInputError.prototype.name = NAME;
	InvalidDerefInputError.message = MESSAGE;
	
	module.exports = InvalidDerefInputError;


/***/ },
/* 395 */
/***/ function(module, exports) {

	module.exports = function fromWhenceYeCame() {
	    var reference = this._referenceContainer;
	
	    // Always true when this mode is false.
	    if (!this._allowFromWhenceYouCame) {
	        return true;
	    }
	
	    // If fromWhenceYouCame is true and the first set of keys did not have
	    // a reference, this case can happen.  They are always valid.
	    if (reference === true) {
	        return true;
	    }
	
	    // was invalid before even derefing.
	    if (reference === false) {
	        return false;
	    }
	
	    // Its been disconnected (set over or collected) from the graph.
	    if (reference && reference.ツparent === undefined) {
	        return false;
	    }
	
	    // The reference has expired but has not been collected from the graph.
	    if (reference && reference.ツinvalidated) {
	        return false;
	    }
	
	    return true;
	};


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	var ModelResponse = __webpack_require__(333);
	var pathSyntax = __webpack_require__(149);
	
	module.exports = function getValue(path) {
	    var parsedPath = pathSyntax.fromPath(path);
	    var pathIdx = 0;
	    var pathLen = parsedPath.length;
	    while (++pathIdx < pathLen) {
	        if (typeof parsedPath[pathIdx] === "object") {
	            /* eslint-disable no-loop-func */
	            return new ModelResponse(function(o) {
	                o.onError(new Error("Paths must be simple paths"));
	            });
	            /* eslint-enable no-loop-func */
	        }
	    }
	
	    var self = this;
	    return new ModelResponse(function(obs) {
	        return self.get(parsedPath).subscribe(function(data) {
	            var curr = data.json;
	            var depth = -1;
	            var length = parsedPath.length;
	
	            while (curr && ++depth < length) {
	                curr = curr[parsedPath[depth]];
	            }
	            obs.onNext(curr);
	        }, function(err) {
	            obs.onError(err);
	        }, function() {
	            obs.onCompleted();
	        });
	    });
	};


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	var jsong = __webpack_require__(383);
	var ModelResponse = __webpack_require__(333);
	var isPathValue = __webpack_require__(339);
	
	module.exports = function setValue(pathArg, valueArg) {
	    var value = isPathValue(pathArg) ? pathArg : jsong.pathValue(pathArg, valueArg);
	    var pathIdx = 0;
	    var path = value.path;
	    var pathLen = path.length;
	    while (++pathIdx < pathLen) {
	        if (typeof path[pathIdx] === "object") {
	            /* eslint-disable no-loop-func */
	            return new ModelResponse(function(o) {
	                o.onError(new Error("Paths must be simple paths"));
	            });
	            /* eslint-enable no-loop-func */
	        }
	    }
	    var self = this;
	    return new ModelResponse(function(obs) {
	        return self.set(value).subscribe(function(data) {
	            var curr = data.json;
	            var depth = -1;
	            var length = path.length;
	
	            while (curr && ++depth < length) {
	                curr = curr[path[depth]];
	            }
	            obs.onNext(curr);
	        }, function(err) {
	            obs.onError(err);
	        }, function() {
	            obs.onCompleted();
	        });
	    });
	};


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(149);
	
	module.exports = function getValueSync(pathArg) {
	    var path = pathSyntax.fromPath(pathArg);
	    if (Array.isArray(path) === false) {
	        throw new Error("Model#getValueSync must be called with an Array path.");
	    }
	    if (this._path.length) {
	        path = this._path.concat(path);
	    }
	    return this._syncCheck("getValueSync") && this._getValueSync(this, path).value;
	};


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(149);
	var isPathValue = __webpack_require__(339);
	var setPathValues = __webpack_require__(319);
	
	module.exports = function setValueSync(pathArg, valueArg, errorSelectorArg, comparatorArg) {
	
	    var path = pathSyntax.fromPath(pathArg);
	    var value = valueArg;
	    var errorSelector = errorSelectorArg;
	    var comparator = comparatorArg;
	
	    if (isPathValue(path)) {
	        comparator = errorSelector;
	        errorSelector = value;
	        value = path;
	    } else {
	        value = {
	            path: path,
	            value: value
	        };
	    }
	
	    if (isPathValue(value) === false) {
	        throw new Error("Model#setValueSync must be called with an Array path.");
	    }
	
	    if (typeof errorSelector !== "function") {
	        errorSelector = this._root._errorSelector;
	    }
	
	    if (typeof comparator !== "function") {
	        comparator = this._root._comparator;
	    }
	
	    if (this._syncCheck("setValueSync")) {
	        setPathValues(this, [value]);
	        return this._getValueSync(this, value.path).value;
	    }
	};


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(149);
	var getBoundValue = __webpack_require__(355);
	var InvalidModelError = __webpack_require__(327);
	
	module.exports = function derefSync(boundPathArg) {
	
	    var boundPath = pathSyntax.fromPath(boundPathArg);
	
	    if (!Array.isArray(boundPath)) {
	        throw new Error("Model#derefSync must be called with an Array path.");
	    }
	
	    var boundValue = getBoundValue(this, this._path.concat(boundPath), false);
	
	    var path = boundValue.path;
	    var node = boundValue.value;
	    var found = boundValue.found;
	
	    // If the node is not found or the node is found but undefined is returned,
	    // this happens when a reference is expired.
	    if (!found || node === undefined) {
	        return undefined;
	    }
	
	    if (node.$type) {
	        throw new InvalidModelError();
	    }
	
	    return this._clone({ _path: path });
	};


/***/ },
/* 401 */
/***/ function(module, exports) {

	module.exports = function _getVersion(model, path) {
	    // ultra fast clone for boxed values.
	    var gen = model._getValueSync({
	        _boxed: true,
	        _root: model._root,
	        _treatErrorsAsValues: model._treatErrorsAsValues
	    }, path, true).value;
	    var version = gen && gen.ツversion;
	    return (version == null) ? -1 : version;
	};


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var __ref = __webpack_require__(350);
	
	var $ref = __webpack_require__(272);
	
	var getBoundValue = __webpack_require__(355);
	
	var promote = __webpack_require__(352);
	var getSize = __webpack_require__(301);
	var isExpired = __webpack_require__(303);
	var isFunction = __webpack_require__(262);
	var isPrimitive = __webpack_require__(325);
	var expireNode = __webpack_require__(277);
	var iterateKeySet = __webpack_require__(282).iterateKeySet;
	var updateNodeAncestors = __webpack_require__(315);
	var removeNodeAndDescendants = __webpack_require__(311);
	
	/**
	 * Invalidates a list of Paths in a JSON Graph.
	 * @function
	 * @param {Object} model - the Model for which to insert the PathValues.
	 * @param {Array.<PathValue>} paths - the PathValues to set.
	 */
	
	module.exports = function invalidatePathSets(model, paths) {
	
	    var modelRoot = model._root;
	    var lru = modelRoot;
	    var expired = modelRoot.expired;
	    var version = modelRoot.version++;
	    var bound = model._path;
	    var cache = modelRoot.cache;
	    var node = bound.length ? getBoundValue(model, bound).value : cache;
	    var parent = node.ツparent || cache;
	    var initialVersion = cache.ツversion;
	
	    var pathIndex = -1;
	    var pathCount = paths.length;
	
	    while (++pathIndex < pathCount) {
	
	        var path = paths[pathIndex];
	
	        invalidatePathSet(
	            path, 0, cache, parent, node,
	            version, expired, lru
	        );
	    }
	
	    var newVersion = cache.ツversion;
	    var rootChangeHandler = modelRoot.onChange;
	
	    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
	        rootChangeHandler(modelRoot.topLevelModel);
	    }
	};
	
	function invalidatePathSet(
	    path, depth, root, parent, node,
	    version, expired, lru) {
	
	    var note = {};
	    var branch = depth < path.length - 1;
	    var keySet = path[depth];
	    var key = iterateKeySet(keySet, note);
	
	    do {
	        var results = invalidateNode(
	            root, parent, node,
	            key, branch, false,
	            version, expired, lru
	        );
	        var nextNode = results[0];
	        var nextParent = results[1];
	        if (nextNode) {
	            if (branch) {
	                invalidatePathSet(
	                    path, depth + 1,
	                    root, nextParent, nextNode,
	                    version, expired, lru
	                );
	            } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {
	                updateNodeAncestors(nextParent, getSize(nextNode), lru, version);
	            }
	        }
	        key = iterateKeySet(keySet, note);
	    } while (!note.done);
	}
	
	function invalidateReference(root, node, version, expired, lru) {
	
	    if (isExpired(node)) {
	        expireNode(node, expired, lru);
	        return [undefined, root];
	    }
	
	    promote(lru, node);
	
	    var container = node;
	    var reference = node.value;
	    var parent = root;
	
	    node = node.ツcontext;
	
	    if (node != null) {
	        parent = node.ツparent || root;
	    } else {
	
	        var index = 0;
	        var count = reference.length - 1;
	
	        parent = node = root;
	
	        do {
	            var key = reference[index];
	            var branch = index < count;
	            var results = invalidateNode(
	                root, parent, node,
	                key, branch, true,
	                version, expired, lru
	            );
	            node = results[0];
	            if (isPrimitive(node)) {
	                return results;
	            }
	            parent = results[1];
	        } while (index++ < count);
	
	        if (container.ツcontext !== node) {
	            var backRefs = node.ツrefsLength || 0;
	            node.ツrefsLength = backRefs + 1;
	            node[__ref + backRefs] = container;
	            container.ツcontext = node;
	            container.ツrefIndex = backRefs;
	        }
	    }
	
	    return [node, parent];
	}
	
	function invalidateNode(
	    root, parent, node,
	    key, branch, reference,
	    version, expired, lru) {
	
	    var type = node.$type;
	
	    while (type === $ref) {
	
	        var results = invalidateReference(root, node, version, expired, lru);
	
	        node = results[0];
	
	        if (isPrimitive(node)) {
	            return results;
	        }
	
	        parent = results[1];
	        type = node.$type;
	    }
	
	    if (type !== void 0) {
	        return [node, parent];
	    }
	
	    if (key == null) {
	        if (branch) {
	            throw new Error("`null` is not allowed in branch key positions.");
	        } else if (node) {
	            key = node.ツkey;
	        }
	    } else {
	        parent = node;
	        node = parent[key];
	    }
	
	    return [node, parent];
	}


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var createHardlink = __webpack_require__(349);
	var __prefix = __webpack_require__(281);
	
	var $ref = __webpack_require__(272);
	
	var getBoundValue = __webpack_require__(355);
	
	var promote = __webpack_require__(352);
	var getSize = __webpack_require__(301);
	var hasOwn = __webpack_require__(248);
	var isObject = __webpack_require__(249);
	var isExpired = __webpack_require__(303);
	var isFunction = __webpack_require__(262);
	var isPrimitive = __webpack_require__(325);
	var expireNode = __webpack_require__(277);
	var updateNodeAncestors = __webpack_require__(315);
	var removeNodeAndDescendants = __webpack_require__(311);
	
	/**
	 * Sets a list of PathMaps into a JSON Graph.
	 * @function
	 * @param {Object} model - the Model for which to insert the PathMaps.
	 * @param {Array.<PathMapEnvelope>} pathMapEnvelopes - the a list of @PathMapEnvelopes to set.
	 */
	
	module.exports = function invalidatePathMaps(model, pathMapEnvelopes) {
	
	    var modelRoot = model._root;
	    var lru = modelRoot;
	    var expired = modelRoot.expired;
	    var version = modelRoot.version++;
	    var comparator = modelRoot._comparator;
	    var errorSelector = modelRoot._errorSelector;
	    var bound = model._path;
	    var cache = modelRoot.cache;
	    var node = bound.length ? getBoundValue(model, bound).value : cache;
	    var parent = node.ツparent || cache;
	    var initialVersion = cache.ツversion;
	
	    var pathMapIndex = -1;
	    var pathMapCount = pathMapEnvelopes.length;
	
	    while (++pathMapIndex < pathMapCount) {
	
	        var pathMapEnvelope = pathMapEnvelopes[pathMapIndex];
	
	        invalidatePathMap(
	            pathMapEnvelope.json, 0, cache, parent, node,
	            version, expired, lru, comparator, errorSelector
	        );
	    }
	
	    var newVersion = cache.ツversion;
	    var rootChangeHandler = modelRoot.onChange;
	
	    if (isFunction(rootChangeHandler) && initialVersion !== newVersion) {
	        rootChangeHandler(modelRoot.topLevelModel);
	    }
	};
	
	function invalidatePathMap(pathMap, depth, root, parent, node, version, expired, lru, comparator, errorSelector) {
	
	    if (isPrimitive(pathMap) || pathMap.$type) {
	        return;
	    }
	
	    for (var key in pathMap) {
	        if (key[0] !== __prefix && key[0] !== "$" && hasOwn(pathMap, key)) {
	            var child = pathMap[key];
	            var branch = isObject(child) && !child.$type;
	            var results = invalidateNode(
	                root, parent, node,
	                key, child, branch, false,
	                version, expired, lru, comparator, errorSelector
	            );
	            var nextNode = results[0];
	            var nextParent = results[1];
	            if (nextNode) {
	                if (branch) {
	                    invalidatePathMap(
	                        child, depth + 1,
	                        root, nextParent, nextNode,
	                        version, expired, lru, comparator, errorSelector
	                    );
	                } else if (removeNodeAndDescendants(nextNode, nextParent, key, lru)) {
	                    updateNodeAncestors(nextParent, getSize(nextNode), lru, version);
	                }
	            }
	        }
	    }
	}
	
	function invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector) {
	
	    if (isExpired(node)) {
	        expireNode(node, expired, lru);
	        return [undefined, root];
	    }
	
	    promote(lru, node);
	
	    var container = node;
	    var reference = node.value;
	    var parent = root;
	
	    node = node.ツcontext;
	
	    if (node != null) {
	        parent = node.ツparent || root;
	    } else {
	
	        var index = 0;
	        var count = reference.length - 1;
	
	        parent = node = root;
	
	        do {
	            var key = reference[index];
	            var branch = index < count;
	            var results = invalidateNode(
	                root, parent, node,
	                key, value, branch, true,
	                version, expired, lru, comparator, errorSelector
	            );
	            node = results[0];
	            if (isPrimitive(node)) {
	                return results;
	            }
	            parent = results[1];
	        } while (index++ < count);
	
	        if (container.ツcontext !== node) {
	            createHardlink(container, node);
	        }
	    }
	
	    return [node, parent];
	}
	
	function invalidateNode(
	    root, parent, node,
	    key, value, branch, reference,
	    version, expired, lru, comparator, errorSelector) {
	
	    var type = node.$type;
	
	    while (type === $ref) {
	
	        var results = invalidateReference(value, root, node, version, expired, lru, comparator, errorSelector);
	
	        node = results[0];
	
	        if (isPrimitive(node)) {
	            return results;
	        }
	
	        parent = results[1];
	        type = node && node.$type;
	    }
	
	    if (type !== void 0) {
	        return [node, parent];
	    }
	
	    if (key == null) {
	        if (branch) {
	            throw new Error("`null` is not allowed in branch key positions.");
	        } else if (node) {
	            key = node.ツkey;
	        }
	    } else {
	        parent = node;
	        node = parent[key];
	    }
	
	    return [node, parent];
	}


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Event = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Subject2 = __webpack_require__(78);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Event = exports.Event = function (_Subject) {
	    _inherits(Event, _Subject);
	
	    function Event() {
	        _classCallCheck(this, Event);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Event).apply(this, arguments));
	    }
	
	    _createClass(Event, [{
	        key: 'lift',
	        value: function lift(operator) {
	            var event = new Event(this.destination || this, this);
	            event.operator = operator;
	            return event;
	        }
	    }, {
	        key: 'stop',
	        value: function stop() {
	            return this.do(function (x) {
	                return x.stopPropagation();
	            });
	        }
	    }, {
	        key: 'clobber',
	        value: function clobber() {
	            return this.do(function (x) {
	                x.preventDefault();
	                x.stopPropagation();
	            });
	        }
	    }]);
	
	    return Event;
	}(_Subject2.Subject);
	//# sourceMappingURL=Event.js.map

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Component = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Event = __webpack_require__(404);
	
	var _Changes = __webpack_require__(406);
	
	var _isPromise = __webpack_require__(106);
	
	var _Observable2 = __webpack_require__(79);
	
	var _observable = __webpack_require__(81);
	
	var _ReplaySubject = __webpack_require__(416);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var isArray = Array.isArray;
	
	var Component = exports.Component = function (_Observable) {
	    _inherits(Component, _Observable);
	
	    function Component(attrs, createChild) {
	        _classCallCheck(this, Component);
	
	        if (typeof attrs === 'function') {
	            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this, attrs));
	        } else if (isObservable(attrs)) {
	            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));
	
	            _this.models = attrs;
	        } else {
	            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));
	
	            if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
	                if (createChild && !_this.createChild) {
	                    _this.createChild = createChild;
	                }
	                var models = attrs['models'];
	                delete attrs['models'];
	                for (var key in attrs) {
	                    if (attrs.hasOwnProperty(key)) {
	                        _this[key] = attrs[key];
	                    }
	                }
	                if (isObservable(models)) {
	                    _this.models = models;
	                }
	            }
	        }
	        return _possibleConstructorReturn(_this);
	    }
	
	    _createClass(Component, [{
	        key: 'createChildren',
	        value: function createChildren(updates) {
	            return updates;
	        }
	    }, {
	        key: 'loader',
	        value: function loader(props) {
	            return _Observable2.Observable.of({ json: {} });
	        }
	    }, {
	        key: 'events',
	        value: function events(props) {
	            return _Observable2.Observable.of(props);
	        }
	    }, {
	        key: 'render',
	        value: function render(props) {
	            return _Observable2.Observable.empty();
	        }
	    }, {
	        key: 'mapModelToKey',
	        value: function mapModelToKey(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return name + ' ' + model.inspect();
	        }
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(currKey, nextKey) {
	            return currKey !== nextKey;
	        }
	    }, {
	        key: 'mapDataToProps',
	        value: function mapDataToProps(_ref3, _ref4) {
	            var _ref5 = _slicedToArray(_ref3, 1);
	
	            var model = _ref5[0];
	            var json = _ref4.json;
	
	            return [model, json];
	        }
	    }, {
	        key: 'listen',
	        value: function listen(name) {
	            var subjects = this.subjects || (this.subjects = {});
	            var subject = subjects[name] || (subjects[name] = new _Event.Event());
	            subject.eventName = name;
	            return subject;
	        }
	    }, {
	        key: 'dispatch',
	        value: function dispatch(name) {
	            var handlers = this.handlers || (this.handlers = {});
	            var responder = handlers[name] || (handlers[name] = this.trigger.bind(this, name));
	            responder.eventName = name;
	            return responder;
	        }
	    }, {
	        key: 'trigger',
	        value: function trigger(name, value) {
	            var subjects = this.subjects;
	            if (subjects) {
	                var subject = subjects[name];
	                if (subject) {
	                    subject.next(value);
	                }
	            }
	        }
	    }, {
	        key: 'lift',
	        value: function lift(operator) {
	            var component = new Component();
	            component.source = this;
	            component.operator = operator;
	            return component;
	        }
	    }, {
	        key: 'models',
	        set: function set(m) {
	            var _this2 = this;
	
	            if (this.source) {
	                this.source.unsubscribe();
	            }
	
	            if (this.subscription) {
	                this.subscription.unsubscribe();
	            }
	
	            var updates = _Changes.Changes.from(m.distinctUntilChanged(function () {
	                return !_this2.shouldComponentUpdate.apply(_this2, arguments);
	            }, function () {
	                return _this2.key = _this2.mapModelToKey.apply(_this2, arguments);
	            }).switchMap(function () {
	                return _this2.loader.apply(_this2, arguments);
	            }, function () {
	                return _this2.mapDataToProps.apply(_this2, arguments);
	            })
	            // .do(() => console.log('updated', this.key))
	            .switchMap(function (props) {
	                return _this2.events(props).startWith(props);
	            }));
	
	            this.source = new _ReplaySubject.ReplaySubject(1);
	
	            this.subscription = this.createChildren(updates).switchMap(function () {
	                return toObservable(_this2.render.apply(_this2, arguments));
	            }, false)
	            // .do(() => console.log('rendered', this.key))
	            .subscribe(this.source);
	        }
	    }]);
	
	    return Component;
	}(_Observable2.Observable);
	
	function toObservable(ish, skipNull) {
	    if (ish == null) {
	        return skipNull ? _Observable2.Observable.empty() : _Observable2.Observable.of(ish);
	    } else if (isArray(ish) || (0, _isPromise.isPromise)(ish) || isObservable(ish) || typeof ish[_observable.$$observable] === 'function') {
	        return ish;
	    } else {
	        return _Observable2.Observable.of(ish);
	    }
	}
	
	function isObservable(ish) {
	    if (ish && (typeof ish === 'undefined' ? 'undefined' : _typeof(ish)) === 'object') {
	        return ish instanceof _Observable2.Observable;
	    }
	    return false;
	}
	//# sourceMappingURL=Component.js.map

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Changes = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _asap = __webpack_require__(407);
	
	var _tryCatch = __webpack_require__(88);
	
	var _Scheduler = __webpack_require__(415);
	
	var _Observable2 = __webpack_require__(79);
	
	var _Subscriber2 = __webpack_require__(83);
	
	var _errorObject = __webpack_require__(89);
	
	var _Subscription = __webpack_require__(85);
	
	var _falcorPathSyntax = __webpack_require__(149);
	
	var _falcorPathSyntax2 = _interopRequireDefault(_falcorPathSyntax);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var isArray = Array.isArray;
	
	var Changes = exports.Changes = function (_Observable) {
	    _inherits(Changes, _Observable);
	
	    function Changes(subscribe) {
	        _classCallCheck(this, Changes);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Changes).call(this, subscribe));
	
	        _this.nextVal = null;
	        _this.errorVal = null;
	        _this.hasValue = false;
	        _this.hasError = false;
	        _this.subscribers = [];
	        _this.subscription = null;
	        _this.hasCompleted = false;
	        return _this;
	    }
	
	    _createClass(Changes, [{
	        key: 'next',
	        value: function next(x) {
	            this.nextVal = x;
	            this.hasValue = true;
	            var subscribers = this.subscribers.slice(0);
	            var len = subscribers.length;
	            var index = -1;
	            while (++index < len) {
	                subscribers[index].next(x);
	            }
	        }
	    }, {
	        key: 'error',
	        value: function error(e) {
	            this.errorVal = e;
	            this.hasError = true;
	            var subscribers = this.subscribers.slice(0);
	            this.subscribers = [];
	            var len = subscribers.length;
	            var index = -1;
	            while (++index < len) {
	                subscribers[index].error(e);
	            }
	        }
	    }, {
	        key: 'complete',
	        value: function complete() {
	            this.hasCompleted = true;
	            var subscribers = this.subscribers.slice(0);
	            this.subscribers = [];
	            var len = subscribers.length;
	            var index = -1;
	            while (++index < len) {
	                subscribers[index].complete();
	            }
	        }
	    }, {
	        key: '_subscribe',
	        value: function _subscribe(subscriber) {
	            var _this2 = this;
	
	            var subscribers = this.subscribers;
	
	
	            subscribers.push(subscriber);
	
	            if (subscribers.length === 1) {
	                this.subscription = this.source.subscribe(this);
	            } else if (this.hasError) {
	                subscriber.error(this.errorVal);
	            } else if (this.hasCompleted) {
	                subscriber.complete();
	            } else if (this.hasValue) {
	                subscriber.next(this.nextVal);
	            }
	
	            return new _Subscription.Subscription(function () {
	                var index = subscribers.indexOf(subscriber);
	                if (~index) {
	                    subscribers.splice(index, 1);
	                }
	                if (subscribers.length === 0) {
	                    var subscription = _this2.subscription;
	                    _this2.subscription = null;
	                    subscription.unsubscribe();
	                }
	            });
	        }
	    }, {
	        key: 'deref',
	        value: function deref() {
	            for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
	                keys[_key] = arguments[_key];
	            }
	
	            if (keys.length === 1) {
	                if (isArray(keys[0])) {
	                    keys = keys[0];
	                } else if (typeof keys[0] === 'string') {
	                    keys = (0, _falcorPathSyntax2.default)(keys[0]);
	                }
	            }
	            return this.lift(new DerefOperator(keys));
	        }
	    }], [{
	        key: 'from',
	        value: function from(source) {
	            var observable = new Changes();
	            observable.source = source;
	            return observable;
	        }
	    }]);
	
	    return Changes;
	}(_Observable2.Observable);
	
	var DerefOperator = function () {
	    function DerefOperator(keys) {
	        _classCallCheck(this, DerefOperator);
	
	        this.keys = keys;
	    }
	
	    _createClass(DerefOperator, [{
	        key: 'call',
	        value: function call(subscriber, source) {
	            return source._subscribe(new DerefSubscriber(subscriber, this.keys));
	        }
	    }]);
	
	    return DerefOperator;
	}();
	
	var DerefSubscriber = function (_Subscriber) {
	    _inherits(DerefSubscriber, _Subscriber);
	
	    function DerefSubscriber(destination, keys) {
	        _classCallCheck(this, DerefSubscriber);
	
	        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(DerefSubscriber).call(this, destination));
	
	        _this3.keys = keys;
	        return _this3;
	    }
	
	    _createClass(DerefSubscriber, [{
	        key: '_next',
	        value: function _next(update) {
	
	            var keys = this.keys;
	            var count = keys.length;
	            var keysIdx = -1;
	            var _update = update;
	
	            var _update2 = _slicedToArray(_update, 2);
	
	            var model = _update2[0];
	            var state = _update2[1];
	
	
	            while (++keysIdx < count) {
	                var key = keys[keysIdx];
	                if (!state.hasOwnProperty(key)) {
	                    return;
	                }
	                model = (0, _tryCatch.tryCatch)(model.deref).call(model, state = state[key]);
	                if (model === _errorObject.errorObject) {
	                    return this.destination.error(_errorObject.errorObject.e);
	                }
	            }
	
	            update = update.slice(0);
	            update[0] = model;
	            update[1] = state;
	
	            _get(Object.getPrototypeOf(DerefSubscriber.prototype), '_next', this).call(this, update);
	        }
	    }]);
	
	    return DerefSubscriber;
	}(_Subscriber2.Subscriber);
	//# sourceMappingURL=Changes.js.map

/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsapScheduler_1 = __webpack_require__(408);
	exports.asap = new AsapScheduler_1.AsapScheduler();
	//# sourceMappingURL=asap.js.map

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsapAction_1 = __webpack_require__(409);
	var QueueScheduler_1 = __webpack_require__(413);
	var AsapScheduler = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsapScheduler.prototype.scheduleNow = function (work, state) {
	        return new AsapAction_1.AsapAction(this, work).schedule(state);
	    };
	    return AsapScheduler;
	}(QueueScheduler_1.QueueScheduler));
	exports.AsapScheduler = AsapScheduler;
	//# sourceMappingURL=AsapScheduler.js.map

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Immediate_1 = __webpack_require__(410);
	var FutureAction_1 = __webpack_require__(412);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsapAction = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction() {
	        _super.apply(this, arguments);
	    }
	    AsapAction.prototype._schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype._schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        if (!scheduler.scheduledId) {
	            scheduler.scheduledId = Immediate_1.Immediate.setImmediate(function () {
	                scheduler.scheduledId = null;
	                scheduler.flush();
	            });
	        }
	        return this;
	    };
	    AsapAction.prototype._unsubscribe = function () {
	        var scheduler = this.scheduler;
	        var scheduledId = scheduler.scheduledId, actions = scheduler.actions;
	        _super.prototype._unsubscribe.call(this);
	        if (actions.length === 0) {
	            scheduler.active = false;
	            if (scheduledId != null) {
	                scheduler.scheduledId = null;
	                Immediate_1.Immediate.clearImmediate(scheduledId);
	            }
	        }
	    };
	    return AsapAction;
	}(FutureAction_1.FutureAction));
	exports.AsapAction = AsapAction;
	//# sourceMappingURL=AsapAction.js.map

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**
	Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";
	var root_1 = __webpack_require__(80);
	var ImmediateDefinition = (function () {
	    function ImmediateDefinition(root) {
	        this.root = root;
	        if (root.setImmediate && typeof root.setImmediate === 'function') {
	            this.setImmediate = root.setImmediate.bind(root);
	            this.clearImmediate = root.clearImmediate.bind(root);
	        }
	        else {
	            this.nextHandle = 1;
	            this.tasksByHandle = {};
	            this.currentlyRunningATask = false;
	            // Don't get fooled by e.g. browserify environments.
	            if (this.canUseProcessNextTick()) {
	                // For Node.js before 0.9
	                this.setImmediate = this.createProcessNextTickSetImmediate();
	            }
	            else if (this.canUsePostMessage()) {
	                // For non-IE10 modern browsers
	                this.setImmediate = this.createPostMessageSetImmediate();
	            }
	            else if (this.canUseMessageChannel()) {
	                // For web workers, where supported
	                this.setImmediate = this.createMessageChannelSetImmediate();
	            }
	            else if (this.canUseReadyStateChange()) {
	                // For IE 6–8
	                this.setImmediate = this.createReadyStateChangeSetImmediate();
	            }
	            else {
	                // For older browsers
	                this.setImmediate = this.createSetTimeoutSetImmediate();
	            }
	            var ci = function clearImmediate(handle) {
	                delete clearImmediate.instance.tasksByHandle[handle];
	            };
	            ci.instance = this;
	            this.clearImmediate = ci;
	        }
	    }
	    ImmediateDefinition.prototype.identify = function (o) {
	        return this.root.Object.prototype.toString.call(o);
	    };
	    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
	        return this.identify(this.root.process) === '[object process]';
	    };
	    ImmediateDefinition.prototype.canUseMessageChannel = function () {
	        return Boolean(this.root.MessageChannel);
	    };
	    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
	        var document = this.root.document;
	        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
	    };
	    ImmediateDefinition.prototype.canUsePostMessage = function () {
	        var root = this.root;
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `root.postMessage` means something completely different and can't be used for this purpose.
	        if (root.postMessage && !root.importScripts) {
	            var postMessageIsAsynchronous_1 = true;
	            var oldOnMessage = root.onmessage;
	            root.onmessage = function () {
	                postMessageIsAsynchronous_1 = false;
	            };
	            root.postMessage('', '*');
	            root.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous_1;
	        }
	        return false;
	    };
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var fn = function result() {
	            var _a = result, handler = _a.handler, args = _a.args;
	            if (typeof handler === 'function') {
	                handler.apply(undefined, args);
	            }
	            else {
	                (new Function('' + handler))();
	            }
	        };
	        fn.handler = handler;
	        fn.args = args;
	        return fn;
	    };
	    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
	        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
	        return this.nextHandle++;
	    };
	    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	        var root = this.root;
	        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
	        var onGlobalMessage = function globalMessageHandler(event) {
	            var instance = globalMessageHandler.instance;
	            if (event.source === root &&
	                typeof event.data === 'string' &&
	                event.data.indexOf(messagePrefix) === 0) {
	                instance.runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	        onGlobalMessage.instance = this;
	        root.addEventListener('message', onGlobalMessage, false);
	        var fn = function setImmediate() {
	            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.postMessage(messagePrefix + handle, '*');
	            return handle;
	        };
	        fn.instance = this;
	        fn.messagePrefix = messagePrefix;
	        return fn;
	    };
	    ImmediateDefinition.prototype.runIfPresent = function (handle) {
	        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (this.currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // 'too much recursion' error.
	            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
	        }
	        else {
	            var task = this.tasksByHandle[handle];
	            if (task) {
	                this.currentlyRunningATask = true;
	                try {
	                    task();
	                }
	                finally {
	                    this.clearImmediate(handle);
	                    this.currentlyRunningATask = false;
	                }
	            }
	        }
	    };
	    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
	        var _this = this;
	        var channel = new this.root.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            _this.runIfPresent(handle);
	        };
	        var fn = function setImmediate() {
	            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	        fn.channel = channel;
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var root = instance.root;
	            var doc = root.document;
	            var html = doc.documentElement;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement('script');
	            script.onreadystatechange = function () {
	                instance.runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    return ImmediateDefinition;
	}());
	exports.ImmediateDefinition = ImmediateDefinition;
	exports.Immediate = new ImmediateDefinition(root_1.root);
	//# sourceMappingURL=Immediate.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(411).clearImmediate, __webpack_require__(411).setImmediate))

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(11).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(411).setImmediate, __webpack_require__(411).clearImmediate))

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(80);
	var Subscription_1 = __webpack_require__(85);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FutureAction = (function (_super) {
	    __extends(FutureAction, _super);
	    function FutureAction(scheduler, work) {
	        _super.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.pending = false;
	    }
	    FutureAction.prototype.execute = function () {
	        if (this.isUnsubscribed) {
	            this.error = new Error('executing a cancelled action');
	        }
	        else {
	            try {
	                this.work(this.state);
	            }
	            catch (e) {
	                this.unsubscribe();
	                this.error = e;
	            }
	        }
	    };
	    FutureAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        return this._schedule(state, delay);
	    };
	    FutureAction.prototype._schedule = function (state, delay) {
	        var _this = this;
	        if (delay === void 0) { delay = 0; }
	        // Always replace the current state with the new state.
	        this.state = state;
	        // Set the pending flag indicating that this action has been scheduled, or
	        // has recursively rescheduled itself.
	        this.pending = true;
	        var id = this.id;
	        // If this action has an intervalID and the specified delay matches the
	        // delay we used to create the intervalID, don't call `setInterval` again.
	        if (id != null && this.delay === delay) {
	            return this;
	        }
	        this.delay = delay;
	        // If this action has an intervalID, but was rescheduled with a different
	        // `delay` time, cancel the current intervalID and call `setInterval` with
	        // the new `delay` time.
	        if (id != null) {
	            this.id = null;
	            root_1.root.clearInterval(id);
	        }
	        //
	        // Important implementation note:
	        //
	        // By default, FutureAction only executes once. However, Actions have the
	        // ability to be rescheduled from within the scheduled callback (mimicking
	        // recursion for asynchronous methods). This allows us to implement single
	        // and repeated actions with the same code path without adding API surface
	        // area, and implement tail-call optimization over asynchronous boundaries.
	        //
	        // However, JS runtimes make a distinction between intervals scheduled by
	        // repeatedly calling `setTimeout` vs. a single `setInterval` call, with
	        // the latter providing a better guarantee of precision.
	        //
	        // In order to accommodate both single and repeatedly rescheduled actions,
	        // use `setInterval` here for both cases. By default, the interval will be
	        // canceled after its first execution, or if the action schedules itself to
	        // run again with a different `delay` time.
	        //
	        // If the action recursively schedules itself to run again with the same
	        // `delay` time, the interval is not canceled, but allowed to loop again.
	        // The check of whether the interval should be canceled or not is run every
	        // time the interval is executed. The first time an action fails to
	        // reschedule itself, the interval is canceled.
	        //
	        this.id = root_1.root.setInterval(function () {
	            _this.pending = false;
	            var _a = _this, id = _a.id, scheduler = _a.scheduler;
	            scheduler.actions.push(_this);
	            scheduler.flush();
	            //
	            // Terminate this interval if the action didn't reschedule itself.
	            // Don't call `this.unsubscribe()` here, because the action could be
	            // rescheduled later. For example:
	            //
	            // ```
	            // scheduler.schedule(function doWork(counter) {
	            //   /* ... I'm a busy worker bee ... */
	            //   var originalAction = this;
	            //   /* wait 100ms before rescheduling this action again */
	            //   setTimeout(function () {
	            //     originalAction.schedule(counter + 1);
	            //   }, 100);
	            // }, 1000);
	            // ```
	            if (_this.pending === false && id != null) {
	                _this.id = null;
	                root_1.root.clearInterval(id);
	            }
	        }, delay);
	        return this;
	    };
	    FutureAction.prototype._unsubscribe = function () {
	        this.pending = false;
	        var _a = this, id = _a.id, scheduler = _a.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        if (id != null) {
	            this.id = null;
	            root_1.root.clearInterval(id);
	        }
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        this.work = null;
	        this.state = null;
	        this.scheduler = null;
	    };
	    return FutureAction;
	}(Subscription_1.Subscription));
	exports.FutureAction = FutureAction;
	//# sourceMappingURL=FutureAction.js.map

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var QueueAction_1 = __webpack_require__(414);
	var FutureAction_1 = __webpack_require__(412);
	var QueueScheduler = (function () {
	    function QueueScheduler() {
	        this.active = false;
	        this.actions = []; // XXX: use `any` to remove type param `T` from `VirtualTimeScheduler`.
	        this.scheduledId = null;
	    }
	    QueueScheduler.prototype.now = function () {
	        return Date.now();
	    };
	    QueueScheduler.prototype.flush = function () {
	        if (this.active || this.scheduledId) {
	            return;
	        }
	        this.active = true;
	        var actions = this.actions;
	        // XXX: use `any` to remove type param `T` from `VirtualTimeScheduler`.
	        for (var action = null; action = actions.shift();) {
	            action.execute();
	            if (action.error) {
	                this.active = false;
	                throw action.error;
	            }
	        }
	        this.active = false;
	    };
	    QueueScheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return (delay <= 0) ?
	            this.scheduleNow(work, state) :
	            this.scheduleLater(work, delay, state);
	    };
	    QueueScheduler.prototype.scheduleNow = function (work, state) {
	        return new QueueAction_1.QueueAction(this, work).schedule(state);
	    };
	    QueueScheduler.prototype.scheduleLater = function (work, delay, state) {
	        return new FutureAction_1.FutureAction(this, work).schedule(state, delay);
	    };
	    return QueueScheduler;
	}());
	exports.QueueScheduler = QueueScheduler;
	//# sourceMappingURL=QueueScheduler.js.map

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FutureAction_1 = __webpack_require__(412);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var QueueAction = (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction() {
	        _super.apply(this, arguments);
	    }
	    QueueAction.prototype._schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype._schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        scheduler.flush();
	        return this;
	    };
	    return QueueAction;
	}(FutureAction_1.FutureAction));
	exports.QueueAction = QueueAction;
	//# sourceMappingURL=QueueAction.js.map

/***/ },
/* 415 */
/***/ function(module, exports) {

	"use strict";
	//# sourceMappingURL=Scheduler.js.map

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(78);
	var queue_1 = __webpack_require__(417);
	var observeOn_1 = __webpack_require__(111);
	/**
	 * @class ReplaySubject<T>
	 */
	var ReplaySubject = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	        _super.call(this);
	        this.events = [];
	        this.scheduler = scheduler;
	        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = windowTime < 1 ? 1 : windowTime;
	    }
	    ReplaySubject.prototype._next = function (value) {
	        var now = this._getNow();
	        this.events.push(new ReplayEvent(now, value));
	        this._trimBufferThenGetEvents(now);
	        _super.prototype._next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var events = this._trimBufferThenGetEvents(this._getNow());
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
	        }
	        var index = -1;
	        var len = events.length;
	        while (++index < len && !subscriber.isUnsubscribed) {
	            subscriber.next(events[index].value);
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue_1.queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function (now) {
	        var bufferSize = this.bufferSize;
	        var _windowTime = this._windowTime;
	        var events = this.events;
	        var eventsCount = events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if ((now - events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount += 1;
	        }
	        if (eventsCount > bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
	        }
	        if (spliceCount > 0) {
	            events.splice(0, spliceCount);
	        }
	        return events;
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	exports.ReplaySubject = ReplaySubject;
	var ReplayEvent = (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());
	//# sourceMappingURL=ReplaySubject.js.map

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var QueueScheduler_1 = __webpack_require__(413);
	exports.queue = new QueueScheduler_1.QueueScheduler();
	//# sourceMappingURL=queue.js.map

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Container = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _Subject = __webpack_require__(78);
	
	var _Component2 = __webpack_require__(405);
	
	var _Observable = __webpack_require__(79);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Container = exports.Container = function (_Component) {
	    _inherits(Container, _Component);
	
	    function Container() {
	        _classCallCheck(this, Container);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Container).apply(this, arguments));
	    }
	
	    _createClass(Container, [{
	        key: 'createChildren',
	        value: function createChildren(models) {
	            var _this2 = this;
	
	            var subjects = [];
	            var children = [];
	            return models.switchMap(function (tuple) {
	                var kids = _this2.deref(subjects, children, tuple);
	                if (kids.length === 0) {
	                    return _Observable.Observable.of([tuple]);
	                }
	                return _Observable.Observable.combineLatest(children = kids, function () {
	                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	                        args[_key] = arguments[_key];
	                    }
	
	                    return [tuple].concat(args);
	                });
	            });
	        }
	    }, {
	        key: 'deref',
	        value: function deref(subjects, children, _ref) {
	            var _ref2 = _slicedToArray(_ref, 2);
	
	            var _model = _ref2[0];
	            var _state = _ref2[1];
	
	
	            var index = -1;
	            var count = _state.length;
	
	            while (++index < count) {
	                if (!subjects[index]) {
	                    subjects[index] = new _Subject.Subject();
	                    children[index] = this.createChild(subjects[index], _state[index], index);
	                }
	            }
	
	            index = count - 1;
	            children.length = count;
	            count = subjects.length;
	            while (++index < count) {
	                subjects[index].complete();
	            }
	
	            index = -1;
	            count = subjects.length = children.length;
	            while (++index < count) {
	                var state = _state[index];
	                var model = _model.deref(state);
	                subjects[index].next([model, state, index]);
	            }
	
	            return children;
	        }
	    }]);
	
	    return Container;
	}(_Component2.Component);
	//# sourceMappingURL=Container.js.map

/***/ },
/* 419 */
/***/ function(module, exports) {

	"use strict";
	
	var SVGNS = 'http://www.w3.org/2000/svg';    
	var modulesNS = ['hook', 'on', 'style', 'class', 'props', 'attrs'];
	var slice = Array.prototype.slice;
	
	function isPrimitive(val) {
	  return  typeof val === 'string'   ||
	          typeof val === 'number'   ||
	          typeof val === 'boolean'  ||
	          typeof val === 'symbol'   ||
	          val === null              ||
	          val === undefined;
	}
	
	function normalizeAttrs(attrs, nsURI, defNS, modules) {
	  var map = { ns: nsURI };
	  for (var i = 0, len = modules.length; i < len; i++) {
	    var mod = modules[i];
	    if(attrs[mod])
	      map[mod] = attrs[mod];
	  }
	  for(var key in attrs) {
	    if(key !== 'key' && key !== 'classNames' && key !== 'selector') {
	      var idx = key.indexOf('-');
	      if(idx > 0)
	        addAttr(key.slice(0, idx), key.slice(idx+1), attrs[key]);
	      else if(!map[key])
	        addAttr(defNS, key, attrs[key]);
	    }
	  }
	  return map;
	
	  function addAttr(namespace, key, val) {
	    var ns = map[namespace] || (map[namespace] = {});
	    ns[key] = val;
	  }
	}
	
	function buildFromStringTag(nsURI, defNS, modules, tag, attrs, children) {
	
	  if(attrs.selector) {
	    tag = tag + attrs.selector;
	  }
	  if(attrs.classNames) {
	    var cns = attrs.classNames;
	    tag = tag + '.' + (
	      Array.isArray(cns) ? cns.join('.') : cns.replace(/\s+/g, '.')
	    );
	  }
	
	  return {
	    sel       : tag,
	    data      : normalizeAttrs(attrs, nsURI, defNS, modules),
	    children  : children.map( function(c) {
	      return isPrimitive(c) ? {text: c} : c;
	    }),
	    key: attrs.key
	  };
	}
	
	function buildFromComponent(nsURI, defNS, modules, tag, attrs, children) {
	  var res;
	  if(typeof tag === 'function')
	    res = tag(attrs, children);
	  else if(tag && typeof tag.view === 'function')
	    res = tag.view(attrs, children);
	  else if(tag && typeof tag.render === 'function')
	    res = tag.render(attrs, children);
	  else
	    throw "JSX tag must be either a string, a function or an object with 'view' or 'render' methods";
	  res.key = attrs.key;
	  return res;
	}
	
	function buildVnode(nsURI, defNS, modules, tag, attrs, children) {
	  attrs = attrs || {};
	  if(typeof tag === 'string') {
	    return buildFromStringTag(nsURI, defNS, modules, tag, attrs, children)
	  } else {
	    return buildFromComponent(nsURI, defNS, modules, tag, attrs, children)
	  }
	}
	
	function JSX(nsURI, defNS, modules) {
	  return function jsxWithCustomNS(tag, attrs, children) {
	    if(arguments.length > 3 || !Array.isArray(children))
	      children = slice.call(arguments, 2);
	    return buildVnode(nsURI, defNS || 'props', modules || modulesNS, tag, attrs, children);
	  };
	}
	
	module.exports = {
	  html: JSX(undefined),
	  svg: JSX(SVGNS, 'attrs'),
	  JSX: JSX
	};


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var fromEvent_1 = __webpack_require__(421);
	Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;
	//# sourceMappingURL=fromEvent.js.map

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventObservable_1 = __webpack_require__(422);
	exports.fromEvent = FromEventObservable_1.FromEventObservable.create;
	//# sourceMappingURL=fromEvent.js.map

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(79);
	var tryCatch_1 = __webpack_require__(88);
	var errorObject_1 = __webpack_require__(89);
	var Subscription_1 = __webpack_require__(85);
	function isNodeStyleEventEmmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }
	    /**
	     * @param sourceObj
	     * @param eventName
	     * @param selector
	     * @return {FromEventObservable}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (sourceObj, eventName, selector) {
	        return new FromEventObservable(sourceObj, eventName, selector);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return sourceObj.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmmitter(sourceObj)) {
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };
	        }
	        subscriber.add(new Subscription_1.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(errorObject_1.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };
	    return FromEventObservable;
	}(Observable_1.Observable));
	exports.FromEventObservable = FromEventObservable;
	//# sourceMappingURL=FromEventObservable.js.map

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var merge_1 = __webpack_require__(424);
	Observable_1.Observable.merge = merge_1.merge;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(425);
	exports.merge = merge_1.mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(99);
	var mergeAll_1 = __webpack_require__(199);
	var isScheduler_1 = __webpack_require__(102);
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {Observable} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    observables.unshift(this);
	    return mergeStatic.apply(this, observables);
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {Observable} input1 An input Observable to merge with others.
	 * @param {Observable} input2 An input Observable to merge with others.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The Scheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (observables.length === 1) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var take_1 = __webpack_require__(427);
	Observable_1.Observable.prototype.take = take_1.take;
	//# sourceMappingURL=take.js.map

/***/ },
/* 427 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var ArgumentOutOfRangeError_1 = __webpack_require__(428);
	var EmptyObservable_1 = __webpack_require__(101);
	/**
	 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 * @param total
	 * @return {any}
	 * @method take
	 * @owner Observable
	 */
	function take(total) {
	    if (total === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeOperator(total));
	    }
	}
	exports.take = take;
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeSubscriber = (function (_super) {
	    __extends(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        if (++this.count <= total) {
	            this.destination.next(value);
	            if (this.count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=take.js.map

/***/ },
/* 428 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an element was queried at a certain index of an
	 * Observable, but no such index or position exists in that sequence.
	 *
	 * @see {@link elementAt}
	 * @see {@link take}
	 * @see {@link takeLast}
	 *
	 * @class ArgumentOutOfRangeError
	 */
	var ArgumentOutOfRangeError = (function (_super) {
	    __extends(ArgumentOutOfRangeError, _super);
	    function ArgumentOutOfRangeError() {
	        _super.call(this, 'argument out of range');
	        this.name = 'ArgumentOutOfRangeError';
	    }
	    return ArgumentOutOfRangeError;
	}(Error));
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;
	//# sourceMappingURL=ArgumentOutOfRangeError.js.map

/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var delay_1 = __webpack_require__(430);
	Observable_1.Observable.prototype.delay = delay_1.delay;
	//# sourceMappingURL=delay.js.map

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(431);
	var isDate_1 = __webpack_require__(433);
	var Subscriber_1 = __webpack_require__(83);
	var Notification_1 = __webpack_require__(112);
	/**
	 * Delays the emission of items from the source Observable by a given timeout or
	 * until a given Date.
	 *
	 * <span class="informal">Time shifts each item by some specified amount of
	 * milliseconds.</span>
	 *
	 * <img src="./img/delay.png" width="100%">
	 *
	 * If the delay argument is a Number, this operator time shifts the source
	 * Observable by that amount of time expressed in milliseconds. The relative
	 * time intervals between the values are preserved.
	 *
	 * If the delay argument is a Date, this operator time shifts the start of the
	 * Observable execution until the given date occurs.
	 *
	 * @example <caption>Delay each click by one second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @example <caption>Delay all clicks until a future date happens</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var date = new Date('March 15, 2050 12:00:00'); // in the future
	 * var delayedClicks = clicks.delay(date); // click emitted only after that date
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 *
	 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
	 * a `Date` until which the emission of the source items is delayed.
	 * @param {Scheduler} [scheduler=async] The Scheduler to use for
	 * managing the timers that handle the time-shift for each item.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified timeout or Date.
	 * @method delay
	 * @owner Observable
	 */
	function delay(delay, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteDelay = isDate_1.isDate(delay);
	    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
	    return this.lift(new DelayOperator(delayFor, scheduler));
	}
	exports.delay = delay;
	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	    DelayOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
	    };
	    return DelayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelaySubscriber = (function (_super) {
	    __extends(DelaySubscriber, _super);
	    function DelaySubscriber(destination, delay, scheduler) {
	        _super.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	    }
	    DelaySubscriber.dispatch = function (state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, delay_1);
	        }
	        else {
	            source.active = false;
	        }
	    };
	    DelaySubscriber.prototype._schedule = function (scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	    DelaySubscriber.prototype.scheduleNotification = function (notification) {
	        if (this.errored === true) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        var message = new DelayMessage(scheduler.now() + this.delay, notification);
	        this.queue.push(message);
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	    DelaySubscriber.prototype._next = function (value) {
	        this.scheduleNotification(Notification_1.Notification.createNext(value));
	    };
	    DelaySubscriber.prototype._error = function (err) {
	        this.errored = true;
	        this.queue = [];
	        this.destination.error(err);
	    };
	    DelaySubscriber.prototype._complete = function () {
	        this.scheduleNotification(Notification_1.Notification.createComplete());
	    };
	    return DelaySubscriber;
	}(Subscriber_1.Subscriber));
	var DelayMessage = (function () {
	    function DelayMessage(time, notification) {
	        this.time = time;
	        this.notification = notification;
	    }
	    return DelayMessage;
	}());
	//# sourceMappingURL=delay.js.map

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncScheduler_1 = __webpack_require__(432);
	exports.async = new AsyncScheduler_1.AsyncScheduler();
	//# sourceMappingURL=async.js.map

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FutureAction_1 = __webpack_require__(412);
	var QueueScheduler_1 = __webpack_require__(413);
	var AsyncScheduler = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsyncScheduler.prototype.scheduleNow = function (work, state) {
	        return new FutureAction_1.FutureAction(this, work).schedule(state, 0);
	    };
	    return AsyncScheduler;
	}(QueueScheduler_1.QueueScheduler));
	exports.AsyncScheduler = AsyncScheduler;
	//# sourceMappingURL=AsyncScheduler.js.map

/***/ },
/* 433 */
/***/ function(module, exports) {

	"use strict";
	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}
	exports.isDate = isDate;
	//# sourceMappingURL=isDate.js.map

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var merge_1 = __webpack_require__(425);
	Observable_1.Observable.prototype.merge = merge_1.merge;
	//# sourceMappingURL=merge.js.map

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var finally_1 = __webpack_require__(436);
	Observable_1.Observable.prototype.finally = finally_1._finally;
	//# sourceMappingURL=finally.js.map

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var Subscription_1 = __webpack_require__(85);
	/**
	 * Returns an Observable that mirrors the source Observable, but will call a specified function when
	 * the source terminates on complete or error.
	 * @param {function} finallySelector function to be called when source terminates.
	 * @return {Observable} an Observable that mirrors the source, but will call the specified function on termination.
	 * @method finally
	 * @owner Observable
	 */
	function _finally(finallySelector) {
	    return this.lift(new FinallyOperator(finallySelector));
	}
	exports._finally = _finally;
	var FinallyOperator = (function () {
	    function FinallyOperator(finallySelector) {
	        this.finallySelector = finallySelector;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new FinallySubscriber(subscriber, this.finallySelector));
	    };
	    return FinallyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FinallySubscriber = (function (_super) {
	    __extends(FinallySubscriber, _super);
	    function FinallySubscriber(destination, finallySelector) {
	        _super.call(this, destination);
	        this.add(new Subscription_1.Subscription(finallySelector));
	    }
	    return FinallySubscriber;
	}(Subscriber_1.Subscriber));
	//# sourceMappingURL=finally.js.map

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var concatMap_1 = __webpack_require__(438);
	Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMap_1 = __webpack_require__(130);
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): Observable} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} an observable of values merged from the projected
	 * Observables as they were subscribed to, one at a time. Optionally, these
	 * values may have been projected from a passed `projectResult` argument.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	exports.concatMap = concatMap;
	//# sourceMappingURL=concatMap.js.map

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var startWith_1 = __webpack_require__(440);
	Observable_1.Observable.prototype.startWith = startWith_1.startWith;
	//# sourceMappingURL=startWith.js.map

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(99);
	var ScalarObservable_1 = __webpack_require__(100);
	var EmptyObservable_1 = __webpack_require__(101);
	var concat_1 = __webpack_require__(198);
	var isScheduler_1 = __webpack_require__(102);
	/**
	 * Returns an Observable that emits the items in a specified Iterable before it begins to emit items emitted by the
	 * source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {Values} an Iterable that contains the items you want the modified Observable to emit first.
	 * @return {Observable} an Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
	    }
	}
	exports.startWith = startWith;
	//# sourceMappingURL=startWith.js.map

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var takeUntil_1 = __webpack_require__(442);
	Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;
	//# sourceMappingURL=takeUntil.js.map

/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * @param notifier
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method takeUntil
	 * @owner Observable
	 */
	function takeUntil(notifier) {
	    return this.lift(new TakeUntilOperator(notifier));
	}
	exports.takeUntil = takeUntil;
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
	    };
	    return TakeUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeUntilSubscriber = (function (_super) {
	    __extends(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=takeUntil.js.map

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var mergeMapTo_1 = __webpack_require__(444);
	Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
	Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(118);
	var subscribeToResult_1 = __webpack_require__(116);
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in the output Observable.
	 *
	 * <span class="informal">It's like {@link mergeMap}, but maps each value always
	 * to the same inner Observable.</span>
	 *
	 * <img src="./img/mergeMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then merges those resulting Observables into one
	 * single Observable, which is the output Observable.
	 *
	 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 * @see {@link switchMapTo}
	 *
	 * @param {Observable} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable.
	 * @method mergeMapTo
	 * @owner Observable
	 */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
	}
	exports.mergeMapTo = mergeMapTo;
	// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
	//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapToOperator.prototype.call = function (observer, source) {
	        return source._subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
	    };
	    return MergeMapToOperator;
	}());
	exports.MergeMapToOperator = MergeMapToOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapToSubscriber = (function (_super) {
	    __extends(MergeMapToSubscriber, _super);
	    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapToSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            this.active++;
	            this._innerSub(ish, destination, resultSelector, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapToSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    MergeMapToSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapToSubscriber = MergeMapToSubscriber;
	//# sourceMappingURL=mergeMapTo.js.map

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(79);
	var debounceTime_1 = __webpack_require__(446);
	Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(83);
	var async_1 = __webpack_require__(431);
	/**
	 * Returns the source Observable delayed by the computed debounce duration,
	 * with the duration lengthened if a new source item arrives before the delay
	 * duration ends.
	 * In practice, for each item emitted on the source, this operator holds the
	 * latest item, waits for a silence for the `dueTime` length, and only then
	 * emits the latest source item on the result Observable.
	 * Optionally takes a scheduler for manging timers.
	 * @param {number} dueTime the timeout value for the window of time required to not drop the item.
	 * @param {Scheduler} [scheduler] the Scheduler to use for managing the timers that handle the timeout for each item.
	 * @return {Observable} an Observable the same as source Observable, but drops items.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	exports.debounceTime = debounceTime;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source._subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}
	//# sourceMappingURL=debounceTime.js.map

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	// jshint newcap: false
	/* global require, module, document, Node */
	'use strict';
	
	var VNode = __webpack_require__(448);
	var is = __webpack_require__(449);
	var domApi = __webpack_require__(450);
	
	function isUndef(s) { return s === undefined; }
	function isDef(s) { return s !== undefined; }
	
	var emptyNode = VNode('', {}, [], undefined, undefined);
	
	function sameVnode(vnode1, vnode2) {
	  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
	}
	
	function createKeyToOldIdx(children, beginIdx, endIdx) {
	  var i, map = {}, key;
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) map[key] = i;
	  }
	  return map;
	}
	
	var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];
	
	function init(modules, api) {
	  var i, j, cbs = {};
	
	  if (isUndef(api)) api = domApi;
	
	  for (i = 0; i < hooks.length; ++i) {
	    cbs[hooks[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
	    }
	  }
	
	  function emptyNodeAt(elm) {
	    return VNode(api.tagName(elm).toLowerCase(), {}, [], undefined, elm);
	  }
	
	  function createRmCb(childElm, listeners) {
	    return function() {
	      if (--listeners === 0) {
	        var parent = api.parentNode(childElm);
	        api.removeChild(parent, childElm);
	      }
	    };
	  }
	
	  function createElm(vnode, insertedVnodeQueue) {
	    var i, thunk, data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode);
	      if (isDef(i = data.vnode)) {
	          thunk = vnode;
	          vnode = i;
	      }
	    }
	    var elm, children = vnode.children, sel = vnode.sel;
	    if (isDef(sel)) {
	      // Parse selector
	      var hashIdx = sel.indexOf('#');
	      var dotIdx = sel.indexOf('.', hashIdx);
	      var hash = hashIdx > 0 ? hashIdx : sel.length;
	      var dot = dotIdx > 0 ? dotIdx : sel.length;
	      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
	      elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)
	                                                          : api.createElement(tag);
	      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
	      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
	      if (is.array(children)) {
	        for (i = 0; i < children.length; ++i) {
	          api.appendChild(elm, createElm(children[i], insertedVnodeQueue));
	        }
	      } else if (is.primitive(vnode.text)) {
	        api.appendChild(elm, api.createTextNode(vnode.text));
	      }
	      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
	      i = vnode.data.hook; // Reuse variable
	      if (isDef(i)) {
	        if (i.create) i.create(emptyNode, vnode);
	        if (i.insert) insertedVnodeQueue.push(vnode);
	      }
	    } else {
	      elm = vnode.elm = api.createTextNode(vnode.text);
	    }
	    if (isDef(thunk)) thunk.elm = vnode.elm;
	    return vnode.elm;
	  }
	
	  function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
	    }
	  }
	
	  function invokeDestroyHook(vnode) {
	    var i, j, data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
	      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
	      if (isDef(i = vnode.children)) {
	        for (j = 0; j < vnode.children.length; ++j) {
	          invokeDestroyHook(vnode.children[j]);
	        }
	      }
	      if (isDef(i = data.vnode)) invokeDestroyHook(i);
	    }
	  }
	
	  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var i, listeners, rm, ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.sel)) {
	          invokeDestroyHook(ch);
	          listeners = cbs.remove.length + 1;
	          rm = createRmCb(ch.elm, listeners);
	          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
	          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
	            i(ch, rm);
	          } else {
	            rm();
	          }
	        } else { // Text node
	          api.removeChild(parentElm, ch.elm);
	        }
	      }
	    }
	  }
	
	  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
	    var oldStartIdx = 0, newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, before;
	
	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
	        idxInOld = oldKeyToIdx[newStartVnode.key];
	        if (isUndef(idxInOld)) { // New element
	          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	          oldCh[idxInOld] = undefined;
	          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
	      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }
	
	  function patchVnode(oldVnode, vnode, insertedVnodeQueue) {
	    var i, hook;
	    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    if (isDef(i = oldVnode.data) && isDef(i = i.vnode)) oldVnode = i;
	    if (isDef(i = vnode.data) && isDef(i = i.vnode)) {
	      patchVnode(oldVnode, i, insertedVnodeQueue);
	      vnode.elm = i.elm;
	      return;
	    }
	    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
	    if (oldVnode === vnode) return;
	    if (!sameVnode(oldVnode, vnode)) {
	      var parentElm = api.parentNode(oldVnode.elm);
	      elm = createElm(vnode, insertedVnodeQueue);
	      api.insertBefore(parentElm, elm, oldVnode.elm);
	      removeVnodes(parentElm, [oldVnode], 0, 0);
	      return;
	    }
	    if (isDef(vnode.data)) {
	      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
	      i = vnode.data.hook;
	      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) api.setTextContent(elm, '');
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        api.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      api.setTextContent(elm, vnode.text);
	    }
	    if (isDef(hook) && isDef(i = hook.postpatch)) {
	      i(oldVnode, vnode);
	    }
	  }
	
	  return function(oldVnode, vnode) {
	    var i, elm, parent;
	    var insertedVnodeQueue = [];
	    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
	
	    if (isUndef(oldVnode.sel)) {
	      oldVnode = emptyNodeAt(oldVnode);
	    }
	
	    if (sameVnode(oldVnode, vnode)) {
	      patchVnode(oldVnode, vnode, insertedVnodeQueue);
	    } else {
	      elm = oldVnode.elm;
	      parent = api.parentNode(elm);
	
	      createElm(vnode, insertedVnodeQueue);
	
	      if (parent !== null) {
	        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));
	        removeVnodes(parent, [oldVnode], 0, 0);
	      }
	    }
	
	    for (i = 0; i < insertedVnodeQueue.length; ++i) {
	      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
	    }
	    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
	    return vnode;
	  };
	}
	
	module.exports = {init: init};


/***/ },
/* 448 */
/***/ function(module, exports) {

	module.exports = function(sel, data, children, text, elm) {
	  var key = data === undefined ? undefined : data.key;
	  return {sel: sel, data: data, children: children,
	          text: text, elm: elm, key: key};
	};


/***/ },
/* 449 */
/***/ function(module, exports) {

	module.exports = {
	  array: Array.isArray,
	  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
	};


/***/ },
/* 450 */
/***/ function(module, exports) {

	function createElement(tagName){
	  return document.createElement(tagName);
	}
	
	function createElementNS(namespaceURI, qualifiedName){
	  return document.createElementNS(namespaceURI, qualifiedName);
	}
	
	function createTextNode(text){
	  return document.createTextNode(text);
	}
	
	
	function insertBefore(parentNode, newNode, referenceNode){
	  parentNode.insertBefore(newNode, referenceNode);
	}
	
	
	function removeChild(node, child){
	  node.removeChild(child);
	}
	
	function appendChild(node, child){
	  node.appendChild(child);
	}
	
	function parentNode(node){
	  return node.parentElement;
	}
	
	function nextSibling(node){
	  return node.nextSibling;
	}
	
	function tagName(node){
	  return node.tagName;
	}
	
	function setTextContent(node, text){
	  node.textContent = text;
	}
	
	module.exports = {
	  createElement: createElement,
	  createElementNS: createElementNS,
	  createTextNode: createTextNode,
	  appendChild: appendChild,
	  removeChild: removeChild,
	  insertBefore: insertBefore,
	  parentNode: parentNode,
	  nextSibling: nextSibling,
	  tagName: tagName,
	  setTextContent: setTextContent
	};


/***/ },
/* 451 */
/***/ function(module, exports) {

	function updateClass(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldClass = oldVnode.data.class || {},
	      klass = vnode.data.class || {};
	  for (name in oldClass) {
	    if (!klass[name]) {
	      elm.classList.remove(name);
	    }
	  }
	  for (name in klass) {
	    cur = klass[name];
	    if (cur !== oldClass[name]) {
	      elm.classList[cur ? 'add' : 'remove'](name);
	    }
	  }
	}
	
	module.exports = {create: updateClass, update: updateClass};


/***/ },
/* 452 */
/***/ function(module, exports) {

	function updateProps(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
	  for (key in oldProps) {
	    if (!props[key]) {
	      delete elm[key];
	    }
	  }
	  for (key in props) {
	    cur = props[key];
	    old = oldProps[key];
	    if (old !== cur && (key !== 'value' || elm[key] !== cur)) {
	      elm[key] = cur;
	    }
	  }
	}
	
	module.exports = {create: updateProps, update: updateProps};


/***/ },
/* 453 */
/***/ function(module, exports) {

	var raf = (typeof window !== 'undefined' && window.requestAnimationFrame) || setTimeout;
	var nextFrame = function(fn) { raf(function() { raf(fn); }); };
	
	function setNextFrame(obj, prop, val) {
	  nextFrame(function() { obj[prop] = val; });
	}
	
	function updateStyle(oldVnode, vnode) {
	  var cur, name, elm = vnode.elm,
	      oldStyle = oldVnode.data.style || {},
	      style = vnode.data.style || {},
	      oldHasDel = 'delayed' in oldStyle;
	  for (name in oldStyle) {
	    if (!style[name]) {
	      elm.style[name] = '';
	    }
	  }
	  for (name in style) {
	    cur = style[name];
	    if (name === 'delayed') {
	      for (name in style.delayed) {
	        cur = style.delayed[name];
	        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
	          setNextFrame(elm.style, name, cur);
	        }
	      }
	    } else if (name !== 'remove' && cur !== oldStyle[name]) {
	      elm.style[name] = cur;
	    }
	  }
	}
	
	function applyDestroyStyle(vnode) {
	  var style, name, elm = vnode.elm, s = vnode.data.style;
	  if (!s || !(style = s.destroy)) return;
	  for (name in style) {
	    elm.style[name] = style[name];
	  }
	}
	
	function applyRemoveStyle(vnode, rm) {
	  var s = vnode.data.style;
	  if (!s || !s.remove) {
	    rm();
	    return;
	  }
	  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
	      compStyle, style = s.remove, amount = 0, applied = [];
	  for (name in style) {
	    applied.push(name);
	    elm.style[name] = style[name];
	  }
	  compStyle = getComputedStyle(elm);
	  var props = compStyle['transition-property'].split(', ');
	  for (; i < props.length; ++i) {
	    if(applied.indexOf(props[i]) !== -1) amount++;
	  }
	  elm.addEventListener('transitionend', function(ev) {
	    if (ev.target === elm) --amount;
	    if (amount === 0) rm();
	  });
	}
	
	module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};


/***/ },
/* 454 */
/***/ function(module, exports) {

	var booleanAttrs = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "compact", "controls", "declare", 
	                "default", "defaultchecked", "defaultmuted", "defaultselected", "defer", "disabled", "draggable", 
	                "enabled", "formnovalidate", "hidden", "indeterminate", "inert", "ismap", "itemscope", "loop", "multiple", 
	                "muted", "nohref", "noresize", "noshade", "novalidate", "nowrap", "open", "pauseonexit", "readonly", 
	                "required", "reversed", "scoped", "seamless", "selected", "sortable", "spellcheck", "translate", 
	                "truespeed", "typemustmatch", "visible"];
	    
	var booleanAttrsDict = {};
	for(var i=0, len = booleanAttrs.length; i < len; i++) {
	  booleanAttrsDict[booleanAttrs[i]] = true;
	}
	    
	function updateAttrs(oldVnode, vnode) {
	  var key, cur, old, elm = vnode.elm,
	      oldAttrs = oldVnode.data.attrs || {}, attrs = vnode.data.attrs || {};
	  
	  // update modified attributes, add new attributes
	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      // TODO: add support to namespaced attributes (setAttributeNS)
	      if(!cur && booleanAttrsDict[key])
	        elm.removeAttribute(key);
	      else
	        elm.setAttribute(key, cur);
	    }
	  }
	  //remove removed attributes
	  // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)
	  // the other option is to remove all attributes with value == undefined
	  for (key in oldAttrs) {
	    if (!(key in attrs)) {
	      elm.removeAttribute(key);
	    }
	  }
	}
	
	module.exports = {create: updateAttrs, update: updateAttrs};


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	var is = __webpack_require__(449);
	
	function arrInvoker(arr) {
	  return function() {
	    // Special case when length is two, for performance
	    arr.length === 2 ? arr[0](arr[1]) : arr[0].apply(undefined, arr.slice(1));
	  };
	}
	
	function fnInvoker(o) {
	  return function(ev) { o.fn(ev); };
	}
	
	function updateEventListeners(oldVnode, vnode) {
	  var name, cur, old, elm = vnode.elm,
	      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
	  if (!on) return;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    if (old === undefined) {
	      if (is.array(cur)) {
	        elm.addEventListener(name, arrInvoker(cur));
	      } else {
	        cur = {fn: cur};
	        on[name] = cur;
	        elm.addEventListener(name, fnInvoker(cur));
	      }
	    } else if (is.array(old)) {
	      // Deliberately modify old array since it's captured in closure created with `arrInvoker`
	      old.length = cur.length;
	      for (var i = 0; i < old.length; ++i) old[i] = cur[i];
	      on[name]  = old;
	    } else {
	      old.fn = cur;
	      on[name] = old;
	    }
	  }
	}
	
	module.exports = {create: updateEventListeners, update: updateEventListeners};


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.App = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	var _Tasks = __webpack_require__(457);
	
	var _Controls = __webpack_require__(483);
	
	var _TaskInput = __webpack_require__(484);
	
	function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx hJSX */
	
	
	var fromEvent = _Observable.Observable.fromEvent;
	
	
	// require('./app.css');
	
	var App = exports.App = function (_Component) {
	    _inherits(App, _Component);
	
	    function App() {
	        _classCallCheck(this, App);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(App).apply(this, arguments));
	    }
	
	    _createClass(App, [{
	        key: 'createChildren',
	        value: function createChildren(models) {
	
	            var tasks = new _Tasks.Tasks(models.deref('tasks'));
	            var input = new _TaskInput.TaskInput(models.deref('input'));
	            var footer = new _Controls.Controls(models.deref('tasks'));
	
	            return models.switchMap(function (tuple) {
	                return _Observable.Observable.combineLatest(input, tasks, footer, function () {
	                    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {
	                        children[_key] = arguments[_key];
	                    }
	
	                    return [tuple].concat(children);
	                });
	            });
	        }
	    }, {
	        key: 'loader',
	        value: function loader(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return model.get('input.value', 'tasks.length', 'tasks.filter', '[\'apiVersion\', \'globalTaskId\']');
	        }
	    }, {
	        key: 'events',
	        value: function events(_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 2);
	
	            var model = _ref4[0];
	            var state = _ref4[1];
	
	            return fromEvent(window, 'hashchange') //.startWith(0)
	            .map(function () {
	                return (location.hash || '#/').slice(2) || 'all';
	            }).filter(function (filter) {
	                return filter !== state.tasks.filter;
	            }).switchMap(function (filter) {
	                return model.set({ json: { tasks: { filter: filter } } });
	            }, function (filter, _ref5) {
	                var json = _ref5.json;
	                return _extends({}, state, json);
	            }).map(function (newState) {
	                return [model, state = newState];
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render(_ref6) {
	            var _ref7 = _toArray(_ref6);
	
	            var _ref7$ = _slicedToArray(_ref7[0], 2);
	
	            var model = _ref7$[0];
	            var state = _ref7$[1];
	
	            var children = _ref7.slice(1);
	
	            return (0, _.hJSX)(
	                'section',
	                { 'class': { 'todoapp': true } },
	                children.filter(function (x) {
	                    return !!x;
	                })
	            );
	        }
	    }]);
	
	    return App;
	}(_.Component);

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Tasks = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _lodash = __webpack_require__(458);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _Task = __webpack_require__(471);
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	var _falcorJsonGraph = __webpack_require__(472);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx hJSX */
	
	
	var Tasks = exports.Tasks = function (_Container) {
	    _inherits(Tasks, _Container);
	
	    function Tasks() {
	        _classCallCheck(this, Tasks);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Tasks).apply(this, arguments));
	    }
	
	    _createClass(Tasks, [{
	        key: 'loader',
	        value: function loader(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return model.getItems(function getTasksPaths() {
	                return [['length']];
	            }, function getTaskPaths(_ref3) {
	                var length = _ref3.json.length;
	
	                return length === 0 ? [['filter']] : [['filter'], [{ length: length }, 'completed']];
	            });
	        }
	    }, {
	        key: 'deref',
	        value: function deref(subjects, children, _ref4) {
	            var _ref5 = _slicedToArray(_ref4, 2);
	
	            var model = _ref5[0];
	            var state = _ref5[1];
	            var _state = state;
	            var filter = _state.filter;
	
	
	            if (filter === 'completed') {
	                state = (0, _lodash2.default)(state, function (_ref6) {
	                    var completed = _ref6.completed;
	                    return completed;
	                });
	            } else if (filter === 'active') {
	                state = (0, _lodash2.default)(state, function (_ref7) {
	                    var completed = _ref7.completed;
	                    return !completed;
	                });
	            }
	
	            state.filter = filter;
	
	            return _get(Object.getPrototypeOf(Tasks.prototype), 'deref', this).call(this, subjects, children, [model, state]);
	        }
	    }, {
	        key: 'createChild',
	        value: function createChild(childUpdates, childState, childIndex) {
	            return new _Task.Task(childUpdates);
	        }
	    }, {
	        key: 'events',
	        value: function events(_ref8) {
	            var _ref9 = _slicedToArray(_ref8, 2);
	
	            var model = _ref9[0];
	            var state = _ref9[1];
	
	            return this.listen('toggleAll').map(function (_ref10) {
	                var target = _ref10.target;
	                return target.checked;
	            }).switchMap(function (bool) {
	                return model.set((0, _falcorJsonGraph.pathValue)('length', state.length), (0, _falcorJsonGraph.pathValue)('[0...' + state.length + '].completed', bool));
	            }, function (bool, _ref11) {
	                var json = _ref11.json;
	                return json;
	            }).map(function (newState) {
	                return [model, state = newState];
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render(_ref12) {
	            var _ref13 = _toArray(_ref12);
	
	            var _ref13$ = _slicedToArray(_ref13[0], 2);
	
	            var model = _ref13$[0];
	            var state = _ref13$[1];
	
	            var taskVDoms = _ref13.slice(1);
	
	            var children = [];
	            var length = state.length;
	
	
	            if (length > 0) {
	                var completed = length === (0, _lodash2.default)(state, function (_ref14) {
	                    var completed = _ref14.completed;
	                    return completed;
	                }).length;
	                children.push((0, _.hJSX)('input', { type: 'checkbox',
	                    checked: completed,
	                    'class': { 'toggle-all': true },
	                    'on-click': this.dispatch('toggleAll') }));
	                children.push((0, _.hJSX)(
	                    'label',
	                    { attrs: { 'for': 'toggle-all' } },
	                    'Mark all as complete'
	                ));
	                children.push((0, _.hJSX)(
	                    'ul',
	                    { 'class': { 'todo-list': true } },
	                    taskVDoms
	                ));
	            }
	
	            return (0, _.hJSX)(
	                'section',
	                { 'class': { 'main': true } },
	                children
	            );
	        }
	    }]);
	
	    return Tasks;
	}(_.Container);

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var arrayFilter = __webpack_require__(459),
	    baseCallback = __webpack_require__(460),
	    baseFilter = __webpack_require__(469),
	    isArray = __webpack_require__(462);
	
	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is bound to `thisArg` and
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * If a property name is provided for `predicate` the created `_.property`
	 * style callback returns the property value of the given element.
	 *
	 * If a value is also provided for `thisArg` the created `_.matchesProperty`
	 * style callback returns `true` for elements that have a matching property
	 * value, else `false`.
	 *
	 * If an object is provided for `predicate` the created `_.matches` style
	 * callback returns `true` for elements that have the properties of the given
	 * object, else `false`.
	 *
	 * @static
	 * @memberOf _
	 * @alias select
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function|Object|string} [predicate=_.identity] The function invoked
	 *  per iteration.
	 * @param {*} [thisArg] The `this` binding of `predicate`.
	 * @returns {Array} Returns the new filtered array.
	 * @example
	 *
	 * _.filter([4, 5, 6], function(n) {
	 *   return n % 2 == 0;
	 * });
	 * // => [4, 6]
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // using the `_.matches` callback shorthand
	 * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
	 * // => ['barney']
	 *
	 * // using the `_.matchesProperty` callback shorthand
	 * _.pluck(_.filter(users, 'active', false), 'user');
	 * // => ['fred']
	 *
	 * // using the `_.property` callback shorthand
	 * _.pluck(_.filter(users, 'active'), 'user');
	 * // => ['barney']
	 */
	function filter(collection, predicate, thisArg) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  predicate = baseCallback(predicate, thisArg, 3);
	  return func(collection, predicate);
	}
	
	module.exports = filter;


/***/ },
/* 459 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/**
	 * A specialized version of `_.filter` for arrays without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array.length,
	      resIndex = -1,
	      result = [];
	
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[++resIndex] = value;
	    }
	  }
	  return result;
	}
	
	module.exports = arrayFilter;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseIsEqual = __webpack_require__(461),
	    bindCallback = __webpack_require__(467),
	    isArray = __webpack_require__(462),
	    pairs = __webpack_require__(468);
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}
	
	/**
	 * The base implementation of `_.callback` which supports specifying the
	 * number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function baseCallback(func, thisArg, argCount) {
	  var type = typeof func;
	  if (type == 'function') {
	    return thisArg === undefined
	      ? func
	      : bindCallback(func, thisArg, argCount);
	  }
	  if (func == null) {
	    return identity;
	  }
	  if (type == 'object') {
	    return baseMatches(func);
	  }
	  return thisArg === undefined
	    ? property(func)
	    : baseMatchesProperty(func, thisArg);
	}
	
	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	/**
	 * The base implementation of `_.isMatch` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} matchData The propery names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = toObject(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
	      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	/**
	 * The base implementation of `_.matches` which does not clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    var key = matchData[0][0],
	        value = matchData[0][1];
	
	    return function(object) {
	      if (object == null) {
	        return false;
	      }
	      return object[key] === value && (value !== undefined || (key in toObject(object)));
	    };
	  }
	  return function(object) {
	    return baseIsMatch(object, matchData);
	  };
	}
	
	/**
	 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to compare.
	 * @returns {Function} Returns the new function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  var isArr = isArray(path),
	      isCommon = isKey(path) && isStrictComparable(srcValue),
	      pathKey = (path + '');
	
	  path = toPath(path);
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    var key = pathKey;
	    object = toObject(object);
	    if ((isArr || !isCommon) && !(key in object)) {
	      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
	      if (object == null) {
	        return false;
	      }
	      key = last(path);
	      object = toObject(object);
	    }
	    return object[key] === srcValue
	      ? (srcValue !== undefined || (key in object))
	      : baseIsEqual(srcValue, object[key], undefined, true);
	  };
	}
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function basePropertyDeep(path) {
	  var pathKey = (path + '');
	  path = toPath(path);
	  return function(object) {
	    return baseGet(object, path, pathKey);
	  };
	}
	
	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;
	
	  start = start == null ? 0 : (+start || 0);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : (+end || 0);
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;
	
	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}
	
	/**
	 * Gets the propery names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = pairs(object),
	      length = result.length;
	
	  while (length--) {
	    result[length][2] = isStrictComparable(result[length][1]);
	  }
	  return result;
	}
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  var type = typeof value;
	  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
	    return true;
	  }
	  if (isArray(value)) {
	    return false;
	  }
	  var result = !reIsDeepProp.test(value);
	  return result || (object != null && value in toObject(object));
	}
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}
	
	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array ? array.length : 0;
	  return length ? array[length - 1] : undefined;
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * Creates a function that returns the property value at `path` on a
	 * given object.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': { 'c': 2 } } },
	 *   { 'a': { 'b': { 'c': 1 } } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b.c'));
	 * // => [2, 1]
	 *
	 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
	}
	
	module.exports = baseCallback;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var isArray = __webpack_require__(462),
	    isTypedArray = __webpack_require__(463),
	    keys = __webpack_require__(464);
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    stringTag = '[object String]';
	
	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * A specialized version of `_.some` for arrays without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.isEqual` without support for `this` binding
	 * `customizer` functions.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing objects.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
	 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = objToString.call(object);
	    if (objTag == argsTag) {
	      objTag = objectTag;
	    } else if (objTag != objectTag) {
	      objIsArr = isTypedArray(object);
	    }
	  }
	  if (!othIsArr) {
	    othTag = objToString.call(other);
	    if (othTag == argsTag) {
	      othTag = objectTag;
	    } else if (othTag != objectTag) {
	      othIsArr = isTypedArray(other);
	    }
	  }
	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !(objIsArr || objIsObj)) {
	    return equalByTag(object, other, objTag);
	  }
	  if (!isLoose) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  // For more information on detecting circular references see https://es5.github.io/#JO.
	  stackA || (stackA = []);
	  stackB || (stackB = []);
	
	  var length = stackA.length;
	  while (length--) {
	    if (stackA[length] == object) {
	      return stackB[length] == other;
	    }
	  }
	  // Add `object` and `other` to the stack of traversed objects.
	  stackA.push(object);
	  stackB.push(other);
	
	  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
	
	  stackA.pop();
	  stackB.pop();
	
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing arrays.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var index = -1,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
	    return false;
	  }
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index],
	        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;
	
	    if (result !== undefined) {
	      if (result) {
	        continue;
	      }
	      return false;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (isLoose) {
	      if (!arraySome(other, function(othValue) {
	            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
	          })) {
	        return false;
	      }
	    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} value The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag) {
	  switch (tag) {
	    case boolTag:
	    case dateTag:
	      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
	      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
	      return +object == +other;
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case numberTag:
	      // Treat `NaN` vs. `NaN` as equal.
	      return (object != +object)
	        ? other != +other
	        : object == +other;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings primitives and string
	      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
	      return object == (other + '');
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparing values.
	 * @param {boolean} [isLoose] Specify performing partial comparisons.
	 * @param {Array} [stackA] Tracks traversed `value` objects.
	 * @param {Array} [stackB] Tracks traversed `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
	  var objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isLoose) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  var skipCtor = isLoose;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key],
	        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;
	
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
	      return false;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (!skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      return false;
	    }
	  }
	  return true;
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = baseIsEqual;


/***/ },
/* 462 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';
	
	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');
	
	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}
	
	module.exports = isArray;


/***/ },
/* 463 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dateTag] = typedArrayTags[errorTag] =
	typedArrayTags[funcTag] = typedArrayTags[mapTag] =
	typedArrayTags[numberTag] = typedArrayTags[objectTag] =
	typedArrayTags[regexpTag] = typedArrayTags[setTag] =
	typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
	
	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/**
	 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	function isTypedArray(value) {
	  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
	}
	
	module.exports = isTypedArray;


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(465),
	    isArguments = __webpack_require__(466),
	    isArray = __webpack_require__(462);
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');
	
	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;
	
	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));
	
	  var index = -1,
	      result = [];
	
	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};
	
	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;
	
	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;
	
	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	module.exports = keys;


/***/ },
/* 465 */
/***/ function(module, exports) {

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/** `Object#toString` result references. */
	var funcTag = '[object Function]';
	
	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}
	
	module.exports = getNative;


/***/ },
/* 466 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/** Used for native method references. */
	var objectProto = Object.prototype;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/** Native method references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	
	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is classified as an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  return isObjectLike(value) && isArrayLike(value) &&
	    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
	}
	
	module.exports = isArguments;


/***/ },
/* 467 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	
	/**
	 * A specialized version of `baseCallback` which only supports `this` binding
	 * and specifying the number of arguments to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {number} [argCount] The number of arguments to provide to `func`.
	 * @returns {Function} Returns the callback.
	 */
	function bindCallback(func, thisArg, argCount) {
	  if (typeof func != 'function') {
	    return identity;
	  }
	  if (thisArg === undefined) {
	    return func;
	  }
	  switch (argCount) {
	    case 1: return function(value) {
	      return func.call(thisArg, value);
	    };
	    case 3: return function(value, index, collection) {
	      return func.call(thisArg, value, index, collection);
	    };
	    case 4: return function(accumulator, value, index, collection) {
	      return func.call(thisArg, accumulator, value, index, collection);
	    };
	    case 5: return function(value, other, key, object, source) {
	      return func.call(thisArg, value, other, key, object, source);
	    };
	  }
	  return function() {
	    return func.apply(thisArg, arguments);
	  };
	}
	
	/**
	 * This method returns the first argument provided to it.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * _.identity(object) === object;
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	module.exports = bindCallback;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var keys = __webpack_require__(464);
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Creates a two dimensional array of the key-value pairs for `object`,
	 * e.g. `[[key1, value1], [key2, value2]]`.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the new array of key-value pairs.
	 * @example
	 *
	 * _.pairs({ 'barney': 36, 'fred': 40 });
	 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
	 */
	function pairs(object) {
	  object = toObject(object);
	
	  var index = -1,
	      props = keys(object),
	      length = props.length,
	      result = Array(length);
	
	  while (++index < length) {
	    var key = props[index];
	    result[index] = [key, object[key]];
	  }
	  return result;
	}
	
	module.exports = pairs;


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseEach = __webpack_require__(470);
	
	/**
	 * The base implementation of `_.filter` without support for callback
	 * shorthands or `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}
	
	module.exports = baseFilter;


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var keys = __webpack_require__(464);
	
	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/**
	 * The base implementation of `_.forEach` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Array|Object|string} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object|string} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);
	
	/**
	 * The base implementation of `baseForIn` and `baseForOwn` which iterates
	 * over `object` properties returned by `keysFunc` invoking `iteratee` for
	 * each property. Iteratee functions may exit iteration early by explicitly
	 * returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();
	
	/**
	 * The base implementation of `_.forOwn` without support for callback
	 * shorthands and `this` binding.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return baseFor(object, iteratee, keys);
	}
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    var length = collection ? getLength(collection) : 0;
	    if (!isLength(length)) {
	      return eachFunc(collection, iteratee);
	    }
	    var index = fromRight ? length : -1,
	        iterable = toObject(collection);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}
	
	/**
	 * Creates a base function for `_.forIn` or `_.forInRight`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var iterable = toObject(object),
	        props = keysFunc(object),
	        length = props.length,
	        index = fromRight ? length : -1;
	
	    while ((fromRight ? index-- : ++index < length)) {
	      var key = props[index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}
	
	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}
	
	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	module.exports = baseEach;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Task = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx hJSX */
	
	
	var Task = exports.Task = function (_Component) {
	    _inherits(Task, _Component);
	
	    function Task() {
	        _classCallCheck(this, Task);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Task).apply(this, arguments));
	    }
	
	    _createClass(Task, [{
	        key: 'loader',
	        value: function loader(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return model.get('[\'id\', \'content\', \'completed\']');
	        }
	    }, {
	        key: 'events',
	        value: function events(_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 2);
	
	            var model = _ref4[0];
	            var state = _ref4[1];
	
	            return _Observable.Observable.merge(this.listen('edit').map(function () {
	                return _extends({}, state, { editing: true });
	            }), this.listen('done').map(function (_ref5) {
	                var target = _ref5.target;
	                return target.checked;
	            }).switchMap(function (completed) {
	                return model.call(['toggle'], [completed]);
	            }, function (completed) {
	                return _extends({}, state, { completed: completed, editing: false });
	            }), this.listen('blur').merge(this.listen('commit').filter(function (ev) {
	                return ev.keyIdentifier === 'Enter';
	            })).map(function (_ref6) {
	                var target = _ref6.target;
	                return target.value;
	            }).switchMap(function (content) {
	                return model.set({ json: { content: content } });
	            }, function (content) {
	                return _extends({}, state, { content: content, editing: false });
	            }), this.listen('destroy').switchMap(function () {
	                return model.call(['remove']);
	            }, function (ev) {
	                return { id: '', content: '', completed: '' };
	            })).map(function (newState) {
	                return [model, state = newState];
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render(_ref7) {
	            var _ref8 = _slicedToArray(_ref7, 2);
	
	            var model = _ref8[0];
	            var _ref8$ = _ref8[1];
	            var id = _ref8$.id;
	            var content = _ref8$.content;
	            var completed = _ref8$.completed;
	            var _ref8$$editing = _ref8$.editing;
	            var editing = _ref8$$editing === undefined ? false : _ref8$$editing;
	
	            return (0, _.hJSX)(
	                'li',
	                { 'class': { editing: editing, completed: completed && !editing } },
	                (0, _.hJSX)(
	                    'div',
	                    { 'class': { 'view': true } },
	                    (0, _.hJSX)('input', { 'class': { 'toggle': true },
	                        type: 'checkbox',
	                        checked: completed && !editing,
	                        'on-click': this.dispatch('done') }),
	                    (0, _.hJSX)(
	                        'label',
	                        { 'on-dblclick': this.dispatch('edit') },
	                        content
	                    ),
	                    (0, _.hJSX)('button', { 'class': { 'destroy': true },
	                        'on-click': this.dispatch('destroy') })
	                ),
	                (0, _.hJSX)('input', { 'class': { 'edit': true },
	                    value: content,
	                    'on-blur': this.dispatch('blur'),
	                    'on-keydown': this.dispatch('commit'),
	                    hook: {
	                        postpatch: function postpatch(old, _ref9) {
	                            var elm = _ref9.elm;
	
	                            if (editing) {
	                                elm.focus();
	                            }
	                        }
	                    } })
	            );
	        }
	    }]);
	
	    return Task;
	}(_.Component);

/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	var pathSyntax = __webpack_require__(473);
	
	function sentinel(type, value, props) {
	    var copy = Object.create(null);
	    if (props != null) {
	        for(var key in props) {
	            copy[key] = props[key];
	        }
	        
	        copy["$type"] = type;
	        copy.value = value;
	        return copy;
	    }
	    else {
	        return { $type: type, value: value };
	    }    
	}
	
	module.exports = {
	    ref: function ref(path, props) {
	        return sentinel("ref", pathSyntax.fromPath(path), props);
	    },
	    atom: function atom(value, props) {
	        return sentinel("atom", value, props);        
	    },
	    undefined: function() {
	        return sentinel("atom");
	    },    
	    error: function error(errorValue, props) {
	        return sentinel("error", errorValue, props);        
	    },
	    pathValue: function pathValue(path, value) {
	        return { path: pathSyntax.fromPath(path), value: value };
	    },
	    pathInvalidation: function pathInvalidation(path) {
	        return { path: pathSyntax.fromPath(path), invalidated: true };
	    }    
	};


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	var Tokenizer = __webpack_require__(474);
	var head = __webpack_require__(476);
	var RoutedTokens = __webpack_require__(482);
	
	var parser = function parser(string, extendedRules) {
	    return head(new Tokenizer(string, extendedRules));
	};
	
	module.exports = parser;
	
	// Constructs the paths from paths / pathValues that have strings.
	// If it does not have a string, just moves the value into the return
	// results.
	parser.fromPathsOrPathValues = function(paths, ext) {
	    if (!paths) {
	        return [];
	    }
	
	    var out = [];
	    for (var i = 0, len = paths.length; i < len; i++) {
	
	        // Is the path a string
	        if (typeof paths[i] === 'string') {
	            out[i] = parser(paths[i], ext);
	        }
	
	        // is the path a path value with a string value.
	        else if (typeof paths[i].path === 'string') {
	            out[i] = {
	                path: parser(paths[i].path, ext), value: paths[i].value
	            };
	        }
	
	        // just copy it over.
	        else {
	            out[i] = paths[i];
	        }
	    }
	
	    return out;
	};
	
	// If the argument is a string, this with convert, else just return
	// the path provided.
	parser.fromPath = function(path, ext) {
	    if (!path) {
	        return [];
	    }
	
	    if (typeof path === 'string') {
	        return parser(path, ext);
	    }
	
	    return path;
	};
	
	// Potential routed tokens.
	parser.RoutedTokens = RoutedTokens;


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(475);
	var DOT_SEPARATOR = '.';
	var COMMA_SEPARATOR = ',';
	var OPENING_BRACKET = '[';
	var CLOSING_BRACKET = ']';
	var OPENING_BRACE = '{';
	var CLOSING_BRACE = '}';
	var COLON = ':';
	var ESCAPE = '\\';
	var DOUBLE_OUOTES = '"';
	var SINGE_OUOTES = "'";
	var SPACE = " ";
	var SPECIAL_CHARACTERS = '\\\'"[]., ';
	var EXT_SPECIAL_CHARACTERS = '\\{}\'"[]., :';
	
	var Tokenizer = module.exports = function(string, ext) {
	    this._string = string;
	    this._idx = -1;
	    this._extended = ext;
	    this.parseString = '';
	};
	
	Tokenizer.prototype = {
	    /**
	     * grabs the next token either from the peek operation or generates the
	     * next token.
	     */
	    next: function() {
	        var nextToken = this._nextToken ?
	            this._nextToken : getNext(this._string, this._idx, this._extended);
	
	        this._idx = nextToken.idx;
	        this._nextToken = false;
	        this.parseString += nextToken.token.token;
	
	        return nextToken.token;
	    },
	
	    /**
	     * will peak but not increment the tokenizer
	     */
	    peek: function() {
	        var nextToken = this._nextToken ?
	            this._nextToken : getNext(this._string, this._idx, this._extended);
	        this._nextToken = nextToken;
	
	        return nextToken.token;
	    }
	};
	
	Tokenizer.toNumber = function toNumber(x) {
	    if (!isNaN(+x)) {
	        return +x;
	    }
	    return NaN;
	};
	
	function toOutput(token, type, done) {
	    return {
	        token: token,
	        done: done,
	        type: type
	    };
	}
	
	function getNext(string, idx, ext) {
	    var output = false;
	    var token = '';
	    var specialChars = ext ?
	        EXT_SPECIAL_CHARACTERS : SPECIAL_CHARACTERS;
	    var done;
	
	    do {
	
	        done = idx + 1 >= string.length;
	        if (done) {
	            break;
	        }
	
	        // we have to peek at the next token
	        var character = string[idx + 1];
	
	        if (character !== undefined &&
	            specialChars.indexOf(character) === -1) {
	
	            token += character;
	            ++idx;
	            continue;
	        }
	
	        // The token to delimiting character transition.
	        else if (token.length) {
	            break;
	        }
	
	        ++idx;
	        var type;
	        switch (character) {
	            case DOT_SEPARATOR:
	                type = TokenTypes.dotSeparator;
	                break;
	            case COMMA_SEPARATOR:
	                type = TokenTypes.commaSeparator;
	                break;
	            case OPENING_BRACKET:
	                type = TokenTypes.openingBracket;
	                break;
	            case CLOSING_BRACKET:
	                type = TokenTypes.closingBracket;
	                break;
	            case OPENING_BRACE:
	                type = TokenTypes.openingBrace;
	                break;
	            case CLOSING_BRACE:
	                type = TokenTypes.closingBrace;
	                break;
	            case SPACE:
	                type = TokenTypes.space;
	                break;
	            case DOUBLE_OUOTES:
	            case SINGE_OUOTES:
	                type = TokenTypes.quote;
	                break;
	            case ESCAPE:
	                type = TokenTypes.escape;
	                break;
	            case COLON:
	                type = TokenTypes.colon;
	                break;
	            default:
	                type = TokenTypes.unknown;
	                break;
	        }
	        output = toOutput(character, type, false);
	        break;
	    } while (!done);
	
	    if (!output && token.length) {
	        output = toOutput(token, TokenTypes.token, false);
	    }
	
	    if (!output) {
	        output = {done: true};
	    }
	
	    return {
	        token: output,
	        idx: idx
	    };
	}
	
	


/***/ },
/* 475 */
/***/ function(module, exports) {

	var TokenTypes = {
	    token: 'token',
	    dotSeparator: '.',
	    commaSeparator: ',',
	    openingBracket: '[',
	    closingBracket: ']',
	    openingBrace: '{',
	    closingBrace: '}',
	    escape: '\\',
	    space: ' ',
	    colon: ':',
	    quote: 'quote',
	    unknown: 'unknown'
	};
	
	module.exports = TokenTypes;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(475);
	var E = __webpack_require__(477);
	var indexer = __webpack_require__(478);
	
	/**
	 * The top level of the parse tree.  This returns the generated path
	 * from the tokenizer.
	 */
	module.exports = function head(tokenizer) {
	    var token = tokenizer.next();
	    var state = {};
	    var out = [];
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	                var first = +token.token[0];
	                if (!isNaN(first)) {
	                    E.throwError(E.invalidIdentifier, tokenizer);
	                }
	                out[out.length] = token.token;
	                break;
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (out.length === 0) {
	                    E.throwError(E.unexpectedToken, tokenizer);
	                }
	                break;
	
	            // Spaces do nothing.
	            case TokenTypes.space:
	                // NOTE: Spaces at the top level are allowed.
	                // titlesById  .summary is a valid path.
	                break;
	
	
	            // Its time to decend the parse tree.
	            case TokenTypes.openingBracket:
	                indexer(tokenizer, token, state, out);
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	                break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (out.length === 0) {
	        E.throwError(E.invalidPath, tokenizer);
	    }
	
	    return out;
	};
	


/***/ },
/* 477 */
/***/ function(module, exports) {

	module.exports = {
	    indexer: {
	        nested: 'Indexers cannot be nested.',
	        needQuotes: 'unquoted indexers must be numeric.',
	        empty: 'cannot have empty indexers.',
	        leadingDot: 'Indexers cannot have leading dots.',
	        leadingComma: 'Indexers cannot have leading comma.',
	        requiresComma: 'Indexers require commas between indexer args.',
	        routedTokens: 'Only one token can be used per indexer when specifying routed tokens.'
	    },
	    range: {
	        precedingNaN: 'ranges must be preceded by numbers.',
	        suceedingNaN: 'ranges must be suceeded by numbers.'
	    },
	    routed: {
	        invalid: 'Invalid routed token.  only integers|ranges|keys are supported.'
	    },
	    quote: {
	        empty: 'cannot have empty quoted keys.',
	        illegalEscape: 'Invalid escape character.  Only quotes are escapable.'
	    },
	    unexpectedToken: 'Unexpected token.',
	    invalidIdentifier: 'Invalid Identifier.',
	    invalidPath: 'Please provide a valid path.',
	    throwError: function(err, tokenizer, token) {
	        if (token) {
	            throw err + ' -- ' + tokenizer.parseString + ' with next token: ' + token;
	        }
	        throw err + ' -- ' + tokenizer.parseString;
	    }
	};
	


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(475);
	var E = __webpack_require__(477);
	var idxE = E.indexer;
	var range = __webpack_require__(479);
	var quote = __webpack_require__(480);
	var routed = __webpack_require__(481);
	
	/**
	 * The indexer is all the logic that happens in between
	 * the '[', opening bracket, and ']' closing bracket.
	 */
	module.exports = function indexer(tokenizer, openingToken, state, out) {
	    var token = tokenizer.next();
	    var done = false;
	    var allowedMaxLength = 1;
	    var routedIndexer = false;
	
	    // State variables
	    state.indexer = [];
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	            case TokenTypes.quote:
	
	                // ensures that token adders are properly delimited.
	                if (state.indexer.length === allowedMaxLength) {
	                    E.throwError(idxE.requiresComma, tokenizer);
	                }
	                break;
	        }
	
	        switch (token.type) {
	            // Extended syntax case
	            case TokenTypes.openingBrace:
	                routedIndexer = true;
	                routed(tokenizer, token, state, out);
	                break;
	
	
	            case TokenTypes.token:
	                var t = +token.token;
	                if (isNaN(t)) {
	                    E.throwError(idxE.needQuotes, tokenizer);
	                }
	                state.indexer[state.indexer.length] = t;
	                break;
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (!state.indexer.length) {
	                    E.throwError(idxE.leadingDot, tokenizer);
	                }
	                range(tokenizer, token, state, out);
	                break;
	
	            // Spaces do nothing.
	            case TokenTypes.space:
	                break;
	
	            case TokenTypes.closingBracket:
	                done = true;
	                break;
	
	
	            // The quotes require their own tree due to what can be in it.
	            case TokenTypes.quote:
	                quote(tokenizer, token, state, out);
	                break;
	
	
	            // Its time to decend the parse tree.
	            case TokenTypes.openingBracket:
	                E.throwError(idxE.nested, tokenizer);
	                break;
	
	            case TokenTypes.commaSeparator:
	                ++allowedMaxLength;
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	                break;
	        }
	
	        // If done, leave loop
	        if (done) {
	            break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (state.indexer.length === 0) {
	        E.throwError(idxE.empty, tokenizer);
	    }
	
	    if (state.indexer.length > 1 && routedIndexer) {
	        E.throwError(idxE.routedTokens, tokenizer);
	    }
	
	    // Remember, if an array of 1, keySets will be generated.
	    if (state.indexer.length === 1) {
	        state.indexer = state.indexer[0];
	    }
	
	    out[out.length] = state.indexer;
	
	    // Clean state.
	    state.indexer = undefined;
	};
	


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	var Tokenizer = __webpack_require__(474);
	var TokenTypes = __webpack_require__(475);
	var E = __webpack_require__(477);
	
	/**
	 * The indexer is all the logic that happens in between
	 * the '[', opening bracket, and ']' closing bracket.
	 */
	module.exports = function range(tokenizer, openingToken, state, out) {
	    var token = tokenizer.peek();
	    var dotCount = 1;
	    var done = false;
	    var inclusive = true;
	
	    // Grab the last token off the stack.  Must be an integer.
	    var idx = state.indexer.length - 1;
	    var from = Tokenizer.toNumber(state.indexer[idx]);
	    var to;
	
	    if (isNaN(from)) {
	        E.throwError(E.range.precedingNaN, tokenizer);
	    }
	
	    // Why is number checking so difficult in javascript.
	
	    while (!done && !token.done) {
	
	        switch (token.type) {
	
	            // dotSeparators at the top level have no meaning
	            case TokenTypes.dotSeparator:
	                if (dotCount === 3) {
	                    E.throwError(E.unexpectedToken, tokenizer);
	                }
	                ++dotCount;
	
	                if (dotCount === 3) {
	                    inclusive = false;
	                }
	                break;
	
	            case TokenTypes.token:
	                // move the tokenizer forward and save to.
	                to = Tokenizer.toNumber(tokenizer.next().token);
	
	                // throw potential error.
	                if (isNaN(to)) {
	                    E.throwError(E.range.suceedingNaN, tokenizer);
	                }
	
	                done = true;
	                break;
	
	            default:
	                done = true;
	                break;
	        }
	
	        // Keep cycling through the tokenizer.  But ranges have to peek
	        // before they go to the next token since there is no 'terminating'
	        // character.
	        if (!done) {
	            tokenizer.next();
	
	            // go to the next token without consuming.
	            token = tokenizer.peek();
	        }
	
	        // break and remove state information.
	        else {
	            break;
	        }
	    }
	
	    state.indexer[idx] = {from: from, to: inclusive ? to : to - 1};
	};
	


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(475);
	var E = __webpack_require__(477);
	var quoteE = E.quote;
	
	/**
	 * quote is all the parse tree in between quotes.  This includes the only
	 * escaping logic.
	 *
	 * parse-tree:
	 * <opening-quote>(.|(<escape><opening-quote>))*<opening-quote>
	 */
	module.exports = function quote(tokenizer, openingToken, state, out) {
	    var token = tokenizer.next();
	    var innerToken = '';
	    var openingQuote = openingToken.token;
	    var escaping = false;
	    var done = false;
	
	    while (!token.done) {
	
	        switch (token.type) {
	            case TokenTypes.token:
	            case TokenTypes.space:
	
	            case TokenTypes.dotSeparator:
	            case TokenTypes.commaSeparator:
	
	            case TokenTypes.openingBracket:
	            case TokenTypes.closingBracket:
	            case TokenTypes.openingBrace:
	            case TokenTypes.closingBrace:
	                if (escaping) {
	                    E.throwError(quoteE.illegalEscape, tokenizer);
	                }
	
	                innerToken += token.token;
	                break;
	
	
	            case TokenTypes.quote:
	                // the simple case.  We are escaping
	                if (escaping) {
	                    innerToken += token.token;
	                    escaping = false;
	                }
	
	                // its not a quote that is the opening quote
	                else if (token.token !== openingQuote) {
	                    innerToken += token.token;
	                }
	
	                // last thing left.  Its a quote that is the opening quote
	                // therefore we must produce the inner token of the indexer.
	                else {
	                    done = true;
	                }
	
	                break;
	            case TokenTypes.escape:
	                escaping = true;
	                break;
	
	            default:
	                E.throwError(E.unexpectedToken, tokenizer);
	        }
	
	        // If done, leave loop
	        if (done) {
	            break;
	        }
	
	        // Keep cycling through the tokenizer.
	        token = tokenizer.next();
	    }
	
	    if (innerToken.length === 0) {
	        E.throwError(quoteE.empty, tokenizer);
	    }
	
	    state.indexer[state.indexer.length] = innerToken;
	};
	


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	var TokenTypes = __webpack_require__(475);
	var RoutedTokens = __webpack_require__(482);
	var E = __webpack_require__(477);
	var routedE = E.routed;
	
	/**
	 * The routing logic.
	 *
	 * parse-tree:
	 * <opening-brace><routed-token>(:<token>)<closing-brace>
	 */
	module.exports = function routed(tokenizer, openingToken, state, out) {
	    var routeToken = tokenizer.next();
	    var named = false;
	    var name = '';
	
	    // ensure the routed token is a valid ident.
	    switch (routeToken.token) {
	        case RoutedTokens.integers:
	        case RoutedTokens.ranges:
	        case RoutedTokens.keys:
	            //valid
	            break;
	        default:
	            E.throwError(routedE.invalid, tokenizer);
	            break;
	    }
	
	    // Now its time for colon or ending brace.
	    var next = tokenizer.next();
	
	    // we are parsing a named identifier.
	    if (next.type === TokenTypes.colon) {
	        named = true;
	
	        // Get the token name.
	        next = tokenizer.next();
	        if (next.type !== TokenTypes.token) {
	            E.throwError(routedE.invalid, tokenizer);
	        }
	        name = next.token;
	
	        // move to the closing brace.
	        next = tokenizer.next();
	    }
	
	    // must close with a brace.
	
	    if (next.type === TokenTypes.closingBrace) {
	        var outputToken = {
	            type: routeToken.token,
	            named: named,
	            name: name
	        };
	        state.indexer[state.indexer.length] = outputToken;
	    }
	
	    // closing brace expected
	    else {
	        E.throwError(routedE.invalid, tokenizer);
	    }
	
	};
	


/***/ },
/* 482 */
/***/ function(module, exports) {

	module.exports = {
	    integers: 'integers',
	    ranges: 'ranges',
	    keys: 'keys'
	};


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Controls = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _lodash = __webpack_require__(458);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx hJSX */
	
	
	var Controls = exports.Controls = function (_Component) {
	    _inherits(Controls, _Component);
	
	    function Controls() {
	        _classCallCheck(this, Controls);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(Controls).apply(this, arguments));
	    }
	
	    _createClass(Controls, [{
	        key: 'loader',
	        value: function loader(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return model.getItems(function getControlsPaths() {
	                return [['length']];
	            }, function getTaskPaths(_ref3) {
	                var length = _ref3.json.length;
	
	                return length === 0 ? [['filter']] : [['filter'], [{ length: length }, 'completed']];
	            });
	        }
	    }, {
	        key: 'events',
	        value: function events(_ref4) {
	            var _ref5 = _slicedToArray(_ref4, 2);
	
	            var model = _ref5[0];
	            var state = _ref5[1];
	
	            return this.listen('clear').switchMap(function (ev) {
	                return model.call('completed.remove');
	            }, function (ev, _ref6) {
	                var json = _ref6.json;
	                return _extends({}, state, json);
	            }).map(function (newState) {
	                return [model, state = newState];
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render(_ref7) {
	            var _ref8 = _slicedToArray(_ref7, 2);
	
	            var model = _ref8[0];
	            var state = _ref8[1];
	            var length = state.length;
	
	
	            if (length === 0) {
	                return;
	            }
	
	            var filter = state.filter;
	
	            var done = (0, _lodash2.default)(state, function (_ref9) {
	                var completed = _ref9.completed;
	                return completed;
	            }).length;
	            var open = length - done;
	            var suffix = open === 1 ? 'item left' : 'items left';
	
	            var children = [(0, _.hJSX)(
	                'span',
	                { 'class': { 'todo-count': true } },
	                (0, _.hJSX)(
	                    'strong',
	                    null,
	                    open
	                ),
	                ' ',
	                suffix
	            ), (0, _.hJSX)(
	                'ul',
	                { 'class': { 'filters': true } },
	                (0, _.hJSX)(
	                    'li',
	                    null,
	                    (0, _.hJSX)(
	                        'a',
	                        { 'class-selected': filter === 'all', href: '#/' },
	                        'All'
	                    )
	                ),
	                (0, _.hJSX)(
	                    'li',
	                    null,
	                    (0, _.hJSX)(
	                        'a',
	                        { 'class-selected': filter === 'active', href: '#/active' },
	                        'Active'
	                    )
	                ),
	                (0, _.hJSX)(
	                    'li',
	                    null,
	                    (0, _.hJSX)(
	                        'a',
	                        { 'class-selected': filter === 'completed', href: '#/completed' },
	                        'Completed'
	                    )
	                )
	            )];
	            if (done > 0) {
	                children.push((0, _.hJSX)(
	                    'button',
	                    { 'class': { 'clear-completed': true },
	                        'on-click': this.dispatch('clear') },
	                    'Clear completed'
	                ));
	            }
	            return (0, _.hJSX)(
	                'footer',
	                { 'class': { 'footer': true } },
	                children
	            );
	        }
	    }]);
	
	    return Controls;
	}(_.Component);

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TaskInput = undefined;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /** @jsx hJSX */
	
	
	var TaskInput = exports.TaskInput = function (_Component) {
	    _inherits(TaskInput, _Component);
	
	    function TaskInput() {
	        _classCallCheck(this, TaskInput);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(TaskInput).apply(this, arguments));
	    }
	
	    _createClass(TaskInput, [{
	        key: 'loader',
	        value: function loader(_ref) {
	            var _ref2 = _slicedToArray(_ref, 1);
	
	            var model = _ref2[0];
	
	            return model.get('value');
	        }
	    }, {
	        key: 'events',
	        value: function events(_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 2);
	
	            var model = _ref4[0];
	            var state = _ref4[1];
	
	
	            var entered = this.listen('keydown').filter(function (_ref5) {
	                var target = _ref5.target;
	                var keyIdentifier = _ref5.keyIdentifier;
	                return target.value && keyIdentifier === 'Enter';
	            });
	
	            return _Observable.Observable.merge(this.listen('input').debounceTime(250).takeUntil(entered).switchMap(function (ev) {
	                return model.set({ json: { value: ev.target.value } });
	            }, function (ev, _ref6) {
	                var json = _ref6.json;
	                return _extends({}, state, json);
	            }), entered.switchMap(function (ev) {
	                return model.call('add', [ev.target.value]);
	            }, function (ev) {
	                return { value: ev.target.value = '' };
	            })).map(function (newState) {
	                return [model, state = newState];
	            });
	        }
	    }, {
	        key: 'render',
	        value: function render(_ref7) {
	            var _ref8 = _slicedToArray(_ref7, 2);
	
	            var model = _ref8[0];
	            var value = _ref8[1].value;
	
	            return (0, _.hJSX)(
	                'header',
	                { 'class': { 'header': true } },
	                (0, _.hJSX)(
	                    'h1',
	                    null,
	                    'todos'
	                ),
	                (0, _.hJSX)('input', {
	                    'class': { 'new-todo': true },
	                    value: value,
	                    attrs: {
	                        autofocus: true,
	                        placeholder: 'What needs to be done?'
	                    },
	                    'on-input': this.dispatch('input'),
	                    'on-keydown': this.dispatch('keydown') })
	            );
	        }
	    }]);
	
	    return TaskInput;
	}(_.Component);

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.Routes = Routes;
	
	var _lodash = __webpack_require__(458);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _ = __webpack_require__(77);
	
	var _Observable = __webpack_require__(79);
	
	var _falcorJsonGraph = __webpack_require__(472);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function Routes() {
	    var cache = arguments.length <= 0 || arguments[0] === undefined ? {
	        apiVersion: 0,
	        globalTaskId: 0,
	        input: { value: '' },
	        tasks: { length: 0, filter: 'all' }
	    } : arguments[0];
	
	
	    var model = new _.Model({
	        cache: cache, // boxed: true,
	        materialized: true,
	        treatErrorsAsValues: true
	    });
	
	    return [].concat(apiVersionRoute(), globalTaskIdRoute(), removeTaskByIdRoute(), addTaskFromInputRoute(), getAndSetTasksKeyRoutes(), removeCompletedTasksRoute(), getAndSetTaskKeysByIdRoutes());
	
	    function apiVersionRoute() {
	        return {
	            route: 'apiVersion',
	            get: function get(pathSet) {
	                return model.get(pathSet)._toJSONG();
	            }
	        };
	    }
	
	    function globalTaskIdRoute() {
	        return {
	            route: 'globalTaskId',
	            get: function get(pathSet) {
	                return model.get(pathSet)._toJSONG();
	            }
	        };
	    }
	
	    function getAndSetTasksKeyRoutes() {
	        return [{
	            route: 'input.value',
	            get: function get(pathSet) {
	                return model.get(pathSet)._toJSONG();
	            },
	            set: function set(json) {
	                return model.set({ json: json })._toJSONG();
	            }
	        }, {
	            route: 'tasks[{keys:props}]',
	            get: function get(pathSet) {
	                return model.get(pathSet)._toJSONG();
	            },
	            set: function set(json) {
	                return model.set({ json: json })._toJSONG();
	            }
	        }];
	    }
	
	    function getAndSetTaskKeysByIdRoutes() {
	        return [{
	            route: 'tasksById[{keys:ids}][{keys:props}]',
	            get: function get(pathSet) {
	                return model.get(pathSet)._toJSONG();
	            },
	            set: function set(json) {
	                return model.set({ json: json })._toJSONG();
	            }
	        }, {
	            route: 'tasksById[{keys:ids}].toggle',
	            call: function call(_ref, _ref2) {
	                var ids = _ref.ids;
	
	                var _ref3 = _slicedToArray(_ref2, 1);
	
	                var bool = _ref3[0];
	
	
	                if (ids.length === 0) {
	                    return [];
	                }
	
	                return model.getValue('tasks.filter').flatMap(function (filter) {
	                    return model.set((0, _falcorJsonGraph.pathValue)(['tasksById', ids, 'completed'], bool))._toJSONG().map(function (_ref4) {
	                        var paths = _ref4.paths;
	                        var jsonGraph = _ref4.jsonGraph;
	
	                        paths.push(['tasks', 'filter']);
	                        jsonGraph.tasks = { filter: filter };
	                        return { paths: paths, jsonGraph: jsonGraph };
	                    });
	                });
	            }
	        }];
	    }
	
	    function addTaskFromInputRoute() {
	        return {
	            route: 'input.add',
	            call: function call(callPath, _ref5) {
	                var _ref6 = _slicedToArray(_ref5, 1);
	
	                var content = _ref6[0];
	
	                return model.get('globalTaskId', 'tasks.length').flatMap(function (_ref7) {
	                    var _ref7$json = _ref7.json;
	                    var globalTaskId = _ref7$json.globalTaskId;
	                    var length = _ref7$json.tasks.length;
	
	                    // debugger;
	                    var taskId = globalTaskId + 1;
	                    var taskRef = 'tasksById[\'' + taskId + '\']';
	                    var taskIndex = length;
	                    return model.set({ json: {
	                            globalTaskId: taskId,
	                            input: { value: '' },
	                            tasks: _defineProperty({
	                                length: length + 1
	                            }, taskIndex, (0, _falcorJsonGraph.ref)(taskRef)),
	                            tasksById: _defineProperty({}, taskId, {
	                                content: content,
	                                id: taskId,
	                                completed: false
	                            })
	                        } })._toJSONG();
	                });
	            }
	        };
	    }
	
	    function removeTaskByIdRoute() {
	        return {
	            route: 'tasksById[{keys:taskIds}].remove',
	            call: function call(_ref8) {
	                var taskIds = _ref8.taskIds;
	
	                taskIds = taskIds.map(String);
	                return model.getValue('tasks.length').mergeMap(function (length) {
	                    return length === 0 ? _Observable.Observable.empty() : model.get('tasks.length', 'tasks[0...' + length + '][\'id\']');
	                }).flatMap(function (_ref9) {
	                    var tasks = _ref9.json.tasks;
	
	
	                    var taskIndex = -1;
	                    var taskLen = tasks.length;
	                    var invalidated = [];
	                    var newTaskRefs = [];
	
	                    while (++taskIndex < taskLen) {
	                        var id = tasks[taskIndex].id;
	
	                        if (~taskIds.indexOf(String(id))) {
	                            invalidated.push((0, _falcorJsonGraph.pathInvalidation)('tasksById[\'' + id + '\']'));
	                        } else {
	                            newTaskRefs.push((0, _falcorJsonGraph.pathValue)('tasks[' + newTaskRefs.length + ']', (0, _falcorJsonGraph.ref)('tasksById[\'' + id + '\']')));
	                        }
	                        invalidated.push((0, _falcorJsonGraph.pathInvalidation)('tasks[\'' + taskIndex + '\']'));
	                    }
	
	                    newTaskRefs.push((0, _falcorJsonGraph.pathValue)('tasks.length', newTaskRefs.length));
	
	                    if (invalidated.length > 0) {
	                        model.invalidate.apply(model, _toConsumableArray(invalidated.map(function (_ref10) {
	                            var path = _ref10.path;
	                            return path;
	                        })));
	                    }
	
	                    return _Observable.Observable.from(invalidated).concat(model.set.apply(model, newTaskRefs)._toJSONG());
	                });
	            }
	        };
	    }
	
	    function removeCompletedTasksRoute() {
	        return {
	            route: 'tasks.completed.remove',
	            call: function call() {
	                return model.getValue('tasks.length').mergeMap(function (length) {
	                    return length === 0 ? _Observable.Observable.empty() : model.get('tasks.length', 'tasks[0...' + length + '][\'id\', \'completed\']');
	                }).flatMap(function (_ref11) {
	                    var tasks = _ref11.json.tasks;
	
	
	                    var taskIndex = -1;
	                    var taskLen = tasks.length;
	                    var invalidated = [];
	                    var newTaskRefs = [];
	
	                    while (++taskIndex < taskLen) {
	                        var _tasks$taskIndex = tasks[taskIndex];
	                        var id = _tasks$taskIndex.id;
	                        var completed = _tasks$taskIndex.completed;
	
	                        if (completed) {
	                            invalidated.push((0, _falcorJsonGraph.pathInvalidation)('tasksById[\'' + id + '\']'));
	                        } else {
	                            newTaskRefs.push((0, _falcorJsonGraph.pathValue)('tasks[' + newTaskRefs.length + ']', (0, _falcorJsonGraph.ref)('tasksById[\'' + id + '\']')));
	                        }
	                        invalidated.push((0, _falcorJsonGraph.pathInvalidation)('tasks[\'' + taskIndex + '\']'));
	                    }
	
	                    newTaskRefs.push((0, _falcorJsonGraph.pathValue)('tasks.length', newTaskRefs.length));
	
	                    if (invalidated.length > 0) {
	                        model.invalidate.apply(model, _toConsumableArray(invalidated.map(function (_ref12) {
	                            var path = _ref12.path;
	                            return path;
	                        })));
	                    }
	
	                    return _Observable.Observable.from(invalidated).concat(model.set.apply(model, newTaskRefs)._toJSONG());
	                });
	            }
	        };
	    }
	}

/***/ }
/******/ ]);
//# sourceMappingURL=index.js.map