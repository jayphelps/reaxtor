{"version":3,"sources":["../src/SparseArray.js"],"names":[],"mappings":"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","file":"SparseArray.js","sourcesContent":["SparseArray.prototype.getLength = getLength;\nSparseArray.prototype.setLength = setLength;\nSparseArray.prototype.getDefaultSize = getDefaultSize;\nSparseArray.prototype.setDefaultSize = setDefaultSize;\nSparseArray.prototype.getAxisOffset = getAxisOffset;\nSparseArray.prototype.setAxisOffset = setAxisOffset;\nSparseArray.prototype.getGap = getGap;\nSparseArray.prototype.setGap = setGap;\nSparseArray.prototype.getItemSize = getItemSize;\nSparseArray.prototype.setItemSize = setItemSize;\nSparseArray.prototype.insert = insert;\nSparseArray.prototype.remove = remove;\nSparseArray.prototype.start = start;\nSparseArray.prototype.end = end;\nSparseArray.prototype.indexOf = indexOf;\nSparseArray.prototype.clear = clear;\nSparseArray.prototype.toString = toString;\n\n/**\n * A sparse array of sizes that represent items in a dimension.\n *\n * Provides efficient support for finding the cumulative distance to\n * the start/end of an item along the axis, and similarly for finding the\n * index of the item at a particular distance.\n *\n * Default size is used for items whose size hasn't been specified.\n */\nfunction SparseArray(block_size) {\n\n    if(block_size === undefined) {\n        block_size = 128;\n    }\n\n    // Assumption: vector elements (sizes) will typically be set in\n    // small ranges that reflect localized scrolling.  Allocate vector\n    // elements in blocks of block_size, which must be a power of 2.\n    // block_shift is the power of 2 and block_mask masks off as many\n    // low order bits.  The block_table contains all of the allocated\n    // blocks and has length/block_size elements which are allocated lazily.\n    var pow = (Math.log(block_size) / Math.log(2)) | 0,\n        size = Math.pow(2, pow),\n        mask = size - 1;\n\n    this.block_size  = size;\n    this.block_shift = pow;\n    this.block_mask  = mask;\n    this.block_table = [];\n\n    this._defaultSize = 0;\n    this._axisOffset = 0;\n    this._gap = 0;\n\n    // Sorted Vector of intervals for the pending removes, in descending order,\n    // for example [7, 5, 3, 1] for the removes at 7, 6, 5, 3, 2, 1\n    this.removes = null;\n    // Sorted Vector of intervals for the pending inserts, in ascending order,\n    // for example [1, 3, 5, 7] for the inserts at 1, 2, 3, 5, 6, 7\n    this.inserts = null;\n\n    this._length = 0;\n    // What the length will be after any pending changes are flushed.\n    this._pendingLength = -1;\n}\n\n/**\n * The number of item size valued elements.\n *\n * @default 0\n */\nfunction getLength() {\n    return this._pendingLength === -1 ? this._length : this._pendingLength;\n}\n\n/**\n * @private\n * Grows or truncates the vector to be the specified newLength.\n * When truncating, releases empty blocks and sets to NaN any values\n * in the last block beyond the newLength.\n */\nfunction setLength(newLength) {\n    flushPendingChanges.call(this);\n\n    if(newLength < this._length) {\n        // Clear any remaining non-NaN values in the last block\n        var blockIndex = newLength >> this.block_shift;\n        var endIndex = Math.min(blockIndex * this.block_size + this.block_size, this._length) - 1;\n        clearInterval.call(this, newLength, endIndex);\n    }\n\n    this._length = newLength;\n\n    // update the table\n    var partialBlock = ((this._length & this.block_mask) === 0) ? 0 : 1;\n    this.block_table.length = (this._length >> this.block_shift) + partialBlock;\n}\n\n//----------------------------------\n//  defaultSize\n//----------------------------------\n\n/**\n * The size of items whose size was not specified with setItemSize.\n *\n * @default 0\n */\nfunction getDefaultSize() {\n    return this._defaultSize;\n}\n\n/**\n * @private\n */\nfunction setDefaultSize(value) {\n    this._defaultSize = value;\n}\n\n//----------------------------------\n//  axisOffset\n//----------------------------------\n\n/**\n * The offset of the first item from the origin in the majorAxis\n * direction. This is useful when implementing padding,\n * in addition to gaps, for virtual layouts.\n *\n * @see #gap\n */\nfunction getAxisOffset() {\n    return this._axisOffset;\n}\n\n/**\n * @private\n */\nfunction setAxisOffset(value) {\n    this._axisOffset = value;\n}\n\n//----------------------------------\n//  gap\n//----------------------------------\n\n/**\n * The distance between items.\n *\n * @default 0\n */\nfunction getGap() {\n    return this._gap;\n}\n\n/**\n * @private\n */\nfunction setGap(value) {\n    this._gap = value;\n}\n\n//--------------------------------------------------------------------------\n//\n//  Methods\n//\n//--------------------------------------------------------------------------\n\n/**\n * Return the size of the item at index.  If no size was ever\n * specified then then the defaultSize is returned.\n *\n * @param index The item's index.\n * @see defaultSize\n */\nfunction getItemSize(index) {\n    flushPendingChanges.call(this);\n\n    var block = this.block_table[index >> this.block_shift];\n    if(block) {\n        var value = block.sizes[index & this.block_mask];\n        return (value !== value) ? this._defaultSize : value;\n    } else {\n        return this._defaultSize;\n    }\n}\n\n/**\n * Set the size of the item at index. If an index is\n * set to <code>NaN</code> then subsequent calls to get\n * will return the defaultSize.\n *\n * @param index The item's index.\n * @param value The item's size.\n * @see defaultSize\n */\nfunction setItemSize(index, value) {\n    flushPendingChanges.call(this);\n\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var blockIndex = index >> this.block_shift;\n    var block = this.block_table[blockIndex];\n    if(!block) {\n        block = this.block_table[blockIndex] = new Block(this.block_size);\n    }\n\n    var sizesIndex = index & this.block_mask;\n    var sizes = block.sizes;\n    var oldValue = sizes[sizesIndex];\n    if(oldValue === value) {\n        return;\n    }\n\n    if(oldValue !== oldValue) {\n        block.defaultCount -= 1;\n        block.sizesSum += value;\n    } else if(value !== value) {\n        block.defaultCount += 1;\n        block.sizesSum -= oldValue;\n    } else {\n        block.sizesSum += value - oldValue;\n    }\n\n    sizes[sizesIndex] = value;\n}\n\n/**\n * Make room for a new item at index by shifting all of the sizes\n * one position to the right, beginning with startIndex.\n *\n * The value at index will be NaN.\n *\n * This is similar to array.splice(index, 0, NaN).\n *\n * @param index The position of the new NaN size item.\n */\nfunction insert(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.removes) {\n        flushPendingChanges.call(this);\n    }\n\n    if(this.inserts) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.inserts.length - 1;\n        var intervalEnd = this.inserts[lastIndex];\n\n        if(index === intervalEnd + 1) {\n            // Extend the end of the interval\n            this.inserts[lastIndex] = index;\n        } else if(index > intervalEnd) {\n            // New interval\n            this.inserts.push(index);\n            this.inserts.push(index);\n        } else {\n            // We can't support pending inserts that are not ascending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = Math.max(this._length, index + 1);\n\n    if(!this.inserts) {\n        this.inserts = [];\n        this.inserts.push(index);\n        this.inserts.push(index);\n    }\n}\n\n/**\n * Remove index by shifting all of the sizes one position to the left,\n * begining with index+1.\n *\n * This is similar to array.splice(index, 1).\n *\n * @param index The position to be removed.\n */\nfunction remove(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.inserts) {\n        flushPendingChanges.call(this);\n    }\n\n    // length getter takes into account pending inserts/removes but doesn't flush\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    if(this.removes) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.removes.length - 1;\n        var intervalStart = this.removes[lastIndex];\n\n        if(index === intervalStart - 1) {\n            // Extend the start of the interval\n            this.removes[lastIndex] = index;\n        } else if(index < intervalStart) {\n            // New interval\n            this.removes.push(index);\n            this.removes.push(index);\n        } else {\n            // We can't support pending removes that are not descending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = (this._pendingLength === -1) ? length - 1 : this._pendingLength - 1;\n\n    if(!this.removes) {\n        this.removes = [];\n        this.removes.push(index);\n        this.removes.push(index);\n    }\n}\n\n/**\n * @private\n * Returns true when all sizes in the specified interval for the block are NaN\n */\nfunction isIntervalClear(block, index, count) {\n    var sizes = block.sizes, size;\n    for(count += index; index < count; ++index) {\n        if((size = sizes[index]) === size) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @private\n * Copies elements between blocks. Indices relative to the blocks.\n * If srcBlock is null, then it fills the destination with NaNs.\n * The case of srcBlock === dstBlock is also supported.\n * The caller must ensure that count is within range.\n */\nfunction inBlockCopy(dstBlock, dstIndexStart, srcBlock, srcIndexStart, count) {\n    var ascending = dstIndexStart < srcIndexStart;\n\n    var srcIndex = ascending ? srcIndexStart : srcIndexStart + count - 1;\n    var dstIndex = ascending ? dstIndexStart : dstIndexStart + count - 1;\n    var increment = ascending ? +1 : -1;\n\n    var dstSizes = dstBlock.sizes;\n    var srcSizes = srcBlock ? srcBlock.sizes : null;\n    var dstValue = NaN;\n    var srcValue = NaN;\n    var sizesSumDelta = 0; // How much the destination sizesSum will change\n    var defaultCountDelta = 0; // How much the destination defaultCount will change\n\n    while(count > 0) {\n        if(srcSizes) {\n            srcValue = srcSizes[srcIndex];\n        }\n\n        dstValue = dstSizes[dstIndex];\n\n        // Are the values different?\n        if(srcValue !== dstValue) { // Triple '=' to handle NaN comparison\n\n            // Are we removing a default size or a chached size?\n            if(dstValue !== dstValue) {\n                defaultCountDelta--;\n            } else {\n                sizesSumDelta -= dstValue;\n            }\n\n            // Are we adding a default size or a cached size?\n            if(srcValue !== srcValue) {\n                defaultCountDelta++;\n            } else {\n                sizesSumDelta += srcValue;\n            }\n\n            dstSizes[dstIndex] = srcValue;\n        }\n\n        srcIndex += increment;\n        dstIndex += increment;\n        count--;\n    }\n\n    dstBlock.sizesSum += sizesSumDelta;\n    dstBlock.defaultCount += defaultCountDelta;\n}\n\n/**\n * @private\n * Copies 'count' elements from dstIndex to srcIndex.\n * Safe for overlapping source and destination intervals.\n * If any blocks are left full of NaNs, they will be deallcated.\n */\nfunction copyInterval(dstIndex, srcIndex, count) {\n    var ascending = dstIndex < srcIndex;\n    if(!ascending) {\n        dstIndex += count - 1;\n        srcIndex += count - 1;\n    }\n\n    while(count > 0) {\n        // Figure out destination block\n        var dstBlockIndex = dstIndex >> this.block_shift;\n        var dstSizesIndex = dstIndex & this.block_mask;\n        var dstBlock = this.block_table[dstBlockIndex];\n\n        // Figure out source block\n        var srcBlockIndex = srcIndex >> this.block_shift;\n        var srcSizesIndex = srcIndex & this.block_mask;\n        var srcBlock = this.block_table[srcBlockIndex];\n\n        // Figure out number of elements to copy\n        var copyCount = ascending ?\n            Math.min(this.block_size - dstSizesIndex, this.block_size - srcSizesIndex) :\n            1 + Math.min(dstSizesIndex, srcSizesIndex);\n\n        copyCount = Math.min(copyCount, count);\n\n        // Figure out the start index for each block\n        var dstStartIndex = ascending ? dstSizesIndex : dstSizesIndex - copyCount + 1;\n        var srcStartIndex = ascending ? srcSizesIndex : srcSizesIndex - copyCount + 1;\n\n        // Check whether a destination block needs to be allocated.\n        // Allocate only if there are non-default values to be copied from the source.\n        if(srcBlock && !dstBlock && isIntervalClear(srcBlock, srcStartIndex, copyCount)) {\n            dstBlock = new Block(this.block_size);\n            this.block_table[dstBlockIndex] = dstBlock;\n        }\n\n        // Copy to non-null dstBlock, srcBlock can be null\n        if(dstBlock) {\n            inBlockCopy(dstBlock, dstStartIndex, srcBlock, srcStartIndex, copyCount);\n\n            // If this is the last time we're visiting this block, and it contains\n            // only NaNs, then remove it\n            if(dstBlock.defaultCount === this.block_size) {\n                var blockEndReached = ascending ?\n                    (dstStartIndex + copyCount === this.block_size) :\n                    (dstStartIndex === 0);\n                if(blockEndReached || count === copyCount)\n                    this.block_table[dstBlockIndex] = null;\n            }\n        }\n\n        dstIndex += ascending ? copyCount : -copyCount;\n        srcIndex += ascending ? copyCount : -copyCount;\n        count -= copyCount;\n    }\n}\n\n/**\n * @private\n * Sets all elements within the specified interval to NaN (both ends inclusive).\n * Releases empty blocks.\n */\nfunction clearInterval(start, end) {\n    while(start <= end) {\n        // Figure our destination block\n        var blockIndex = start >> this.block_shift;\n        var sizesIndex = start & this.block_mask;\n        var block = this.block_table[blockIndex];\n\n        // Figure out number of elements to clear in this iteration\n        // Make sure we don't clear more items than requested\n        var clearCount = this.block_size - sizesIndex;\n        clearCount = Math.min(clearCount, end - start + 1);\n\n        if(block) {\n            if(clearCount === this.block_size) {\n                this.block_table[blockIndex] = null;\n            } else {\n                // Copying from null source block is equivalent of clearing the destination block\n                inBlockCopy(block, sizesIndex, null /*srcBlock*/, 0, clearCount);\n\n                // If the blockDst contains only default sizes, then remove the block\n                if(block.defaultCount === this.block_size) {\n                    this.block_table[blockIndex] = null;\n                }\n            }\n        }\n\n        start += clearCount;\n    }\n}\n\n/**\n * @private\n * Removes the elements designated by the intervals and truncates\n * the LinearLayoutVector to the new length.\n * 'intervals' is a Vector of descending intervals [7, 5, 3, 1]\n */\nfunction removeIntervals(intervals) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Adding final nextIntervalStart value (see below).\n    intervals.reverse(); // turn into ascending, for example [7, 5, 3, 1] --> [1, 3, 5, 7]\n    intervals.push(this.getLength());\n\n    // Move the elements\n    var dstStart = intervals[0];\n    var srcStart;\n    var count;\n    var i = 0;\n    do {\n        var intervalEnd = intervals[i + 1];\n        var nextIntervalStart = intervals[i + 2]\n        i += 2;\n\n        // Start copy from after the end of current interval\n        srcStart = intervalEnd + 1;\n\n        // copy all elements up to the start of the next interval.\n        count = nextIntervalStart - srcStart;\n\n        copyInterval.call(this, dstStart, srcStart, count);\n        dstStart += count;\n    } while(i < intervalsCount)\n\n    // Truncate the excess elements.\n    this.setLength(dstStart);\n}\n\n/**\n * @private\n * Increases the length and inserts NaN values for the elements designated by the intervals.\n * 'intervals' is a Vector of ascending intervals [1, 3, 5, 7]\n */\nfunction insertIntervals(intervals, newLength) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Allocate enough space for the insertions, all the elements\n    // allocated are NaN by default.\n    var oldLength = this.getLength();\n    this.setLength(newLength);\n\n    var srcEnd = oldLength - 1;\n    var dstEnd = newLength - 1;\n    var i = intervalsCount - 2;\n    while(i >= 0) {\n        // Find current interval\n        var intervalStart = intervals[i];\n        var intervalEnd = intervals[i + 1];\n        i -= 2;\n\n        // Start after the current interval\n        var dstStart = intervalEnd + 1;\n        var copyCount = dstEnd - dstStart + 1;\n        var srcStart = srcEnd - copyCount + 1;\n\n        copyInterval.call(this, dstStart, srcStart, copyCount);\n        dstStart -= copyCount;\n        dstEnd = intervalStart - 1;\n\n        // Fill in with default NaN values after the copy\n        clearInterval.call(this, intervalStart, intervalEnd);\n    }\n}\n\n/**\n * @private\n * Processes any pending removes or pending inserts.\n */\nfunction flushPendingChanges() {\n    var intervals;\n    if(this.removes) {\n        intervals = this.removes;\n        this.removes = null;\n        this._pendingLength = -1;\n        removeIntervals.call(this, intervals);\n    } else if(this.inserts) {\n        intervals = this.inserts;\n        var newLength = this._pendingLength;\n        this.inserts = null;\n        this._pendingLength = -1;\n        insertIntervals.call(this, intervals, newLength);\n    }\n}\n\n/**\n * The cumulative distance to the start of the item at index, including\n * the gaps between items and the axisOffset.\n *\n * The value of start(0) is axisOffset.\n *\n * Equivalent to:\n * <pre>\n * var distance = this.getAxisOffset();\n * for (var i = 0; i &lt; index; i++)\n *     distance += get(i);\n * return distance + (gap * index);\n * </pre>\n *\n * The actual implementation is relatively efficient.\n *\n * @param index The item's index.\n * @see #end\n */\nfunction start(index) {\n\n    flushPendingChanges.call(this);\n\n    if((this._length === 0) || (index === 0)) {\n        return this.getAxisOffset();\n    }\n\n    if(index >= this._length) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var distance = this.getAxisOffset();\n    var blockIndex = index >> this.block_shift;\n    for(var i = 0; i < blockIndex; i++)\n    {\n        var block = this.block_table[i];\n        distance += block ?\n            block.sizesSum + (block.defaultCount * this._defaultSize) :\n            this.block_size * this._defaultSize;\n    }\n    var lastBlock = this.block_table[blockIndex];\n    var lastBlockOffset = index & ~this.block_mask;\n    var lastBlockLength = index - lastBlockOffset;\n    if(lastBlock) {\n        var sizes = lastBlock.sizes;\n        for(i = 0; i < lastBlockLength; i++) {\n            var size = sizes[i];\n            distance += (size !== size) ? this._defaultSize : size;\n        }\n    } else {\n        distance += this._defaultSize * lastBlockLength;\n    }\n    distance += index * this.getGap();\n    return distance;\n}\n\n/**\n * The cumulative distance to the end of the item at index, including\n * the gaps between items.\n *\n * If <code>index &lt;(length-1)</code> then the value of this\n * function is defined as:\n * <code>start(index) + get(index)</code>.\n *\n * @param index The item's index.\n * @see #start\n */\nfunction end(index) {\n    flushPendingChanges.call(this);\n    return this.start(index) + this.getItemSize(index);\n}\n\n/**\n * Returns the index of the item that overlaps the specified distance.\n *\n * The item at index <code>i</code> overlaps a distance value\n * if <code>start(i) &lt;= distance &lt; end(i)</code>.\n *\n * If no such item exists, -1 is returned.\n */\nfunction indexOf(distance) {\n    flushPendingChanges.call(this);\n    var index = indexOfInternal.call(this, distance);\n    return (index >= this._length) ? -1 : index;\n}\n\nfunction indexOfInternal(distance) {\n\n    if((this._length === 0) || (distance < 0)) {\n        return -1;\n    }\n\n    // The area of the first item includes the axisOffset\n    var curDistance = this.getAxisOffset();\n\n    if(distance < curDistance) {\n        return 0;\n    }\n\n    var index = -1,\n        block = null,\n        blockSize = this.block_size,\n        defaultSize = this._defaultSize,\n        gap = this.getGap(),\n        blockGap = gap * blockSize;\n\n    // Find the block that contains distance and the index of its\n    // first element\n    var blockIndex = -1,\n        blockTable = this.block_table,\n        blockTableLength = blockTable.length;\n\n    for(; ++blockIndex < blockTableLength;) {\n        block = blockTable[blockIndex];\n        var blockDistance = blockGap + (\n            block ?\n                block.sizesSum + (block.defaultCount * defaultSize) :\n                blockSize * defaultSize\n        );\n\n        if((distance === curDistance) || ((distance >= curDistance) && (distance < (curDistance + blockDistance)))) {\n            index = blockIndex << this.block_shift;\n            break;\n        }\n        curDistance += blockDistance;\n    }\n\n    if((index === -1) || (distance === curDistance)) {\n        return index;\n    }\n\n    // At this point index corresponds to the first item in this block\n    if(block) {\n        // Find the item that contains distance and return its index\n        var sizes = block.sizes,\n            n = this.block_size - 1;\n        for(var i = 0; i < n; i++) {\n            var size = sizes[i];\n            curDistance += gap + (size !== size ? this._defaultSize : size);\n            if(curDistance > distance) {\n                return index + i;\n            }\n        }\n        // TBD special-case for the very last index\n        return index + this.block_size - 1;\n    } else {\n        return index + Math.floor(Number(distance - curDistance) / Number(this._defaultSize + gap));\n    }\n}\n\n/**\n * Clear all cached state, reset length to zero.\n */\nfunction clear() {\n    // Discard any pending changes, before setting the length\n    // otherwise the length setter will commit the changes.\n    this.removes = null;\n    this.inserts = null;\n    this._pendingLength = -1;\n\n    this.setLength(0); // clears the this.block_table as well\n}\n\nfunction toString() {\n    return \"SparseArray {\" +\n        \"length: \" + this._length + \", \" +\n        \"size: \" + this.end(this.getLength() -1) + \", \" +\n        \"[blocks: \" + this.block_table.length + \"]\" + \", \" +\n        \"gap: \" + this._gap + \", \" +\n        \"defaultSize: \" + this._defaultSize + \", \" +\n        \"pendingRemoves: \" + (this.removes ? this.removes.length : 0) + \", \" +\n        \"pendingInserts: \" + (this.inserts ? this.inserts.length : 0) +\n        \"}\";\n}\n\n/**\n * @private\n * A SparseArray block of layout element heights or widths.\n *\n * Total \"distance\" for a Block is: sizesSum + (defaultCount * distanceVector.default).\n */\nfunction Block(block_size) {\n\n    this.sizes = new Array(block_size);\n    this.sizesSum = 0;\n    this.defaultCount = block_size;\n\n    for(var i = -1; ++i < block_size;) {\n        this.sizes[i] = NaN;\n    }\n}\n\nexport { SparseArray };\n"]}