{"version":3,"sources":["../src/SparseArray.js"],"names":[],"mappings":"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","file":"SparseArray.js","sourcesContent":["SparseArray.prototype.getLength = getLength;\nSparseArray.prototype.setLength = setLength;\nSparseArray.prototype.getDefaultSize = getDefaultSize;\nSparseArray.prototype.setDefaultSize = setDefaultSize;\nSparseArray.prototype.getAxisOffset = getAxisOffset;\nSparseArray.prototype.setAxisOffset = setAxisOffset;\nSparseArray.prototype.getGap = getGap;\nSparseArray.prototype.setGap = setGap;\nSparseArray.prototype.getItemSize = getItemSize;\nSparseArray.prototype.setItemSize = setItemSize;\nSparseArray.prototype.insert = insert;\nSparseArray.prototype.remove = remove;\nSparseArray.prototype.start = start;\nSparseArray.prototype.end = end;\nSparseArray.prototype.indexOf = indexOf;\nSparseArray.prototype.clear = clear;\nSparseArray.prototype.toString = toString;\n\n/**\n * A sparse array of sizes that represent items in a dimension.\n *\n * Provides efficient support for finding the cumulative distance to\n * the start/end of an item along the axis, and similarly for finding the\n * index of the item at a particular distance.\n *\n * Default size is used for items whose size hasn't been specified.\n */\nfunction SparseArray(block_size) {\n\n    if(block_size === undefined) {\n        block_size = 128;\n    }\n\n    // Assumption: vector elements (sizes) will typically be set in\n    // small ranges that reflect localized scrolling.  Allocate vector\n    // elements in blocks of block_size, which must be a power of 2.\n    // block_shift is the power of 2 and block_mask masks off as many\n    // low order bits.  The block_table contains all of the allocated\n    // blocks and has length/block_size elements which are allocated lazily.\n    var pow = (Math.log(block_size) / Math.log(2)) | 0,\n        size = Math.pow(2, pow),\n        mask = size - 1;\n\n    this.block_size  = size;\n    this.block_shift = pow;\n    this.block_mask  = mask;\n    this.block_table = [];\n\n    this._defaultSize = 0;\n    this._axisOffset = 0;\n    this._gap = 0;\n\n    // Sorted Vector of intervals for the pending removes, in descending order,\n    // for example [7, 5, 3, 1] for the removes at 7, 6, 5, 3, 2, 1\n    this.removes = null;\n    // Sorted Vector of intervals for the pending inserts, in ascending order,\n    // for example [1, 3, 5, 7] for the inserts at 1, 2, 3, 5, 6, 7\n    this.inserts = null;\n\n    this._length = 0;\n    // What the length will be after any pending changes are flushed.\n    this._pendingLength = -1;\n}\n\n/**\n * The number of item size valued elements.\n *\n * @default 0\n */\nfunction getLength() {\n    return this._pendingLength === -1 ? this._length : this._pendingLength;\n}\n\n/**\n * @private\n * Grows or truncates the vector to be the specified newLength.\n * When truncating, releases empty blocks and sets to NaN any values\n * in the last block beyond the newLength.\n */\nfunction setLength(newLength) {\n    flushPendingChanges.call(this);\n\n    if(newLength < this._length) {\n        // Clear any remaining non-NaN values in the last block\n        var blockIndex = newLength >> this.block_shift;\n        var endIndex = Math.min(blockIndex * this.block_size + this.block_size, this._length) - 1;\n        clearInterval.call(this, newLength, endIndex);\n    }\n\n    this._length = newLength;\n\n    // update the table\n    var partialBlock = ((this._length & this.block_mask) === 0) ? 0 : 1;\n    this.block_table.length = (this._length >> this.block_shift) + partialBlock;\n}\n\n//----------------------------------\n//  defaultSize\n//----------------------------------\n\n/**\n * The size of items whose size was not specified with setItemSize.\n *\n * @default 0\n */\nfunction getDefaultSize() {\n    return this._defaultSize;\n}\n\n/**\n * @private\n */\nfunction setDefaultSize(value) {\n    this._defaultSize = value;\n}\n\n//----------------------------------\n//  axisOffset\n//----------------------------------\n\n/**\n * The offset of the first item from the origin in the majorAxis\n * direction. This is useful when implementing padding,\n * in addition to gaps, for virtual layouts.\n *\n * @see #gap\n */\nfunction getAxisOffset() {\n    return this._axisOffset;\n}\n\n/**\n * @private\n */\nfunction setAxisOffset(value) {\n    this._axisOffset = value;\n}\n\n//----------------------------------\n//  gap\n//----------------------------------\n\n/**\n * The distance between items.\n *\n * @default 0\n */\nfunction getGap() {\n    return this._gap;\n}\n\n/**\n * @private\n */\nfunction setGap(value) {\n    this._gap = value;\n}\n\n//--------------------------------------------------------------------------\n//\n//  Methods\n//\n//--------------------------------------------------------------------------\n\n/**\n * Return the size of the item at index.  If no size was ever\n * specified then then the defaultSize is returned.\n *\n * @param index The item's index.\n * @see defaultSize\n */\nfunction getItemSize(index) {\n    flushPendingChanges.call(this);\n\n    var block = this.block_table[index >> this.block_shift];\n    if(block) {\n        var value = block.sizes[index & this.block_mask];\n        return (value !== value) ? this._defaultSize : value;\n    } else {\n        return this._defaultSize;\n    }\n}\n\n/**\n * Set the size of the item at index. If an index is\n * set to <code>NaN</code> then subsequent calls to get\n * will return the defaultSize.\n *\n * @param index The item's index.\n * @param value The item's size.\n * @see defaultSize\n */\nfunction setItemSize(index, value) {\n    flushPendingChanges.call(this);\n\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var blockIndex = index >> this.block_shift;\n    var block = this.block_table[blockIndex];\n    if(!block) {\n        block = this.block_table[blockIndex] = new Block(this.block_size);\n    }\n\n    var sizesIndex = index & this.block_mask;\n    var sizes = block.sizes;\n    var oldValue = sizes[sizesIndex];\n    if(oldValue === value) {\n        return;\n    }\n\n    if(oldValue !== oldValue) {\n        block.defaultCount -= 1;\n        block.sizesSum += value;\n    } else if(value !== value) {\n        block.defaultCount += 1;\n        block.sizesSum -= oldValue;\n    } else {\n        block.sizesSum += value - oldValue;\n    }\n\n    sizes[sizesIndex] = value;\n}\n\n/**\n * Make room for a new item at index by shifting all of the sizes\n * one position to the right, beginning with startIndex.\n *\n * The value at index will be NaN.\n *\n * This is similar to array.splice(index, 0, NaN).\n *\n * @param index The position of the new NaN size item.\n */\nfunction insert(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.removes) {\n        flushPendingChanges.call(this);\n    }\n\n    if(this.inserts) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.inserts.length - 1;\n        var intervalEnd = this.inserts[lastIndex];\n\n        if(index === intervalEnd + 1) {\n            // Extend the end of the interval\n            this.inserts[lastIndex] = index;\n        } else if(index > intervalEnd) {\n            // New interval\n            this.inserts.push(index);\n            this.inserts.push(index);\n        } else {\n            // We can't support pending inserts that are not ascending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = Math.max(this._length, index + 1);\n\n    if(!this.inserts) {\n        this.inserts = [];\n        this.inserts.push(index);\n        this.inserts.push(index);\n    }\n}\n\n/**\n * Remove index by shifting all of the sizes one position to the left,\n * begining with index+1.\n *\n * This is similar to array.splice(index, 1).\n *\n * @param index The position to be removed.\n */\nfunction remove(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.inserts) {\n        flushPendingChanges.call(this);\n    }\n\n    // length getter takes into account pending inserts/removes but doesn't flush\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    if(this.removes) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.removes.length - 1;\n        var intervalStart = this.removes[lastIndex];\n\n        if(index === intervalStart - 1) {\n            // Extend the start of the interval\n            this.removes[lastIndex] = index;\n        } else if(index < intervalStart) {\n            // New interval\n            this.removes.push(index);\n            this.removes.push(index);\n        } else {\n            // We can't support pending removes that are not descending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = (this._pendingLength === -1) ? length - 1 : this._pendingLength - 1;\n\n    if(!this.removes) {\n        this.removes = [];\n        this.removes.push(index);\n        this.removes.push(index);\n    }\n}\n\n/**\n * @private\n * Returns true when all sizes in the specified interval for the block are NaN\n */\nfunction isIntervalClear(block, index, count) {\n    var sizes = block.sizes, size;\n    for(count += index; index < count; ++index) {\n        if((size = sizes[index]) === size) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @private\n * Copies elements between blocks. Indices relative to the blocks.\n * If srcBlock is null, then it fills the destination with NaNs.\n * The case of srcBlock === dstBlock is also supported.\n * The caller must ensure that count is within range.\n */\nfunction inBlockCopy(dstBlock, dstIndexStart, srcBlock, srcIndexStart, count) {\n    var ascending = dstIndexStart < srcIndexStart;\n\n    var srcIndex = ascending ? srcIndexStart : srcIndexStart + count - 1;\n    var dstIndex = ascending ? dstIndexStart : dstIndexStart + count - 1;\n    var increment = ascending ? +1 : -1;\n\n    var dstSizes = dstBlock.sizes;\n    var srcSizes = srcBlock ? srcBlock.sizes : null;\n    var dstValue = NaN;\n    var srcValue = NaN;\n    var sizesSumDelta = 0; // How much the destination sizesSum will change\n    var defaultCountDelta = 0; // How much the destination defaultCount will change\n\n    while(count > 0) {\n        if(srcSizes) {\n            srcValue = srcSizes[srcIndex];\n        }\n\n        dstValue = dstSizes[dstIndex];\n\n        // Are the values different?\n        if(srcValue !== dstValue) { // Triple '=' to handle NaN comparison\n\n            // Are we removing a default size or a chached size?\n            if(dstValue !== dstValue) {\n                defaultCountDelta--;\n            } else {\n                sizesSumDelta -= dstValue;\n            }\n\n            // Are we adding a default size or a cached size?\n            if(srcValue !== srcValue) {\n                defaultCountDelta++;\n            } else {\n                sizesSumDelta += srcValue;\n            }\n\n            dstSizes[dstIndex] = srcValue;\n        }\n\n        srcIndex += increment;\n        dstIndex += increment;\n        count--;\n    }\n\n    dstBlock.sizesSum += sizesSumDelta;\n    dstBlock.defaultCount += defaultCountDelta;\n}\n\n/**\n * @private\n * Copies 'count' elements from dstIndex to srcIndex.\n * Safe for overlapping source and destination intervals.\n * If any blocks are left full of NaNs, they will be deallcated.\n */\nfunction copyInterval(dstIndex, srcIndex, count) {\n    var ascending = dstIndex < srcIndex;\n    if(!ascending) {\n        dstIndex += count - 1;\n        srcIndex += count - 1;\n    }\n\n    while(count > 0) {\n        // Figure out destination block\n        var dstBlockIndex = dstIndex >> this.block_shift;\n        var dstSizesIndex = dstIndex & this.block_mask;\n        var dstBlock = this.block_table[dstBlockIndex];\n\n        // Figure out source block\n        var srcBlockIndex = srcIndex >> this.block_shift;\n        var srcSizesIndex = srcIndex & this.block_mask;\n        var srcBlock = this.block_table[srcBlockIndex];\n\n        // Figure out number of elements to copy\n        var copyCount = ascending ?\n            Math.min(this.block_size - dstSizesIndex, this.block_size - srcSizesIndex) :\n            1 + Math.min(dstSizesIndex, srcSizesIndex);\n\n        copyCount = Math.min(copyCount, count);\n\n        // Figure out the start index for each block\n        var dstStartIndex = ascending ? dstSizesIndex : dstSizesIndex - copyCount + 1;\n        var srcStartIndex = ascending ? srcSizesIndex : srcSizesIndex - copyCount + 1;\n\n        // Check whether a destination block needs to be allocated.\n        // Allocate only if there are non-default values to be copied from the source.\n        if(srcBlock && !dstBlock && isIntervalClear(srcBlock, srcStartIndex, copyCount)) {\n            dstBlock = new Block(this.block_size);\n            this.block_table[dstBlockIndex] = dstBlock;\n        }\n\n        // Copy to non-null dstBlock, srcBlock can be null\n        if(dstBlock) {\n            inBlockCopy(dstBlock, dstStartIndex, srcBlock, srcStartIndex, copyCount);\n\n            // If this is the last time we're visiting this block, and it contains\n            // only NaNs, then remove it\n            if(dstBlock.defaultCount === this.block_size) {\n                var blockEndReached = ascending ?\n                    (dstStartIndex + copyCount === this.block_size) :\n                    (dstStartIndex === 0);\n                if(blockEndReached || count === copyCount)\n                    this.block_table[dstBlockIndex] = null;\n            }\n        }\n\n        dstIndex += ascending ? copyCount : -copyCount;\n        srcIndex += ascending ? copyCount : -copyCount;\n        count -= copyCount;\n    }\n}\n\n/**\n * @private\n * Sets all elements within the specified interval to NaN (both ends inclusive).\n * Releases empty blocks.\n */\nfunction clearInterval(start, end) {\n    while(start <= end) {\n        // Figure our destination block\n        var blockIndex = start >> this.block_shift;\n        var sizesIndex = start & this.block_mask;\n        var block = this.block_table[blockIndex];\n\n        // Figure out number of elements to clear in this iteration\n        // Make sure we don't clear more items than requested\n        var clearCount = this.block_size - sizesIndex;\n        clearCount = Math.min(clearCount, end - start + 1);\n\n        if(block) {\n            if(clearCount === this.block_size) {\n                this.block_table[blockIndex] = null;\n            } else {\n                // Copying from null source block is equivalent of clearing the destination block\n                inBlockCopy(block, sizesIndex, null /*srcBlock*/, 0, clearCount);\n\n                // If the blockDst contains only default sizes, then remove the block\n                if(block.defaultCount === this.block_size) {\n                    this.block_table[blockIndex] = null;\n                }\n            }\n        }\n\n        start += clearCount;\n    }\n}\n\n/**\n * @private\n * Removes the elements designated by the intervals and truncates\n * the LinearLayoutVector to the new length.\n * 'intervals' is a Vector of descending intervals [7, 5, 3, 1]\n */\nfunction removeIntervals(intervals) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Adding final nextIntervalStart value (see below).\n    intervals.reverse(); // turn into ascending, for example [7, 5, 3, 1] --> [1, 3, 5, 7]\n    intervals.push(this.getLength());\n\n    // Move the elements\n    var dstStart = intervals[0];\n    var srcStart;\n    var count;\n    var i = 0;\n    do {\n        var intervalEnd = intervals[i + 1];\n        var nextIntervalStart = intervals[i + 2]\n        i += 2;\n\n        // Start copy from after the end of current interval\n        srcStart = intervalEnd + 1;\n\n        // copy all elements up to the start of the next interval.\n        count = nextIntervalStart - srcStart;\n\n        copyInterval.call(this, dstStart, srcStart, count);\n        dstStart += count;\n    } while(i < intervalsCount)\n\n    // Truncate the excess elements.\n    this.setLength(dstStart);\n}\n\n/**\n * @private\n * Increases the length and inserts NaN values for the elements designated by the intervals.\n * 'intervals' is a Vector of ascending intervals [1, 3, 5, 7]\n */\nfunction insertIntervals(intervals, newLength) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Allocate enough space for the insertions, all the elements\n    // allocated are NaN by default.\n    var oldLength = this.getLength();\n    this.setLength(newLength);\n\n    var srcEnd = oldLength - 1;\n    var dstEnd = newLength - 1;\n    var i = intervalsCount - 2;\n    while(i >= 0) {\n        // Find current interval\n        var intervalStart = intervals[i];\n        var intervalEnd = intervals[i + 1];\n        i -= 2;\n\n        // Start after the current interval\n        var dstStart = intervalEnd + 1;\n        var copyCount = dstEnd - dstStart + 1;\n        var srcStart = srcEnd - copyCount + 1;\n\n        copyInterval.call(this, dstStart, srcStart, copyCount);\n        dstStart -= copyCount;\n        dstEnd = intervalStart - 1;\n\n        // Fill in with default NaN values after the copy\n        clearInterval.call(this, intervalStart, intervalEnd);\n    }\n}\n\n/**\n * @private\n * Processes any pending removes or pending inserts.\n */\nfunction flushPendingChanges() {\n    var intervals;\n    if(this.removes) {\n        intervals = this.removes;\n        this.removes = null;\n        this._pendingLength = -1;\n        removeIntervals.call(this, intervals);\n    } else if(this.inserts) {\n        intervals = this.inserts;\n        var newLength = this._pendingLength;\n        this.inserts = null;\n        this._pendingLength = -1;\n        insertIntervals.call(this, intervals, newLength);\n    }\n}\n\n/**\n * The cumulative distance to the start of the item at index, including\n * the gaps between items and the axisOffset.\n *\n * The value of start(0) is axisOffset.\n *\n * Equivalent to:\n * <pre>\n * var distance = this.getAxisOffset();\n * for (var i = 0; i &lt; index; i++)\n *     distance += get(i);\n * return distance + (gap * index);\n * </pre>\n *\n * The actual implementation is relatively efficient.\n *\n * @param index The item's index.\n * @see #end\n */\nfunction start(index) {\n\n    flushPendingChanges.call(this);\n\n    if((this._length === 0) || (index === 0)) {\n        return this.getAxisOffset();\n    }\n\n    if(index >= this._length) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var distance = this.getAxisOffset();\n    var blockIndex = index >> this.block_shift;\n    for(var i = 0; i < blockIndex; i++)\n    {\n        var block = this.block_table[i];\n        distance += block ?\n            block.sizesSum + (block.defaultCount * this._defaultSize) :\n            this.block_size * this._defaultSize;\n    }\n    var lastBlock = this.block_table[blockIndex];\n    var lastBlockOffset = index & ~this.block_mask;\n    var lastBlockLength = index - lastBlockOffset;\n    if(lastBlock) {\n        var sizes = lastBlock.sizes;\n        for(i = 0; i < lastBlockLength; i++) {\n            var size = sizes[i];\n            distance += (size !== size) ? this._defaultSize : size;\n        }\n    } else {\n        distance += this._defaultSize * lastBlockLength;\n    }\n    distance += index * this.getGap();\n    return distance;\n}\n\n/**\n * The cumulative distance to the end of the item at index, including\n * the gaps between items.\n *\n * If <code>index &lt;(length-1)</code> then the value of this\n * function is defined as:\n * <code>start(index) + get(index)</code>.\n *\n * @param index The item's index.\n * @see #start\n */\nfunction end(index) {\n    flushPendingChanges.call(this);\n    return this.start(index) + this.getItemSize(index);\n}\n\n/**\n * Returns the index of the item that overlaps the specified distance.\n *\n * The item at index <code>i</code> overlaps a distance value\n * if <code>start(i) &lt;= distance &lt; end(i)</code>.\n *\n * If no such item exists, -1 is returned.\n */\nfunction indexOf(distance) {\n    flushPendingChanges.call(this);\n    var index = indexOfInternal.call(this, distance);\n    return (index >= this._length) ? -1 : index;\n}\n\nfunction indexOfInternal(distance) {\n\n    if((this._length === 0) || (distance < 0)) {\n        return -1;\n    }\n\n    // The area of the first item includes the axisOffset\n    var curDistance = this.getAxisOffset();\n\n    if(distance < curDistance) {\n        return 0;\n    }\n\n    var index = -1,\n        block = null,\n        blockSize = this.block_size,\n        defaultSize = this._defaultSize,\n        gap = this.getGap(),\n        blockGap = gap * blockSize;\n\n    // Find the block that contains distance and the index of its\n    // first element\n    var blockIndex = -1,\n        blockTable = this.block_table,\n        blockTableLength = blockTable.length;\n\n    for(; ++blockIndex < blockTableLength;) {\n        block = blockTable[blockIndex];\n        var blockDistance = blockGap + (\n            block ?\n                block.sizesSum + (block.defaultCount * defaultSize) :\n                blockSize * defaultSize\n        );\n\n        if((distance === curDistance) || ((distance >= curDistance) && (distance < (curDistance + blockDistance)))) {\n            index = blockIndex << this.block_shift;\n            break;\n        }\n        curDistance += blockDistance;\n    }\n\n    if((index === -1) || (distance === curDistance)) {\n        return index;\n    }\n\n    // At this point index corresponds to the first item in this block\n    if(block) {\n        // Find the item that contains distance and return its index\n        var sizes = block.sizes,\n            n = this.block_size - 1;\n        for(var i = 0; i < n; i++) {\n            var size = sizes[i];\n            curDistance += gap + (size !== size ? this._defaultSize : size);\n            if(curDistance > distance) {\n                return index + i;\n            }\n        }\n        // TBD special-case for the very last index\n        return index + this.block_size - 1;\n    } else {\n        return index + Math.floor(Number(distance - curDistance) / Number(this._defaultSize + gap));\n    }\n}\n\n/**\n * Clear all cached state, reset length to zero.\n */\nfunction clear() {\n    // Discard any pending changes, before setting the length\n    // otherwise the length setter will commit the changes.\n    this.removes = null;\n    this.inserts = null;\n    this._pendingLength = -1;\n\n    this.setLength(0); // clears the this.block_table as well\n}\n\nfunction toString() {\n    return \"SparseArray {\" +\n        \"length: \" + this._length + \", \" +\n        \"size: \" + this.end(this.getLength() -1) + \", \" +\n        \"[blocks: \" + this.block_table.length + \"]\" + \", \" +\n        \"gap: \" + this._gap + \", \" +\n        \"defaultSize: \" + this._defaultSize + \", \" +\n        \"pendingRemoves: \" + (this.removes ? this.removes.length : 0) + \", \" +\n        \"pendingInserts: \" + (this.inserts ? this.inserts.length : 0) +\n        \"}\";\n}\n\n/**\n * @private\n * A SparseArray block of layout element heights or widths.\n *\n * Total \"distance\" for a Block is: sizesSum + (defaultCount * distanceVector.default).\n */\nfunction Block(block_size) {\n\n    this.sizes = new Array(block_size);\n    this.sizesSum = 0;\n    this.defaultCount = block_size;\n\n    for(var i = -1; ++i < block_size;) {\n        this.sizes[i] = NaN;\n    }\n}\n\nexport { SparseArray };\n"]}