{"version":3,"sources":["../src/SparseArray.js"],"names":[],"mappings":"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","file":"SparseArray.js","sourcesContent":["SparseArray.prototype.getLength = getLength;\nSparseArray.prototype.setLength = setLength;\nSparseArray.prototype.getDefaultSize = getDefaultSize;\nSparseArray.prototype.setDefaultSize = setDefaultSize;\nSparseArray.prototype.getAxisOffset = getAxisOffset;\nSparseArray.prototype.setAxisOffset = setAxisOffset;\nSparseArray.prototype.getGap = getGap;\nSparseArray.prototype.setGap = setGap;\nSparseArray.prototype.getItemSize = getItemSize;\nSparseArray.prototype.setItemSize = setItemSize;\nSparseArray.prototype.insert = insert;\nSparseArray.prototype.remove = remove;\nSparseArray.prototype.start = start;\nSparseArray.prototype.end = end;\nSparseArray.prototype.indexOf = indexOf;\nSparseArray.prototype.clear = clear;\nSparseArray.prototype.toString = toString;\n\n/**\n * A sparse array of sizes that represent items in a dimension.\n *\n * Provides efficient support for finding the cumulative distance to\n * the start/end of an item along the axis, and similarly for finding the\n * index of the item at a particular distance.\n *\n * Default size is used for items whose size hasn't been specified.\n */\nfunction SparseArray(block_size) {\n\n    if(block_size === undefined) {\n        block_size = 128;\n    }\n\n    // Assumption: vector elements (sizes) will typically be set in\n    // small ranges that reflect localized scrolling.  Allocate vector\n    // elements in blocks of block_size, which must be a power of 2.\n    // block_shift is the power of 2 and block_mask masks off as many\n    // low order bits.  The block_table contains all of the allocated\n    // blocks and has length/block_size elements which are allocated lazily.\n    var pow = (Math.log(block_size) / Math.log(2)) | 0,\n        size = Math.pow(2, pow),\n        mask = size - 1;\n\n    this.block_size  = size;\n    this.block_shift = pow;\n    this.block_mask  = mask;\n    this.block_table = [];\n\n    this._defaultSize = 0;\n    this._axisOffset = 0;\n    this._gap = 0;\n\n    // Sorted Vector of intervals for the pending removes, in descending order,\n    // for example [7, 5, 3, 1] for the removes at 7, 6, 5, 3, 2, 1\n    this.removes = null;\n    // Sorted Vector of intervals for the pending inserts, in ascending order,\n    // for example [1, 3, 5, 7] for the inserts at 1, 2, 3, 5, 6, 7\n    this.inserts = null;\n\n    this._length = 0;\n    // What the length will be after any pending changes are flushed.\n    this._pendingLength = -1;\n}\n\n/**\n * The number of item size valued elements.\n *\n * @default 0\n */\nfunction getLength() {\n    return this._pendingLength === -1 ? this._length : this._pendingLength;\n}\n\n/**\n * @private\n * Grows or truncates the vector to be the specified newLength.\n * When truncating, releases empty blocks and sets to NaN any values\n * in the last block beyond the newLength.\n */\nfunction setLength(newLength) {\n    flushPendingChanges.call(this);\n\n    if(newLength < this._length) {\n        // Clear any remaining non-NaN values in the last block\n        var blockIndex = newLength >> this.block_shift;\n        var endIndex = Math.min(blockIndex * this.block_size + this.block_size, this._length) - 1;\n        clearInterval.call(this, newLength, endIndex);\n    }\n\n    this._length = newLength;\n\n    // update the table\n    var partialBlock = ((this._length & this.block_mask) === 0) ? 0 : 1;\n    this.block_table.length = (this._length >> this.block_shift) + partialBlock;\n}\n\n//----------------------------------\n//  defaultSize\n//----------------------------------\n\n/**\n * The size of items whose size was not specified with setItemSize.\n *\n * @default 0\n */\nfunction getDefaultSize() {\n    return this._defaultSize;\n}\n\n/**\n * @private\n */\nfunction setDefaultSize(value) {\n    this._defaultSize = value;\n}\n\n//----------------------------------\n//  axisOffset\n//----------------------------------\n\n/**\n * The offset of the first item from the origin in the majorAxis\n * direction. This is useful when implementing padding,\n * in addition to gaps, for virtual layouts.\n *\n * @see #gap\n */\nfunction getAxisOffset() {\n    return this._axisOffset;\n}\n\n/**\n * @private\n */\nfunction setAxisOffset(value) {\n    this._axisOffset = value;\n}\n\n//----------------------------------\n//  gap\n//----------------------------------\n\n/**\n * The distance between items.\n *\n * @default 0\n */\nfunction getGap() {\n    return this._gap;\n}\n\n/**\n * @private\n */\nfunction setGap(value) {\n    this._gap = value;\n}\n\n//--------------------------------------------------------------------------\n//\n//  Methods\n//\n//--------------------------------------------------------------------------\n\n/**\n * Return the size of the item at index.  If no size was ever\n * specified then then the defaultSize is returned.\n *\n * @param index The item's index.\n * @see defaultSize\n */\nfunction getItemSize(index) {\n    flushPendingChanges.call(this);\n\n    var block = this.block_table[index >> this.block_shift];\n    if(block) {\n        var value = block.sizes[index & this.block_mask];\n        return (value !== value) ? this._defaultSize : value;\n    } else {\n        return this._defaultSize;\n    }\n}\n\n/**\n * Set the size of the item at index. If an index is\n * set to <code>NaN</code> then subsequent calls to get\n * will return the defaultSize.\n *\n * @param index The item's index.\n * @param value The item's size.\n * @see defaultSize\n */\nfunction setItemSize(index, value) {\n    flushPendingChanges.call(this);\n\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var blockIndex = index >> this.block_shift;\n    var block = this.block_table[blockIndex];\n    if(!block) {\n        block = this.block_table[blockIndex] = new Block(this.block_size);\n    }\n\n    var sizesIndex = index & this.block_mask;\n    var sizes = block.sizes;\n    var oldValue = sizes[sizesIndex];\n    if(oldValue === value) {\n        return;\n    }\n\n    if(oldValue !== oldValue) {\n        block.defaultCount -= 1;\n        block.sizesSum += value;\n    } else if(value !== value) {\n        block.defaultCount += 1;\n        block.sizesSum -= oldValue;\n    } else {\n        block.sizesSum += value - oldValue;\n    }\n\n    sizes[sizesIndex] = value;\n}\n\n/**\n * Make room for a new item at index by shifting all of the sizes\n * one position to the right, beginning with startIndex.\n *\n * The value at index will be NaN.\n *\n * This is similar to array.splice(index, 0, NaN).\n *\n * @param index The position of the new NaN size item.\n */\nfunction insert(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.removes) {\n        flushPendingChanges.call(this);\n    }\n\n    if(this.inserts) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.inserts.length - 1;\n        var intervalEnd = this.inserts[lastIndex];\n\n        if(index === intervalEnd + 1) {\n            // Extend the end of the interval\n            this.inserts[lastIndex] = index;\n        } else if(index > intervalEnd) {\n            // New interval\n            this.inserts.push(index);\n            this.inserts.push(index);\n        } else {\n            // We can't support pending inserts that are not ascending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = Math.max(this._length, index + 1);\n\n    if(!this.inserts) {\n        this.inserts = [];\n        this.inserts.push(index);\n        this.inserts.push(index);\n    }\n}\n\n/**\n * Remove index by shifting all of the sizes one position to the left,\n * begining with index+1.\n *\n * This is similar to array.splice(index, 1).\n *\n * @param index The position to be removed.\n */\nfunction remove(index) {\n    // We don't support interleaved pending inserts and removes\n    if(this.inserts) {\n        flushPendingChanges.call(this);\n    }\n\n    // length getter takes into account pending inserts/removes but doesn't flush\n    if(index >= this.getLength()) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    if(this.removes) {\n        // Update the last interval or add a new one?\n        var lastIndex = this.removes.length - 1;\n        var intervalStart = this.removes[lastIndex];\n\n        if(index === intervalStart - 1) {\n            // Extend the start of the interval\n            this.removes[lastIndex] = index;\n        } else if(index < intervalStart) {\n            // New interval\n            this.removes.push(index);\n            this.removes.push(index);\n        } else {\n            // We can't support pending removes that are not descending\n            flushPendingChanges.call(this);\n        }\n    }\n\n    this._pendingLength = (this._pendingLength === -1) ? length - 1 : this._pendingLength - 1;\n\n    if(!this.removes) {\n        this.removes = [];\n        this.removes.push(index);\n        this.removes.push(index);\n    }\n}\n\n/**\n * @private\n * Returns true when all sizes in the specified interval for the block are NaN\n */\nfunction isIntervalClear(block, index, count) {\n    var sizes = block.sizes, size;\n    for(count += index; index < count; ++index) {\n        if((size = sizes[index]) === size) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * @private\n * Copies elements between blocks. Indices relative to the blocks.\n * If srcBlock is null, then it fills the destination with NaNs.\n * The case of srcBlock === dstBlock is also supported.\n * The caller must ensure that count is within range.\n */\nfunction inBlockCopy(dstBlock, dstIndexStart, srcBlock, srcIndexStart, count) {\n    var ascending = dstIndexStart < srcIndexStart;\n\n    var srcIndex = ascending ? srcIndexStart : srcIndexStart + count - 1;\n    var dstIndex = ascending ? dstIndexStart : dstIndexStart + count - 1;\n    var increment = ascending ? +1 : -1;\n\n    var dstSizes = dstBlock.sizes;\n    var srcSizes = srcBlock ? srcBlock.sizes : null;\n    var dstValue = NaN;\n    var srcValue = NaN;\n    var sizesSumDelta = 0; // How much the destination sizesSum will change\n    var defaultCountDelta = 0; // How much the destination defaultCount will change\n\n    while(count > 0) {\n        if(srcSizes) {\n            srcValue = srcSizes[srcIndex];\n        }\n\n        dstValue = dstSizes[dstIndex];\n\n        // Are the values different?\n        if(srcValue !== dstValue) { // Triple '=' to handle NaN comparison\n\n            // Are we removing a default size or a chached size?\n            if(dstValue !== dstValue) {\n                defaultCountDelta--;\n            } else {\n                sizesSumDelta -= dstValue;\n            }\n\n            // Are we adding a default size or a cached size?\n            if(srcValue !== srcValue) {\n                defaultCountDelta++;\n            } else {\n                sizesSumDelta += srcValue;\n            }\n\n            dstSizes[dstIndex] = srcValue;\n        }\n\n        srcIndex += increment;\n        dstIndex += increment;\n        count--;\n    }\n\n    dstBlock.sizesSum += sizesSumDelta;\n    dstBlock.defaultCount += defaultCountDelta;\n}\n\n/**\n * @private\n * Copies 'count' elements from dstIndex to srcIndex.\n * Safe for overlapping source and destination intervals.\n * If any blocks are left full of NaNs, they will be deallcated.\n */\nfunction copyInterval(dstIndex, srcIndex, count) {\n    var ascending = dstIndex < srcIndex;\n    if(!ascending) {\n        dstIndex += count - 1;\n        srcIndex += count - 1;\n    }\n\n    while(count > 0) {\n        // Figure out destination block\n        var dstBlockIndex = dstIndex >> this.block_shift;\n        var dstSizesIndex = dstIndex & this.block_mask;\n        var dstBlock = this.block_table[dstBlockIndex];\n\n        // Figure out source block\n        var srcBlockIndex = srcIndex >> this.block_shift;\n        var srcSizesIndex = srcIndex & this.block_mask;\n        var srcBlock = this.block_table[srcBlockIndex];\n\n        // Figure out number of elements to copy\n        var copyCount = ascending ?\n            Math.min(this.block_size - dstSizesIndex, this.block_size - srcSizesIndex) :\n            1 + Math.min(dstSizesIndex, srcSizesIndex);\n\n        copyCount = Math.min(copyCount, count);\n\n        // Figure out the start index for each block\n        var dstStartIndex = ascending ? dstSizesIndex : dstSizesIndex - copyCount + 1;\n        var srcStartIndex = ascending ? srcSizesIndex : srcSizesIndex - copyCount + 1;\n\n        // Check whether a destination block needs to be allocated.\n        // Allocate only if there are non-default values to be copied from the source.\n        if(srcBlock && !dstBlock && isIntervalClear(srcBlock, srcStartIndex, copyCount)) {\n            dstBlock = new Block(this.block_size);\n            this.block_table[dstBlockIndex] = dstBlock;\n        }\n\n        // Copy to non-null dstBlock, srcBlock can be null\n        if(dstBlock) {\n            inBlockCopy(dstBlock, dstStartIndex, srcBlock, srcStartIndex, copyCount);\n\n            // If this is the last time we're visiting this block, and it contains\n            // only NaNs, then remove it\n            if(dstBlock.defaultCount === this.block_size) {\n                var blockEndReached = ascending ?\n                    (dstStartIndex + copyCount === this.block_size) :\n                    (dstStartIndex === 0);\n                if(blockEndReached || count === copyCount)\n                    this.block_table[dstBlockIndex] = null;\n            }\n        }\n\n        dstIndex += ascending ? copyCount : -copyCount;\n        srcIndex += ascending ? copyCount : -copyCount;\n        count -= copyCount;\n    }\n}\n\n/**\n * @private\n * Sets all elements within the specified interval to NaN (both ends inclusive).\n * Releases empty blocks.\n */\nfunction clearInterval(start, end) {\n    while(start <= end) {\n        // Figure our destination block\n        var blockIndex = start >> this.block_shift;\n        var sizesIndex = start & this.block_mask;\n        var block = this.block_table[blockIndex];\n\n        // Figure out number of elements to clear in this iteration\n        // Make sure we don't clear more items than requested\n        var clearCount = this.block_size - sizesIndex;\n        clearCount = Math.min(clearCount, end - start + 1);\n\n        if(block) {\n            if(clearCount === this.block_size) {\n                this.block_table[blockIndex] = null;\n            } else {\n                // Copying from null source block is equivalent of clearing the destination block\n                inBlockCopy(block, sizesIndex, null /*srcBlock*/, 0, clearCount);\n\n                // If the blockDst contains only default sizes, then remove the block\n                if(block.defaultCount === this.block_size) {\n                    this.block_table[blockIndex] = null;\n                }\n            }\n        }\n\n        start += clearCount;\n    }\n}\n\n/**\n * @private\n * Removes the elements designated by the intervals and truncates\n * the LinearLayoutVector to the new length.\n * 'intervals' is a Vector of descending intervals [7, 5, 3, 1]\n */\nfunction removeIntervals(intervals) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Adding final nextIntervalStart value (see below).\n    intervals.reverse(); // turn into ascending, for example [7, 5, 3, 1] --> [1, 3, 5, 7]\n    intervals.push(this.getLength());\n\n    // Move the elements\n    var dstStart = intervals[0];\n    var srcStart;\n    var count;\n    var i = 0;\n    do {\n        var intervalEnd = intervals[i + 1];\n        var nextIntervalStart = intervals[i + 2]\n        i += 2;\n\n        // Start copy from after the end of current interval\n        srcStart = intervalEnd + 1;\n\n        // copy all elements up to the start of the next interval.\n        count = nextIntervalStart - srcStart;\n\n        copyInterval.call(this, dstStart, srcStart, count);\n        dstStart += count;\n    } while(i < intervalsCount)\n\n    // Truncate the excess elements.\n    this.setLength(dstStart);\n}\n\n/**\n * @private\n * Increases the length and inserts NaN values for the elements designated by the intervals.\n * 'intervals' is a Vector of ascending intervals [1, 3, 5, 7]\n */\nfunction insertIntervals(intervals, newLength) {\n    var intervalsCount = intervals.length;\n    if(intervalsCount === 0) {\n        return;\n    }\n\n    // Allocate enough space for the insertions, all the elements\n    // allocated are NaN by default.\n    var oldLength = this.getLength();\n    this.setLength(newLength);\n\n    var srcEnd = oldLength - 1;\n    var dstEnd = newLength - 1;\n    var i = intervalsCount - 2;\n    while(i >= 0) {\n        // Find current interval\n        var intervalStart = intervals[i];\n        var intervalEnd = intervals[i + 1];\n        i -= 2;\n\n        // Start after the current interval\n        var dstStart = intervalEnd + 1;\n        var copyCount = dstEnd - dstStart + 1;\n        var srcStart = srcEnd - copyCount + 1;\n\n        copyInterval.call(this, dstStart, srcStart, copyCount);\n        dstStart -= copyCount;\n        dstEnd = intervalStart - 1;\n\n        // Fill in with default NaN values after the copy\n        clearInterval.call(this, intervalStart, intervalEnd);\n    }\n}\n\n/**\n * @private\n * Processes any pending removes or pending inserts.\n */\nfunction flushPendingChanges() {\n    var intervals;\n    if(this.removes) {\n        intervals = this.removes;\n        this.removes = null;\n        this._pendingLength = -1;\n        removeIntervals.call(this, intervals);\n    } else if(this.inserts) {\n        intervals = this.inserts;\n        var newLength = this._pendingLength;\n        this.inserts = null;\n        this._pendingLength = -1;\n        insertIntervals.call(this, intervals, newLength);\n    }\n}\n\n/**\n * The cumulative distance to the start of the item at index, including\n * the gaps between items and the axisOffset.\n *\n * The value of start(0) is axisOffset.\n *\n * Equivalent to:\n * <pre>\n * var distance = this.getAxisOffset();\n * for (var i = 0; i &lt; index; i++)\n *     distance += get(i);\n * return distance + (gap * index);\n * </pre>\n *\n * The actual implementation is relatively efficient.\n *\n * @param index The item's index.\n * @see #end\n */\nfunction start(index) {\n\n    flushPendingChanges.call(this);\n\n    if((this._length === 0) || (index === 0)) {\n        return this.getAxisOffset();\n    }\n\n    if(index >= this._length) {\n        throw new Error(\"Invalid index and all that.\");\n    }\n\n    var distance = this.getAxisOffset();\n    var blockIndex = index >> this.block_shift;\n    for(var i = 0; i < blockIndex; i++)\n    {\n        var block = this.block_table[i];\n        distance += block ?\n            block.sizesSum + (block.defaultCount * this._defaultSize) :\n            this.block_size * this._defaultSize;\n    }\n    var lastBlock = this.block_table[blockIndex];\n    var lastBlockOffset = index & ~this.block_mask;\n    var lastBlockLength = index - lastBlockOffset;\n    if(lastBlock) {\n        var sizes = lastBlock.sizes;\n        for(i = 0; i < lastBlockLength; i++) {\n            var size = sizes[i];\n            distance += (size !== size) ? this._defaultSize : size;\n        }\n    } else {\n        distance += this._defaultSize * lastBlockLength;\n    }\n    distance += index * this.getGap();\n    return distance;\n}\n\n/**\n * The cumulative distance to the end of the item at index, including\n * the gaps between items.\n *\n * If <code>index &lt;(length-1)</code> then the value of this\n * function is defined as:\n * <code>start(index) + get(index)</code>.\n *\n * @param index The item's index.\n * @see #start\n */\nfunction end(index) {\n    flushPendingChanges.call(this);\n    return this.start(index) + this.getItemSize(index);\n}\n\n/**\n * Returns the index of the item that overlaps the specified distance.\n *\n * The item at index <code>i</code> overlaps a distance value\n * if <code>start(i) &lt;= distance &lt; end(i)</code>.\n *\n * If no such item exists, -1 is returned.\n */\nfunction indexOf(distance) {\n    flushPendingChanges.call(this);\n    var index = indexOfInternal.call(this, distance);\n    return (index >= this._length) ? -1 : index;\n}\n\nfunction indexOfInternal(distance) {\n\n    if((this._length === 0) || (distance < 0)) {\n        return -1;\n    }\n\n    // The area of the first item includes the axisOffset\n    var curDistance = this.getAxisOffset();\n\n    if(distance < curDistance) {\n        return 0;\n    }\n\n    var index = -1,\n        block = null,\n        blockSize = this.block_size,\n        defaultSize = this._defaultSize,\n        gap = this.getGap(),\n        blockGap = gap * blockSize;\n\n    // Find the block that contains distance and the index of its\n    // first element\n    var blockIndex = -1,\n        blockTable = this.block_table,\n        blockTableLength = blockTable.length;\n\n    for(; ++blockIndex < blockTableLength;) {\n        block = blockTable[blockIndex];\n        var blockDistance = blockGap + (\n            block ?\n                block.sizesSum + (block.defaultCount * defaultSize) :\n                blockSize * defaultSize\n        );\n\n        if((distance === curDistance) || ((distance >= curDistance) && (distance < (curDistance + blockDistance)))) {\n            index = blockIndex << this.block_shift;\n            break;\n        }\n        curDistance += blockDistance;\n    }\n\n    if((index === -1) || (distance === curDistance)) {\n        return index;\n    }\n\n    // At this point index corresponds to the first item in this block\n    if(block) {\n        // Find the item that contains distance and return its index\n        var sizes = block.sizes,\n            n = this.block_size - 1;\n        for(var i = 0; i < n; i++) {\n            var size = sizes[i];\n            curDistance += gap + (size !== size ? this._defaultSize : size);\n            if(curDistance > distance) {\n                return index + i;\n            }\n        }\n        // TBD special-case for the very last index\n        return index + this.block_size - 1;\n    } else {\n        return index + Math.floor(Number(distance - curDistance) / Number(this._defaultSize + gap));\n    }\n}\n\n/**\n * Clear all cached state, reset length to zero.\n */\nfunction clear() {\n    // Discard any pending changes, before setting the length\n    // otherwise the length setter will commit the changes.\n    this.removes = null;\n    this.inserts = null;\n    this._pendingLength = -1;\n\n    this.setLength(0); // clears the this.block_table as well\n}\n\nfunction toString() {\n    return \"SparseArray {\" +\n        \"length: \" + this._length + \", \" +\n        \"size: \" + this.end(this.getLength() -1) + \", \" +\n        \"[blocks: \" + this.block_table.length + \"]\" + \", \" +\n        \"gap: \" + this._gap + \", \" +\n        \"defaultSize: \" + this._defaultSize + \", \" +\n        \"pendingRemoves: \" + (this.removes ? this.removes.length : 0) + \", \" +\n        \"pendingInserts: \" + (this.inserts ? this.inserts.length : 0) +\n        \"}\";\n}\n\n/**\n * @private\n * A SparseArray block of layout element heights or widths.\n *\n * Total \"distance\" for a Block is: sizesSum + (defaultCount * distanceVector.default).\n */\nfunction Block(block_size) {\n\n    this.sizes = new Array(block_size);\n    this.sizesSum = 0;\n    this.defaultCount = block_size;\n\n    for(var i = -1; ++i < block_size;) {\n        this.sizes[i] = NaN;\n    }\n}\n\nexport { SparseArray };\n"]}