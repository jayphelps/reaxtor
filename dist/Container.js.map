{"version":3,"sources":["../src/Container.js"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA;;;;;;;;IAEa,S,WAAA,S;;;;;;;;;;;uCACM,M,EAAQ;AAAA;;AACnB,gBAAI,WAAW,EAAf;AACA,gBAAI,WAAW,EAAf;AACA,mBAAO,OAAO,SAAP,CAAiB,UAAC,KAAD,EAAW;AAC/B,oBAAM,OAAO,OAAK,KAAL,CAAW,QAAX,EAAqB,QAArB,EAA+B,KAA/B,CAAb;AACA,oBAAI,KAAK,MAAL,KAAgB,CAApB,EAAuB;AACnB,2BAAO,uBAAW,EAAX,CAAc,CAAC,KAAD,CAAd,CAAP;AACH;AACD,uBAAO,uBAAW,aAAX,CACH,WAAW,IADR,EACc;AAAA,sDAAI,IAAJ;AAAI,4BAAJ;AAAA;;AAAA,4BAAc,KAAd,SAAwB,IAAxB;AAAA,iBADd,CAAP;AAGH,aARM,CAAP;AASH;;;8BACK,Q,EAAU,Q,QAA0C;AAAA;;AAAA,gBAA9B,MAA8B;AAAA,gBAAtB,MAAsB;AAAA,gBAAZ,KAAY,yDAAJ,EAAI;AAAA,8BAKlD,KALkD,CAGlD,IAHkD;AAAA,gBAGlD,IAHkD,+BAG3C,CAH2C;AAAA,4BAKlD,KALkD,CAIlD,EAJkD;AAAA,gBAIlD,EAJkD,6BAI7C,OAAO,MAJsC;;AAMtD,gBAAI,QAAQ,CAAC,CAAb;AACA,gBAAI,QAAQ,KAAK,IAAjB;;AAEA,mBAAO,EAAE,KAAF,IAAW,KAAlB,EAAyB;AACrB,oBAAI,CAAC,SAAS,KAAT,CAAL,EAAsB;AAClB,6BAAS,KAAT,IAAkB,sBAAlB;AACA,6BAAS,KAAT,IAAkB,KAAK,WAAL,CAAiB,SAAS,KAAT,CAAjB,EAAkC,OAAO,KAAP,CAAlC,EAAiD,KAAjD,CAAlB;AACH;AACJ;;AAED,oBAAQ,QAAQ,CAAhB;AACA,qBAAS,MAAT,GAAkB,KAAlB;AACA,oBAAQ,SAAS,MAAjB;AACA,mBAAO,EAAE,KAAF,GAAU,KAAjB,EAAwB;AACpB,yBAAS,KAAT,EAAgB,QAAhB;AACH;;AAED,oBAAQ,CAAC,CAAT;AACA,oBAAQ,SAAS,MAAT,GAAkB,SAAS,MAAnC;AACA,mBAAO,EAAE,KAAF,GAAU,KAAjB,EAAwB;AACpB,oBAAM,QAAQ,OAAO,QAAQ,IAAf,CAAd;AACA,oBAAI,SAAS,QAAO,KAAP,yCAAO,KAAP,OAAiB,QAA9B,EAAwC;AACpC,wBAAM,QAAQ,OAAO,KAAP,CAAa,KAAb,CAAd;AACA,6BAAS,KAAT,EAAgB,IAAhB,CAAqB,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAArB;AACH;AACJ;;AAED,mBAAO,QAAP;AACH","file":"Container.js","sourcesContent":["import { Subject } from 'rxjs/Subject';\nimport { Component } from './Component';\nimport { Observable } from 'rxjs/Observable';\n\nexport class Container extends Component {\n    createChildren(models) {\n        var subjects = [];\n        var children = [];\n        return models.switchMap((tuple) => {\n            const kids = this.deref(subjects, children, tuple);\n            if (kids.length === 0) {\n                return Observable.of([tuple]);\n            }\n            return Observable.combineLatest(\n                children = kids, (...args) => [tuple, ...args]\n            );\n        });\n    }\n    deref(subjects, children, [ _model, _state ], range = {}) {\n\n        const {\n            from = 0,\n            to = _state.length\n        } = range;\n        let index = -1;\n        let count = to - from;\n\n        while (++index <= count) {\n            if (!subjects[index]) {\n                subjects[index] = new Subject();\n                children[index] = this.createChild(subjects[index], _state[index], index);\n            }\n        }\n\n        index = count - 1;\n        children.length = count;\n        count = subjects.length;\n        while (++index < count) {\n            subjects[index].complete();\n        }\n\n        index = -1;\n        count = subjects.length = children.length;\n        while (++index < count) {\n            const state = _state[index + from];\n            if (state && typeof state === 'object') {\n                const model = _model.deref(state);\n                subjects[index].next([model, state, index]);\n            }\n        }\n\n        return children;\n    }\n}\n"]}